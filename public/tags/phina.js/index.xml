<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Phina.js on Keep On Coding</title>
    <link>https://alkn203.github.io/blog/tags/phina.js/</link>
    <description>Recent content in Phina.js on Keep On Coding</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Tue, 02 Jul 2019 20:55:06 +0900</lastBuildDate>
    
	<atom:link href="https://alkn203.github.io/blog/tags/phina.js/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>【phina.js】Tweenerとupdateを使ってShapeの色を変化させる</title>
      <link>https://alkn203.github.io/blog/posts/tips/phina-tweener-color/</link>
      <pubDate>Tue, 02 Jul 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/posts/tips/phina-tweener-color/</guid>
      <description>はじめに phina.jsのTweenerはキャラクターの動きをコントロールする場合などに使えるとても勉強な機能です。今回は、Tweenerとupdateを併用したTipsを紹介します。
Shapeの色変化アニメーション Shapeの色を一定時間で変化させるアニメーションを作ります。方法は以下のとおりです。
 Shapeにrgbの3つのプロパティを追加する。 Shapeのtweenerでプロパティの値を変化させる。 Shapeのupdateでプロパティの値を使って色を変化させる。  プロパティを追加する javascriptは、後から好きな時にプロパティを追加できる柔軟さを持ってますので、これを利用します。
// shape var shape = StarShape().addChildTo(this); shape.setPosition(this.gridX.center(), this.gridY.center()); shape.radius = 128; // プロパティ追加 shape.r = 0; shape.g = 0; shape.b = 0;  プロパティ値を変化させる 追加したプロパティ値をtweenerで変化させます。
// プロパティ値変化 shape.tweener.to({r: 10, g: 100, b: 200}, 2000) .to({r: 200, g: 200, b: 10}, 2000) .setLoop(true).play();  色を変化させる  updateでShapeの塗りつぶし色であるfillにプロパティ値を代入します。 rgbは文字列指定する必要があるため、formatメソッドの引数から渡しています。  // 毎フレーム処理 shape.update = function() { // 色指定 shape.fill = &#39;rgb({0}, {1}, {2})&#39;.</description>
    </item>
    
    <item>
      <title>【phina.js】タイマーゲージを作ってみた</title>
      <link>https://alkn203.github.io/blog/posts/tips/phina-timergauge/</link>
      <pubDate>Mon, 01 Jul 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/posts/tips/phina-timergauge/</guid>
      <description>はじめに phina.jsには、体力ゲージの実装に使えるGaugeという便利なクラスが用意されています。今回、これをベースにゲームの制限時間表示によく見られるタイマーゲージを作ってみました。
実行サンプル   runボタンを押すとゲージが経過時間で減っていきます。 pauseボタンで一時停止。recoverボタンで全回復します。  TimerGaugeクラスの仕様 以下のように、シーンに追加します。
// タイマーゲージ var gauge = phina.ui.TimerGauge({ limitTime: 30, }).addChildTo(this); gauge.setPosition(this.gridX.center(), this.gridY.center());  プロパティ・メソッド・イベント    プロパティ 説明     limitTime 制限時間(秒） デフォルト値60       メソッド 説明     run タイマー作動   pause 一時停止   recover ゲージを満タンにする       イベント 説明     onfull ゲージが満タンになった時   onempty ゲージが空になった時     その他のプロパティは、継承元のphina.</description>
    </item>
    
    <item>
      <title>【phina.js 】Webブラウザだけでhtml5ゲームを作成して公開する</title>
      <link>https://alkn203.github.io/blog/posts/others/quick-html5-game/</link>
      <pubDate>Sat, 29 Jun 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/posts/others/quick-html5-game/</guid>
      <description>はじめに ゲームを作っている人なら、自分の作ったゲームを誰かに遊んでもらいたい気持ちは皆持っていると思います。今では、スマホアプリを作ってプラットフォームで公開する方法がメジャーですが、初心者にとってはそう簡単にはいかないものです。
中には、アプリ化まではいかないけど何かゲームを作って公開してみたいと思っている人もいるでしょう。そのようなときは、javascriptでhtml5ゲームを作って、Webで公開することをおすすめします。（もちろんhtml5ゲームをアプリ化する方法もあります）
Webブラウザだけでゲームを作成して公開する 今回は、特別な環境構築をせずに、Webブラウザだけを使ってhtml5ゲームを公開する方法を紹介します。大まかな流れは以下のとおりです。
 runstantでコーティングする runstantプロジェクトをhtmlファイルとしてダウンロードする GitHubにゲーム公開用のリポジトリを作る htmlファイルをGitHubのリポジトリにアップロードする GitHubのリポジトリの設定でGitHub Pagesを有効にする  それでは、順番に説明していきます。
runstantでコーティングする runstantは、phina.jsの生みの親であるphiさんが開発したWebブラウザ上で動くオンラインエディタで、ユーザー登録すれば誰でも利用することができます。 phina.jsの公式エディタでもあり、実際に様々なプログラムが作られて公開されています。
phina.jsのひな形からゲームを作成 これまでも触れていますが、普段私が使っているphina.jsのひな形から作ることで、簡単に始められます。
今回作ったゲーム サンプルとして、制限時間内にどれだけ円をタッチできるかを競う単純なゲームを作りました。
Touch The Circle(runstant)
runstantプロジェクトをhtmlファイルとしてダウンロードする ゲームを作ったら、Webに公開するファイルの準備をする必要がありますが、runstantの便利な機能として、プロジェクトのダウンロードがあります。 ダウンロードされたファイルはhtml形式でjavascriptのコード部分もパッケージ化されているので、このファイル１つあればゲームとして動作します。
プロジェクトのダウンロード方法  runstantの画面下部にあるボタンをクリックすると、プロジェクトのダウンロードができます。ダウンロード先は任意の場所にして、ファイル名をindex.htmlに変更して下さい。  GitHubにゲーム公開用のリポジトリを作る GitHubは、プログラマなら誰もが知るようになりつつある、主にソースコードのバージョン管理を目的としたサービスです。 今回は、このGitHubをゲームの公開用サーバとして利用します。
ユーザー登録を行ったら、ゲーム公開用のリポジトリを作成します。
 ユーザーホーム画面で「New」ボタンをクリックします。   作成画面でリポジトリ名を入力します。 公開範囲が「Public」になっているのを確認します。 「リポジトリをREAD ME で初期化」にチェックを入れます。 「Create repository」ボタンをクリックします。  htmlファイルをGitHubのリポジトリにアップロードする リポジトリの用意が出来たら、runstantからダウンロードしたhtmlファイルをリポジトリにアップロードします。GitHubは、ローカル環境からgitのコマンドを駆使して使うイメージがありますが、GitHub上のGUI操作でもファイルのアップロード程度はできます。
 「Upload files」ボタンをクリックします。   上の領域にダウンロードしたhtmlファイルをドラッグするか、ファイル選択ダイアログでファイルを選択します。 「Commit Changes」ボタンをクリックします。   ファイルがアップロードされたのを確認します。  GitHubのリポジトリの設定でGitHub Pagesを有効にする  上部メニューから「Setting」をクリックします。   「github pages」を有効にします。以前は、git でgh-pages名でブランチを切って、pushする必要がありましたが、現在は不要になっています。   上部に表示される アドレスが公開先のアドレスになります。 反映されるまでには、少し時間がかかる場合もあるようです。  公開先 Touch The Circle</description>
    </item>
    
    <item>
      <title>【phina.js】2Dシューティングチュートリアル =第11回 タイトルをつける=</title>
      <link>https://alkn203.github.io/blog/posts/tutorials/phina-shooting-11/</link>
      <pubDate>Fri, 28 Jun 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/posts/tutorials/phina-shooting-11/</guid>
      <description>はじめに 前回は、プレイヤーが画面外に出ないように移動に制限をかけました。今回は、タイトル画面を追加します。
独自のタイトル画面の作成 Unityのチュートリアルでは、タイトル文字を非表示にすることでタイトル画面とゲーム画面の区別を行っています。これも一つの手法ですが、今回は、phina.jsで元々用意されているタイトル画面を上書きする方法にします。
TitleSceneの上書き  MainSceneを流用して、TitleSceneと同じ名前で新たにクラスを作ることで、元々のシーンが上書きされます。 コード的にはダブりもありますが、シーン毎に切り離して管理できるのがメリットです。  /* * タイトルシーン */ phina.define(&amp;quot;TitleScene&amp;quot;, { // 継承 superClass: &#39;DisplayScene&#39;, // 初期化 init: function() { // 親クラス初期化 this.superInit(); // グループ this.bgGroup = DisplayElement().addChildTo(this); this.bg2Group = DisplayElement().addChildTo(this); // グリッド var gx = this.gridX; var gy = this.gridY; // 背景 this.createBackground(); // タイトルラベル var title = Label({ text: &#39;Shooting Game&#39;, fill: &#39;white&#39;, stroke: &#39;yellow&#39;, fontSize: 72, }).addChildTo(this).setPosition(gx.center(), gy.center(-2)); // スタートキーラベル var startKey = Label({ text: &#39;Press X&#39;, fill: &#39;white&#39;, stroke: &#39;yellow&#39;, fontSize: 64, }).</description>
    </item>
    
    <item>
      <title>【phina.js】2Dシューティングチュートリアル =第10回 プレイヤーの移動制限=</title>
      <link>https://alkn203.github.io/blog/posts/tutorials/phina-shooting-10/</link>
      <pubDate>Thu, 27 Jun 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/posts/tutorials/phina-shooting-10/</guid>
      <description>はじめに 前回は、敵の波状攻撃を実装しました。今回は、ゲームにサウンドをつけます。
サウンド素材の読み込み 画像と同じようにアセットとして読み込みます。
// サウンド sound: { &#39;bgm&#39;: &#39;https://cdn.jsdelivr.net/gh/alkn203/phina-shooting-tutorial@master/work/assets/game_maoudamashii_4_vehicle03.mp3&#39;, &#39;shot&#39;: &#39;https://cdn.jsdelivr.net/gh/alkn203/phina-shooting-tutorial@master/work/assets/se_maoudamashii_battle_gun05.mp3&#39;, &#39;explosion&#39;: &#39;https://cdn.jsdelivr.net/gh/alkn203/phina-shooting-tutorial@master/work/assets/se_maoudamashii_explosion06.mp3&#39;, },   サウンド素材は魔王魂から拝借しました。
 BGMをつける  phina.jsでサウンドを扱うには、SoundManagerクラスを使用します。 BGMのようにループするサウンドの場合は、playMusicメソッドを使います。 デフォルトでは、ループする設定になってます。 メインシーンのコンストラクタなど好きな場所に追加して下さい。  // BGM再生 SoundManager.playMusic(&#39;bgm&#39;);  プレイヤーにショット音をつける  ショット音は一回毎に再生する必要がありますので、playメソッドを使います。 弾生成と同時に音を再生するようにPlayerBulletクラスのコンストラクに処理を追加しています。  /* * プレイヤーの弾クラス */ phina.define(&amp;quot;PlayerBullet&amp;quot;, { // 継 superClass: &#39;Sprite&#39;, // 初期化 init: function() { // 親クラス初期化 this.superInit(&#39;bullet&#39;, 64, 64); // スピード var speed = 10; // 当たり判定用のコライダー this.collider = Collider({ width: 10, height: 30, }).</description>
    </item>
    
    <item>
      <title>【phina.js】2Dシューティングチュートリアル =第9回 音をつける=</title>
      <link>https://alkn203.github.io/blog/posts/tutorials/phina-shooting-09/</link>
      <pubDate>Thu, 27 Jun 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/posts/tutorials/phina-shooting-09/</guid>
      <description>はじめに 前回は、敵の波状攻撃を実装しました。今回は、ゲームにサウンドをつけます。
サウンド素材の読み込み 画像と同じようにアセットとして読み込みます。
// サウンド sound: { &#39;bgm&#39;: &#39;https://cdn.jsdelivr.net/gh/alkn203/phina-shooting-tutorial@master/work/assets/game_maoudamashii_4_vehicle03.mp3&#39;, &#39;shot&#39;: &#39;https://cdn.jsdelivr.net/gh/alkn203/phina-shooting-tutorial@master/work/assets/se_maoudamashii_battle_gun05.mp3&#39;, &#39;explosion&#39;: &#39;https://cdn.jsdelivr.net/gh/alkn203/phina-shooting-tutorial@master/work/assets/se_maoudamashii_explosion06.mp3&#39;, },   サウンド素材は魔王魂から拝借しました。
 BGMをつける  phina.jsでサウンドを扱うには、SoundManagerクラスを使用します。 BGMのようにループするサウンドの場合は、playMusicメソッドを使います。 デフォルトでは、ループする設定になってます。 メインシーンのコンストラクタなど好きな場所に追加して下さい。  // BGM再生 SoundManager.playMusic(&#39;bgm&#39;);  プレイヤーにショット音をつける  ショット音は一回毎に再生する必要がありますので、playメソッドを使います。 弾生成と同時に音を再生するようにPlayerBulletクラスのコンストラクに処理を追加しています。  /* * プレイヤーの弾クラス */ phina.define(&amp;quot;PlayerBullet&amp;quot;, { // 継 superClass: &#39;Sprite&#39;, // 初期化 init: function() { // 親クラス初期化 this.superInit(&#39;bullet&#39;, 64, 64); // スピード var speed = 10; // 当たり判定用のコライダー this.collider = Collider({ width: 10, height: 30, }).</description>
    </item>
    
    <item>
      <title>【phina.js】2Dシューティングチュートリアル =第8回 敵の波状攻撃=</title>
      <link>https://alkn203.github.io/blog/posts/tutorials/phina-shooting-08/</link>
      <pubDate>Wed, 26 Jun 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/posts/tutorials/phina-shooting-08/</guid>
      <description>はじめに 前回は、背景を追加しました。今回は、敵の波状攻撃を実装します。
WaveとEmitter UnityのチュートリアルにあるWave型とEmitterという仕組み自体は、phina.jsにはありませんので、似せた処理を作ります。
Wave機能の実現 UnityのWave型を参考にして、以下の仕様にします。
 敵をフォーメーションで出現させる。 敵が全て倒されるか、画面外に出たら1に戻る。  クラスにしても良いのですが、親子関係の複雑化を避けるために、今回は関数を作ります。
createWave関数 // Wave作成 createWave: function() { // 敵3機フォーメーション [[0, -2], [-2, -4], [2, -4]].each(function(arr) { var enemy = Enemy().addChildTo(this.waveGroup); enemy.setPosition(this.gridX.center(arr[0]), this.gridY.span(arr[1])); }, this); },   これまで敵はenemyGroupに追加してきましたが、新たにwaveGroupに追加します。 敵のフォーメーション情報を配列に入れて、ループでアクセスして敵を配置しています。  checkWave関数 // Waveの状態チェック checkWave: function() { // 敵がいなくなったら出現させる if (this.waveGroup.children.length === 0) { this.createWave(); } },   updateでこの関数を呼び出し、敵の状態をチェックします。 全ての敵が画面外に出るか、プレイヤーに倒されたらcreateWaveを呼び出して敵を出現させます。  敵が画面外で弾を撃たないようにする 敵の波状攻撃は実装できましたが、このままだと画面外にいる時から弾を発射できてしまいますので、画面に現れてから弾の発射を開始するように調整します。
// 一定間隔で弾を発射 this.tweener.clear() .call(function() { this.shot(); }, this) .</description>
    </item>
    
    <item>
      <title>【phina.js】2Dシューティングチュートリアル =第7回 背景を追加する=</title>
      <link>https://alkn203.github.io/blog/posts/tutorials/phina-shooting-07/</link>
      <pubDate>Tue, 25 Jun 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/posts/tutorials/phina-shooting-07/</guid>
      <description>はじめに 前回は、当たり判定を追加しました。今回は、背景を作成します。
背景画像を追加する 下の背景 上の背景（中間は透過処理）  背景画像をスプライトとして追加します。画像は2種類にしてスクロール速度を変えて奥行き感を表現します。 背景をループしてスクロールできるように、それぞれ同じ画像を2つ縦に繋げて並べます。画像はグループに追加して管理します。 背景画像は、画面の縦サイズより少し大きめにすることで、スクロールさせる時の画像の移動をより自然に見せることができます。  // グループ this.bgGroup = DisplayElement().addChildTo(this); this.bg2Group = DisplayElement().addChildTo(this);  // 背景作成 createBackground: function() { var bgGroup = this.bgGroup; var bg2Group = this.bg2Group; (2).times(function(i) { // 一番下の背景 var bg = Sprite(&#39;bg&#39;).addChildTo(bgGroup); bg.setPosition(this.gridX.center(), this.gridY.center()); // 上の背景 var bg2 = Sprite(&#39;bg2&#39;).addChildTo(bg2Group); bg2.setPosition(this.gridX.center(), this.gridY.center()); // スクロールスピード bg.physical.velocity.y = 2; bg2.physical.velocity.y = 4; }, this); // それぞれ2つの背景を縦に繋げる bgGroup.children.last.bottom = bgGroup.children.first.top; bg2Group.children.last.bottom = bg2Group.children.first.top; },  背景をループしてスクロールさせる 背景のスクロール管理は、update内で行います。</description>
    </item>
    
    <item>
      <title>【phina.js】2Dシューティングチュートリアル =第6回 当たり判定とアニメーションイベントとグループ=</title>
      <link>https://alkn203.github.io/blog/posts/tutorials/phina-shooting-06/</link>
      <pubDate>Mon, 24 Jun 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/posts/tutorials/phina-shooting-06/</guid>
      <description>はじめに 前回は、敵を追加して敵が弾を発射するようにしました。今回は、当たり判定を作成します。
Colliderクラスを作成する Unityでは、コライダーという当たり判定を行うためのコンポーネントが用意されていますが、phina.jsにはありません。そこで、それに似た機能を持たせたColliderというクラスを作りました。
/* * コライダークラス */ phina.define(&amp;quot;Collider&amp;quot;, { // 継承 superClass: &#39;RectangleShape&#39;, // 初期化 init: function(param) { // 親クラス初期化 this.superInit({ width: param.width, height: param.height, fill: null, stroke: &#39;red&#39;, }); }, // コライダーの絶対座標の矩形 getAbsoluteRect: function() { var x = this.left + this.parent.x; var y = this.top + this.parent.y; return Rect(x, y, this.width, this.height); }, });   今回は簡易な矩形での当たり判定を行うので、RentangleShapeクラスを継承しています。 コライダーは子要素として追加するため、コライダー自体の座標は相対座標値になることから、親の座標を元に絶対座標値の矩形を計算して返す関数を用意します。  仕様変更 これまでプレイヤーと敵の弾は、空のクラスに一旦追加する形にしていましたが、当たり判定における親子関係を出来るだけシンプルにするために、shot関数の中で直接生成する形に変更しました。
当たり判定を付ける プレイヤー プレイヤークラスでコライダーを以下のように追加します。
/* * プレイヤークラス */ phina.</description>
    </item>
    
    <item>
      <title>【phina.js】2Dシューティングチュートリアル =第5回 敵を作成する=</title>
      <link>https://alkn203.github.io/blog/posts/tutorials/phina-shooting-05/</link>
      <pubDate>Sun, 23 Jun 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/posts/tutorials/phina-shooting-05/</guid>
      <description>はじめに 前回は、プレイヤーから弾が発射できるようにしました。今回は、敵を作成します。
共通部分のクラス化 前回作ったプレイヤークラスと今回作成する敵クラスでは、共通化できる部分があります。その部分をSpaceShipクラスとして別クラスで作成し、使い回しが出来るようにします。
SpaceShipクラス /* * スペースシップクラス */ phina.define(&amp;quot;SpaceShip&amp;quot;, { // 継承 superClass: &#39;Sprite&#39;, // 初期化 init: function(param) { // 親クラス初期化 this.superInit(&#39;spaceship&#39;, 64, 64); // フレームアニメーションをアタッチ this.anim = FrameAnimation(&#39;spaceship&#39;).attachTo(this); // 移動スピード this.speed = param.speed; }, // 機体の移動 move: function(direction) { this.moveBy(direction.x * this.speed, direction.y * this.speed); }, });   プレイヤークラスと敵クラスがこのクラスを継承できるようにします。 スプライトとフレームアニメーションは、同じファイルを使っていますので共通化できます。 移動スピードは、外から指定出来るようにしています。 移動処理も関数に方向を代入することで処理ができるようにしています。  プレイヤークラスから継承する 設計変更で、プレイヤークラスのコンストラクは以下のようになります。
/* * プレイヤークラス */ phina.define(&amp;quot;Player&amp;quot;, { // 継承 superClass: &#39;SpaceShip&#39;, // 初期化 init: function() { // 親クラス初期化 this.</description>
    </item>
    
    <item>
      <title>【phina.js】2Dシューティングチュートリアル =第4回 プレイヤーから弾を撃つ=</title>
      <link>https://alkn203.github.io/blog/posts/tutorials/phina-shooting-04/</link>
      <pubDate>Sat, 22 Jun 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/posts/tutorials/phina-shooting-04/</guid>
      <description>はじめに 前回は、プレイヤーをキーボードで移動させるところまで出来ました。 今回は、プレイヤーが自動で弾を連射するようにします。
親子関係  Unityでは、オブジェクトの「親子関係」という言葉を使いますが、phina.jsでも同じような関係を持たせることができます。 親子関係になると、親が移動・回転を行えば、追従して子も同じように移動・回転します。  子要素として追加する方法 例えば、obj1をobj2の子要素として追加したい場合、以下のように書きます。
obj1.addChildTo(obj2);  プレイヤーの弾を作成する プレイヤーの弾を表示するだけなら、以下のようにスプライトとしてシーンに追加すればOKです。
// プレイヤーの弾 Sprite(&#39;bullet&#39;, 64, 64).addChildTo(this).setPosition(this.gridX.center(), this.gridY.center());  ここまでの実行サンプル プレイヤーの弾表示(runstant)
プレイヤーの弾を動かす ゲームを実行したら勝手に上に飛んで行く弾を作成します。
親となるPlayerBulletの作成 Unityのチュートリアルでは空のゲームオブジェクトを作成していますが、phina.jsではDisplayElementというクラスにその役割をさせることができます。
PlayerBulletクラス プレイヤーの弾として、DisplayElementを継承した以下のクラスを作成しました。
/* * プレイヤーの弾クラス */ phina.define(&amp;quot;PlayerBullet&amp;quot;, { // 継 superClass: &#39;DisplayElement&#39;, // 初期化 init: function() { // 親クラス初期化 this.superInit(); // スピード var speed = 10; var self = this; // 左右の弾 [-10, 10].each(function(dx) { Sprite(&#39;bullet&#39;, 64, 64).addChildTo(self).setPosition(self.x + dx, self.y); }); // 上向き速度を与える this.</description>
    </item>
    
    <item>
      <title>【phina.js】2Dシューティングチュートリアル =第3回 プレイヤーの移動=</title>
      <link>https://alkn203.github.io/blog/posts/tutorials/phina-shooting-03/</link>
      <pubDate>Fri, 21 Jun 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/posts/tutorials/phina-shooting-03/</guid>
      <description>はじめに 前回は、ゲームで使うアセットの読み込みまで行いました。今回は、プレイヤーをキーボードで操作できるようにします。
プレイヤーの移動 Unityでは、コードを実行する場合、ゲームオブジェクトにスクリプトをアタッチする方法をとりますが、phina.jsでは、オブジェクト専用のクラスを作成する方法が一般的です。
プレイヤークラス 今回は、プレイヤークラスを以下のとおり実装しました。
/* * プレイヤークラス */ phina.define(&amp;quot;Player&amp;quot;, { // 継承 superClass: &#39;Sprite&#39;, // 初期化 init: function() { // 親クラス初期化 this.superInit(&#39;spaceship&#39;, 64, 64); // フレームアニメーションをアタッチ FrameAnimation(&#39;spaceship&#39;).attachTo(this).gotoAndPlay(&#39;player&#39;); // 移動スピード this.speed = 5; }, // 毎フレーム更新処理 update: function(app) { // 移動する向きを求める var direction = app.keyboard.getKeyDirection(); // 移動する向きとスピードを代入する this.moveBy(direction.x * this.speed, direction.y * this.speed); }, });  クラス宣言 phina.define(&amp;quot;Player&amp;quot;, { // 継承 superClass: &#39;Sprite&#39;,   クラス宣言は、defineで行います。次の文字列はクラス名です。 superClassで継承元の親クラスを指定します。自機はスプライト画像を使うので、親クラスにSpriteクラスを指定しています。  init関数 一般的にコンストラクと呼ばれるもので、UnityにおけるStartと同じ役割です。</description>
    </item>
    
    <item>
      <title>【phina.js】2Dシューティングチュートリアル =第2回 スプライトとフレームアニメーション=</title>
      <link>https://alkn203.github.io/blog/posts/tutorials/phina-shooting-02/</link>
      <pubDate>Thu, 20 Jun 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/posts/tutorials/phina-shooting-02/</guid>
      <description>はじめに 前回は、phina.jsにおけるコーディングの準備までを書きました。今回から具体的にチュートリアルを進めていきます。
テクスチャからスプライトを作成する Unityでは内臓のスプライトエディタで作成しますが、phina.jsではアセットとして別に用意した画像ファイルを読み込みます。
用意した画像 プレイヤーと敵
プレイヤーと敵の弾
爆発
 これらの画像は、一般的にスプライトシートと呼ばれており同じサイズの画像を複数枚タイル状に並べたものです。 一枚当たりのサイズを指定して切り出すことで、好きなコマ画像を表示したり、フレームアニメーションと言われるコマ送りの動画を表現することができます。  自機と敵のアニメーション 以下ようなアニメーションを作成します。
フレームアニメーション定義ファイルの作成  フレームアニメーションは、少ないコマ数であればコード中でフレームインデックスを指定して表現することもできますが、アニメーションの種類が増えると複雑になりがちです phina.jsではフレームアニメーション定義ファイルを作成してアセットとして読み込むことで、簡単にアニメーションを行うことができます。  自機と敵の定義ファイル { &amp;quot;frame&amp;quot;: { &amp;quot;width&amp;quot;: 64, &amp;quot;height&amp;quot;: 64, &amp;quot;cols&amp;quot;: 4, &amp;quot;rows&amp;quot;: 4 }, &amp;quot;animations&amp;quot; : { &amp;quot;player&amp;quot;: { &amp;quot;frames&amp;quot;: [0,1,2,3,2,1], &amp;quot;next&amp;quot;: &amp;quot;player&amp;quot;, &amp;quot;frequency&amp;quot;: 1 }, &amp;quot;enemy&amp;quot;: { &amp;quot;frames&amp;quot;: [4,5,6,7,6,5], &amp;quot;next&amp;quot;: &amp;quot;enemy&amp;quot;, &amp;quot;frequency&amp;quot;: 1 } } }  定義ファイルはjson形式で作成します。
 frameのwidthとheightは、１コマ毎に画像を切り出すサイズで、今回は64x64としています。 colsは横、rowは縦の画像のコマ数で、4x4の合計16コマであることが分かります。 animationsで個別のアニメーションを定義します。 playerはアニメーション名で、任意の名前を設定することができます。 framesで何番目のコマを使うかを配列形式で指定します。自機の画像は4コマ目までなので、今回は0→1→2→3→2→1と順番に切り替えてアニメーションさせます。敵の画像は5から8コマ目なので、同様に指定しています。配列なのでインデックスは0から始まります。 nextで次のアニメーションを指定します。同じアニメーション名を指定すると、ループします。 frequencyはアニメーションの間隔で、小さければ速くなり、大きければ遅くなります。  爆発アニメーションの定義ファイル 以下のようなアニメーションを作成します。
{ &amp;quot;frame&amp;quot;: { &amp;quot;width&amp;quot;: 64, &amp;quot;height&amp;quot;: 64, &amp;quot;cols&amp;quot;: 10, &amp;quot;rows&amp;quot;: 1 }, &amp;quot;animations&amp;quot; : { &amp;quot;explosion&amp;quot;: { &amp;quot;frames&amp;quot;: [0,1,2,3,4,5,6,7,8,9], &amp;quot;frequency&amp;quot;: 1 } } }  自機と敵の場合と違う点は、animationsのnextを指定していないところです。理由は、爆発アニメーションは1回限りで良いからです。</description>
    </item>
    
    <item>
      <title>【phina.js】2Dシューティングチュートリアル =第1回 プログラミングの準備=</title>
      <link>https://alkn203.github.io/blog/posts/tutorials/phina-shooting-01/</link>
      <pubDate>Wed, 19 Jun 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/posts/tutorials/phina-shooting-01/</guid>
      <description> プログラミングの準備 今回のチュートリアルでは、phina.jsの公式オンラインエディタの位置付けであるRunstantを使用します。
ひな形 私が普段使っている以下のひな形から作成します。
// グローバルに展開 phina.globalize(); /* * メインシーン */ phina.define(&amp;quot;MainScene&amp;quot;, { // 継承 superClass: &#39;DisplayScene&#39;, // 初期化 init: function() { // 親クラス初期化 this.superInit(); // 背景色 this.backgroundColor = &#39;black&#39;; // 以下にコードを書いていく }, // 毎フレーム更新処理 update: function() { // 以下にコードを書いていく }, }); /* * メイン処理 */ phina.main(function() { // アプリケーションを生成 var app = GameApp({ // MainScene から開始 startLabel: &#39;main&#39;, }); // fps表示 //app.enableStats(); // 実行 app.run(); });  </description>
    </item>
    
    <item>
      <title>【phina.js】バブルソートを視覚化してみた</title>
      <link>https://alkn203.github.io/blog/posts/others/phina-bubblesort/</link>
      <pubDate>Sun, 16 Jun 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/posts/others/phina-bubblesort/</guid>
      <description>バブルソートとは プログラミングを習うと必ずと言って良いほど、最初に出てくるソートアルゴリズムです。 今回のコードは、phina.jsでそれを視覚化してみたものです。 要素が入れ替わる様子が何となく分かるかと思います。
実行サンプル  コード バブルソート視覚化(runstant)
参考にしたサイト バブルソート</description>
    </item>
    
    <item>
      <title>【phina.js】色々なスクロールを試す</title>
      <link>https://alkn203.github.io/blog/posts/tips/phina-various-scroll/</link>
      <pubDate>Sat, 15 Jun 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/posts/tips/phina-various-scroll/</guid>
      <description>はじめに 横スクロールアクションゲームでは、画面のスクロール処理が欠かせませんが、スクロール１つでも結構奥が深いです。今回はphina.jsで主だったスクロール処理を実装してみました。
プレイヤー固定スクロール まずは以下のサンプルを確認してみて下さい。 プレイヤーの位置は画面の中心固定で画面がスクロールします。画面タッチでプレイヤーがジャンプして、障害物に当たると反転移動します。 中心には分かりやすいようにラインを表示しています。
 runstantで確認
このパターンのスクロールは、特に難しい実装はないかと思います。 プレイヤーは動かさずに固定して、プレイヤー以外のオブジェクトをプレイヤーの移動方向と逆向きに動かすことで、プレイヤーが移動しているように見えます。
// 画面スクロール moveX: function() { var self = this; this.objectGroup.children.each(function(obj) { obj.x += -self.player.vx; }); },  変則スクロール 始めは固定スクロールと同じようにスクロールしますが、ステージの端に行くとスクロールが止まります。 そして、画面中央を超えると再びスクロールします。
 runstantで確認
このパターンのスクロールのポイントは、プレイヤー以外のオブジェクトの移動とプレイヤーのみの移動の切り替えです。 プレイヤーの横方向の状態をチェックする関数を用意して、その中で切り替えを行います。
// 横方向の状態チェック checkHorizontalState: function() { var player = this.player; var state = this.player.horizontalState; // 左端のオブジェクト var first = this.objectGroup.children.first; // 右端のオブジェクト var last = this.objectGroup.children.last; // プレイヤーの状態で分ける switch (state) { // 左移動中 case &#39;MOVING_LEFT&#39;: // ヒットしたら反転 if (this.</description>
    </item>
    
    <item>
      <title>【phina.js】パスに沿ったオブジェクト移動</title>
      <link>https://alkn203.github.io/blog/posts/tips/phina-movealongpath/</link>
      <pubDate>Fri, 14 Jun 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/posts/tips/phina-movealongpath/</guid>
      <description> パスに沿ったオブジェクトの移動 ゲームを作成していると、動く床などのように一定のルートに従ってオブジェクトを移動させたい時があると思います。 phina.jsを使って、自分なりにその処理を実装してみました。
動作サンプル まずは以下のサンプルをご覧下さい。線に沿ってオブジェクトが移動します。
 runstantで確認
 オブジェクトの移動には、非同期処理が行えるtweenerを利用します。 tweenerの内部処理で使われている_add関数で処理をスタックさせています。 tweenerは、基本的にスタックされた順に非同期処理されるので、次の移動先である各頂点の位置を順番に与えることで、結果としてパスに沿った移動が可能になります。  課題  今回のサンプルでは、移動速度が一定になるように各頂点の距離が同一になるように配置しています。 一定の時間で移動させるのがtweenerの処理ですので、距離が変わると移動速度も変わることになります。 各頂点の距離に応じてdurationを変えると速度を一定にすることが可能になると思われますが、その辺は次回の課題にしたいと思います。  </description>
    </item>
    
    <item>
      <title>【phina.js】上方向だけすり抜ける床を作る</title>
      <link>https://alkn203.github.io/blog/posts/tips/phina-up-direction/</link>
      <pubDate>Thu, 13 Jun 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/posts/tips/phina-up-direction/</guid>
      <description>上方向だけすり抜ける床  ジャンプゲームなどでは、上方向にすり抜け下方向にはすり抜けない床がよくあります。 今回は基本的なジャンプ処理とともに、phina.jsを使って自分なりに実装してみました。  動作サンプル まずは以下のサンプルを確認して下さい。 画面タッチでキャラがジャンプしますが、上方向にはブロックをすり抜けて、その後に下のブロックに着地します。
 runstantで確認
プレイヤーとブロックの作成 プレイヤーとブロックは、それぞれSpriteクラスを継承して作成しました。
// プレイヤークラス phina.define(&#39;Player&#39;, { superClass: &#39;Sprite&#39;, // コンストラクタ init: function() { // 親クラス初期化 this.superInit(&#39;tomapiko&#39;, SPRITE_SIZE, SPRITE_SIZE); // フレームアニメーションをアタッチ this.anim = FrameAnimation(&#39;tomapiko_ss&#39;).attachTo(this); // スプライトシートのサイズにフィットさせない this.anim.fit = false; // 縦移動速度 this.vy = 0; // サイズ変更 this.setSize(CHARA_SIZE, CHARA_SIZE); },   デフォルトのスプライトサイズから半分のサイズにしています。 FrameAnimationクラスのプロパティfitをfalseにしないと、スプライトシートに書いている切り出しサイズが適用されるので注意して下さい。  // ブロッククラス phina.define(&#39;Block&#39;, { superClass: &#39;Sprite&#39;, // コンストラクタ init: function() { // 親クラス初期化 this.superInit(&#39;tiles&#39;, SPRITE_SIZE, SPRITE_SIZE); // タイルセットの指定フレームを表示 this.</description>
    </item>
    
    <item>
      <title>【phina.js】シンプルなタイピングゲームを作ってみた</title>
      <link>https://alkn203.github.io/blog/posts/works/keywordshot/</link>
      <pubDate>Wed, 12 Jun 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/posts/works/keywordshot/</guid>
      <description>はじめに phina.jsでシンプルなタイピングゲームを作ってみました。 私はあまりタイピングは得意な方ではないので、自分で作っておきながら途中でゲームオーバーになりますが、皆さんはいかがでしょうか。
 別画面でプレイする
 画面左から飛んでくるhtmlやjavascriptに関するキーワードをタイプするだけのゲームです。 大文字小文字は区別しません。  改定 2019/5/18 ライフ制導入
カスタマイズ キーワード一覧は、以下のように改行区切りのテキストファイルからアセットとして読み込んでいますので、中身を変えれば 別言語のキーワードなどもイケると思います。
// アセット var ASSETS = { // キーワード一覧 text: { &#39;keywords&#39;: &#39;https://cdn.jsdelivr.net/gh/alkn203/phina-games@master/keyword-shot/assets/keywords&#39;, }, };  リファレンス キーワード一覧は、以下のサイトから引用させて頂きました。ありがとうございます。 JavaScriptのキーワードとか予約語をかき集めてみた - Born Neet</description>
    </item>
    
    <item>
      <title>phina.js事始め</title>
      <link>https://alkn203.github.io/blog/posts/others/about-phina/</link>
      <pubDate>Tue, 11 Jun 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/posts/others/about-phina/</guid>
      <description>（ロゴはphinajs.comから借用）
phina.jsについて 私が日々楽しんで使っているjavascriptのゲームライブラリで、tmlib.jsの後継のライブラリになります。現在開発はphina.jsの方にシフトしています。 とりあえずどのようなものか知るためには、以下の紹介記事辺りが参考になるかと思います。
 本日 JavaScript ゲームライブラリ『phina.js』をリリースしました! by @phi さん phina.js - JavaScriptで楽しく簡単にゲームが作れるライブラリ by @simiraaaa さん phina.jsの簡単さから基礎知識まで by @axion014 さん はじめてのphina.js – JavaScriptゲームライブラリを使ってみた！ by 株式会社LIG さん  気に入っているところ 以下は主観的ですが、他のユーザーも感じているのではないかと思います。
 同じ処理でもコード量が少なく済みます。全てのゲームライブラリと比較したわけではありませんが、phina.jsで書き慣れると、個人的には同様の処理を行う他のライブラリのコードが冗長に感じるようになりました。 ソースが読みやすいです。ソースの書き方を真似ることで、結果的に自分のコードも読みやすくなりました。 実行確認までのステップが短いです。Web上でコーディングできるrunstantを使うことで、環境構築の手間をかけずに自分のプログラムが確認できます。 他に、配列やベクトルなどのコーディングする上でベースとなるクラスの機能拡張が充実しているなどが挙げられます。  とにかく使ってみたい方へ  Githubのリポジトリに導入方法が記載されていますが、開発者向けの内容に近いので、私も含めて不慣れな方には少し敷居が高いかと思います。 一番簡単なのは、runstantへのユーザー登録が必要ですが、runstantに用意されたテンプレートをForkする方法です。  質問など phina.jsの魅力の一つに、親切なサポート体制があります。 Twitterで#phina_jsタグをつけて質問したり、slack(gitterから移行）に参加して質問すれば、作者の phiさんを始め、他のメンバーが優しく真剣に答えてくれます。些細なことでも良いので、構えずに質問してみて下さい。
Tipsなど どんなものか少しでも知ってもらうために、phina.js Tips集をよろしければご覧ください。
おわりに ゲームライブラリは実際に使ってみないとその良し悪しはわかりませんが、恵まれたことにphina.jsは、比較的簡単にトライすることができます。 javascriptでのゲーム開発に興味がある方は、是非一度触ってみて色々と試して頂ければと思います。</description>
    </item>
    
  </channel>
</rss>