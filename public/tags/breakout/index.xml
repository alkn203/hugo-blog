<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Breakout on Keep Coding</title>
    <link>https://alkn203.github.io/blog/tags/breakout/</link>
    <description>Recent content in Breakout on Keep Coding</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Fri, 06 Nov 2015 20:55:06 +0900</lastBuildDate>
    <atom:link href="https://alkn203.github.io/blog/tags/breakout/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>【phina.js】ゲーム作成チュートリアル（ブロック崩し）最終回＝ゲームオーバーとクリア処理＝</title>
      <link>https://alkn203.github.io/blog/2015/11/06/breakout-tut-07</link>
      <pubDate>Fri, 06 Nov 2015 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2015/11/06/breakout-tut-07</guid>
      <description>

&lt;h3 id=&#34;はじめに&#34;&gt;はじめに&lt;/h3&gt;

&lt;p&gt;前回は、&lt;strong&gt;Tweener&lt;/strong&gt;を使ったアニメーション処理を追加しました。
今回は最終回として、ゲームオーバーとクリア処理を追加したいと思います。&lt;/p&gt;

&lt;h3 id=&#34;ゲームオーバー処理&#34;&gt;ゲームオーバー処理&lt;/h3&gt;

&lt;p&gt;ボールが画面下に落下したら、&lt;strong&gt;GAME OVER&lt;/strong&gt;という文字を表示してタイトル画面に戻るようにします。
コードは以下のとおりです。&lt;/p&gt;

&lt;div class=&#39;runstant&#39;&gt;&lt;iframe src=&#39;http://goo.gl/Gn8EzI&#39; width=&#39;100%&#39; height=&#39;640px&#39; style=&#39;border:0px;box-shadow:0px 0px 2px 0px #aaa&#39;&gt;&lt;/iframe&gt;&lt;/div&gt;

&lt;h3 id=&#34;コード説明&#34;&gt;コード説明&lt;/h3&gt;

&lt;h5 id=&#34;93から111行目&#34;&gt;93から111行目&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;      // 落下
      var self = this;

      if (ball.top &amp;gt; screenRect.bottom) {
        // ゲームオーバー表示
        var label = Label({
          text: &#39;GAME OVER&#39;,
          fill: &#39;yellow&#39;,
          fontSize: 64,
        }).addChildTo(this);
        label.setPosition(this.gridX.center(), this.gridY.center());
        // 少し待ってからタイトル画面へ
        label.tweener.clear()
                     .wait(2000)
                     .call(function() {
                       self.nextLabel = &#39;title&#39;;
                       self.exit();
                     });
      }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Label&lt;/strong&gt;クラスを使って表示用のラベルを追加しています。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tweener&lt;/strong&gt;を使って、&lt;strong&gt;wait&lt;/strong&gt;で2秒ほど待ってからタイトル画面に移動するようにしています。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;nextLabel&lt;/strong&gt;で移動先のシーン名を指定します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;exit&lt;/strong&gt;で現在のシーンを抜けます。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;クリア処理&#34;&gt;クリア処理&lt;/h3&gt;

&lt;p&gt;全てのブロックを崩したらクリアとして、スコアを結果画面に表示してみます。
コードは以下のとおりです。&lt;/p&gt;

&lt;div class=&#39;runstant&#39;&gt;&lt;iframe src=&#39;http://goo.gl/15M7pz&#39; width=&#39;100%&#39; height=&#39;640px&#39; style=&#39;border:0px;box-shadow:0px 0px 2px 0px #aaa&#39;&gt;&lt;/iframe&gt;&lt;/div&gt;

&lt;h3 id=&#34;コード説明-1&#34;&gt;コード説明&lt;/h3&gt;

&lt;h5 id=&#34;53から63行目&#34;&gt;53から63行目&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// スコア
this.score = 0;
var scoreLabel = Label({
  text: this.score + &#39;&#39;,
  fill: &#39;lime&#39;,
  fontSize: 64,
}).addChildTo(this);
scoreLabel.setPosition(this.gridX.center(), this.gridY.center());
scoreLabel.alpha = 0.6;
// 連続ヒット数
this.hitNumber = 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;this.score&lt;/strong&gt;は、スコア用の変数です。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Label&lt;/strong&gt;クラスを使ってスコア表示用のラベルを追加しています。ラベルの&lt;strong&gt;text&lt;/strong&gt;プロパティにスコア値を設定しています。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;alpha&lt;/strong&gt;は透明度で、0に近づくほど透明になります。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;this.hitNumber&lt;/strong&gt;ブロックを連続で崩した回数を記録します。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;232から240行目&#34;&gt;232から240行目&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // スコア加算
  this.addScore();
},
// スコア加算処理
addScore: function() {
  this.hitNumber++;
  this.score += this.hitNumber * 10;
  this.scoreLabel.text = this.score;
},
});
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;ブロックを崩した時に&lt;strong&gt;addScore&lt;/strong&gt;関数を呼び出して、スコアを加算します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;addScore&lt;/strong&gt;関数内では、連続ヒット数の場合、スコアを上乗せしています。&lt;/li&gt;
&lt;li&gt;スコア表示用ラベルの&lt;strong&gt;text&lt;/strong&gt;プロパティに現在のスコアを反映させれば、ラベルが更新されます。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;209から215行目&#34;&gt;209から215行目&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// クリアチェック
if (this.blockGroup.children.length === 0) {
  // スコアをリザルトシーンに渡す
  this.exit({
    score: this.score,  
  });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;ブロックを全て崩した時がクリアの条件ですので、&lt;strong&gt;length&lt;/strong&gt;の値をチェックします。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;exit&lt;/strong&gt;にスコアを渡して、リザルトシーンに移動します。&lt;strong&gt;nextLabel&lt;/strong&gt;を設定していないのは、&lt;strong&gt;main&lt;/strong&gt;の次はデフォルトで&lt;strong&gt;result&lt;/strong&gt;が設定されているためです。&lt;/li&gt;
&lt;li&gt;実際にクリアすると、リザルト画面にスコアが引き渡されているのが分かるかと思います。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;まとめ&#34;&gt;まとめ&lt;/h3&gt;

&lt;p&gt;今回のチュートリアルでは、&lt;strong&gt;phina.js&lt;/strong&gt;を使った簡単なブロック崩しの作成について触れさせて頂きました。
&lt;strong&gt;phina.js&lt;/strong&gt;には、今回では紹介しきれていない機能がまだまだありますので、これからこのブログなどで私なりに紹介できればと思っております。&lt;/p&gt;

&lt;p&gt;今回の一連のエントリーに関する質問などは、私(&lt;a href=&#34;https://twitter.com/alkn203&#34;&gt;@alkn203&lt;/a&gt;)までお気軽にどうぞ。
&lt;strong&gt;phina.js&lt;/strong&gt;に関する質問は、作者のphi氏(&lt;a href=&#34;https://twitter.com/phi_jp&#34;&gt;@phi-jp&lt;/a&gt;)に直接して頂くか、&lt;a href=&#34;https://gitter.im/phi-jp/phina.js&#34;&gt;gitter&lt;/a&gt;でして頂ければ、メンバーが真剣に答えてくれると思います。(微力ながら私も参加しています）&lt;/p&gt;

&lt;p&gt;今回のチュートリアルが、&lt;strong&gt;phina.js&lt;/strong&gt;を使ったゲーム作成の際に少しでも参考になれば幸いです。
最後までお付き合い頂きありがとうございました。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【phina.js】ゲーム作成チュートリアル（ブロック崩し）第6回＝Tweenerを使ったアニメーション処理＝</title>
      <link>https://alkn203.github.io/blog/2015/11/05/breakout-tut-06</link>
      <pubDate>Thu, 05 Nov 2015 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2015/11/05/breakout-tut-06</guid>
      <description>

&lt;h3 id=&#34;はじめに&#34;&gt;はじめに&lt;/h3&gt;

&lt;p&gt;前回は、ブロックの消去処理を追加しました。
今回は、ゲームとしての見栄えを良くするために、ブロックがアニメーションして消えるようにしたいと思います。&lt;/p&gt;

&lt;h3 id=&#34;tweenerを使ったアニメーション処理&#34;&gt;Tweenerを使ったアニメーション処理&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;phina.js&lt;/strong&gt;には&lt;strong&gt;Tweener&lt;/strong&gt;という機能があり、オブジェクトに対して移動、拡大・縮小、回転などといったアニメーションを簡単に設定することができます。
今回は、ブロックが&lt;strong&gt;縮小して消える&lt;/strong&gt;ようにしてみます。&lt;/p&gt;

&lt;h3 id=&#34;アニメーション用ダミーブロックの作成&#34;&gt;アニメーション用ダミーブロックの作成&lt;/h3&gt;

&lt;p&gt;ブロックそのものに&lt;strong&gt;Tweener&lt;/strong&gt;を設定しても良いのですが、消去アニメーション中も当たり判定が有効だと予期しない動作を招きかねないので、アニメーション用のダミーブロックを別途作成してから、それに&lt;strong&gt;Tweener&lt;/strong&gt;を設定する方法をとります。
コードは以下のとおりです。&lt;/p&gt;

&lt;div class=&#39;runstant&#39;&gt;&lt;iframe src=&#39;http://goo.gl/2SQ3Zh&#39; width=&#39;100%&#39; height=&#39;640px&#39; style=&#39;border:0px;box-shadow:0px 0px 2px 0px #aaa&#39;&gt;&lt;/iframe&gt;&lt;/div&gt;

&lt;h3 id=&#34;コード説明&#34;&gt;コード説明&lt;/h3&gt;

&lt;h5 id=&#34;20行目&#34;&gt;20行目&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    // ダミーブロックグループ
    this.dummyGroup = CanvasElement().addChildTo(this);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;dummyGroup&lt;/strong&gt;は、ダミーブロック用のグループです。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;189から204行目&#34;&gt;189から204行目&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// ブロックの消去処理
disableBlock: function(block) {
  // 消去アニメーション用のダミーブロック
  var dummy = Block().addChildTo(this.dummyGroup);
  // 属性コピー
  dummy.x = block.x;
  dummy.y = block.y;
  // ブロック削除
  block.remove();
  // 縮小して消えるアニメーション
  dummy.tweener.clear()
               .to({scaleX: 0.1, scaleY: 0.1}, 200)
               .call(function() {
                 dummy.remove();
               });
},
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;disableBlock&lt;/strong&gt;では、まず引数で与えられたブロックの位置情報をコピーしてダミーブロックを作っています。そして、元のブロックを消去しています。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 縮小して消えるアニメーション
dummy.tweener.clear()
             .to({scaleX: 0.1, scaleY: 0.1}, 200)
             .call(function() {
               dummy.remove();
             });
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;ダミーブロックの&lt;strong&gt;Tweener&lt;/strong&gt;設定を行っています。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;clear()&lt;/strong&gt;で一旦初期化し、&lt;strong&gt;to&lt;/strong&gt;でパラメータの変更を行います。&lt;/li&gt;
&lt;li&gt;今回は縮小を行うので、&lt;strong&gt;scaleX&lt;/strong&gt;と&lt;strong&gt;scaleY&lt;/strong&gt;に縮小後の大きさを割合で指定します。&lt;strong&gt;0.1&lt;/strong&gt;の場合は、元の0.1倍の大きさになります。&lt;/li&gt;
&lt;li&gt;その後の数字で、そのアニメーションをどれ位の時間をかけて行うかを指定します。単位は&lt;strong&gt;ミリ秒&lt;/strong&gt;です。&lt;/li&gt;
&lt;li&gt;次の&lt;strong&gt;call&lt;/strong&gt;で、任意の処理を呼び出すことができます。ここでは、ダミーを消去したいので&lt;strong&gt;remove&lt;/strong&gt;としています。&lt;/li&gt;
&lt;li&gt;一連の処理は、チェインメソッドで繋げることができ、順番に実行されます。&lt;/li&gt;
&lt;li&gt;つまり今回は、&lt;strong&gt;200ミリ秒かけて0.1倍まで縮小させた後に、自分自身を消去する&lt;/strong&gt;という一連の処理になります。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;122行目-他&#34;&gt;122行目　他&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;            // ブロック削除処理
            self.disableBlock(block);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;前回までの&lt;strong&gt;remove&lt;/strong&gt;関数を上記のコードに置き換えます。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;今回はここまで&#34;&gt;今回はここまで&lt;/h3&gt;

&lt;p&gt;今回は&lt;strong&gt;phina.js&lt;/strong&gt;の目玉機能の１つとも言える&lt;strong&gt;Tweener&lt;/strong&gt;を使って、ブロックの消去アニメーションを作ってみました。
次回はいよいよ最終回です。最終回では、もう少しゲームらしくするために、ゲームオーバーとクリア処理を追加してみたいと思います。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【phina.js】ゲーム作成チュートリアル（ブロック崩し）第5回＝ボールとブロックの反射処理＝</title>
      <link>https://alkn203.github.io/blog/2015/11/02/breakout-tut-05</link>
      <pubDate>Mon, 02 Nov 2015 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2015/11/02/breakout-tut-05</guid>
      <description>

&lt;h2 id=&#34;はじめに&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;前回は、ボールと画面端、ボールとパドルの反射処理を実装しました。
今回は、ボールとブロックの反射処理、そしてブロックの消去処理を追加したいと思います。&lt;/p&gt;

&lt;h2 id=&#34;ボールとブロックの反射処理&#34;&gt;ボールとブロックの反射処理&lt;/h2&gt;

&lt;p&gt;ボールがブロックに当たると反射するようにします。まず、反射のパターンを整理したいと思います。
そこで、ボールとブロックとの当たり判定を以下のパターンに分けてみました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ブロックの左上角&lt;/strong&gt; ・・・左上に跳ね返す&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ブロックの右上角&lt;/strong&gt; ・・・右上に跳ね返す&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ブロックの左下角&lt;/strong&gt; ・・・左下に跳ね返す&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ブロックの右下角&lt;/strong&gt; ・・・右下に跳ね返す&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ブロックの上面と下面&lt;/strong&gt; ・・・縦移動を反転させる&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ブロックの左側面と右側面&lt;/strong&gt; ・・・横移動を反転させる&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://alkn203.github.io/blog/img/balltoblock.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;コードは以下のとおりです。&lt;/p&gt;

&lt;div class=&#39;runstant&#39;&gt;&lt;iframe src=&#39;http://goo.gl/tCHV5X&#39; width=&#39;100%&#39; height=&#39;640px&#39; style=&#39;border:0px;box-shadow:0px 0px 2px 0px #aaa&#39;&gt;&lt;/iframe&gt;&lt;/div&gt;

&lt;h2 id=&#34;コード説明&#34;&gt;コード説明&lt;/h2&gt;

&lt;p&gt;当たり判定はボールの移動中常時行う必要があるので、&lt;strong&gt;update&lt;/strong&gt;関数内に追加します。&lt;/p&gt;

&lt;h3 id=&#34;ブロックとの反射&#34;&gt;ブロックとの反射&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// ブロックとの反射
this.blockGroup.children.some(function(block) {
  // ヒットなら
  if (ball.hitTestElement(block)) {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;blockGroup&lt;/strong&gt;の子要素配列をループして、ボールとの当たり判定を行います。
&lt;strong&gt;each&lt;/strong&gt;を使いたいところですが、現状&lt;strong&gt;forEach&lt;/strong&gt;には&lt;strong&gt;break&lt;/strong&gt;に当たる処理がないとのことですので、打開策として&lt;strong&gt;some&lt;/strong&gt;関数を使って、当たりと判定されたらループを抜けるようにしています。
この手法については、&lt;a href=&#34;http://qiita.com/phi/items/f998763d2d52bdd57a7c&#34;&gt;本記事&lt;/a&gt;を参考にしています。&lt;/p&gt;

&lt;h3 id=&#34;角のあたり判定&#34;&gt;角のあたり判定&lt;/h3&gt;

&lt;p&gt;角の当たり判定については、左上角を例に説明します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 左上かど
if (ball.top &amp;lt; block.top &amp;amp;&amp;amp; ball.left &amp;lt; block.left) {
  // 位置補正
  ball.right = block.left;
  ball.bottom = block.top;
  // 移動方向設定
  ball.vx = -ball.speed;
  ball.vy = -ball.speed;
  return true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;左上角の場合は、ボールがブロックに当たっていて、&lt;strong&gt;ボールの左側がブロックの左側より左、かつボールの上側がブロックの上側より上&lt;/strong&gt;という位置関係にある時です。
&lt;img src=&#34;http://alkn203.github.io/blog/img/lefttop.png&#34; /&gt;
画面上で&lt;strong&gt;vx&lt;/strong&gt;は負、&lt;strong&gt;vy&lt;/strong&gt;も負の方向、つまり左斜め上45度方向に返します。&lt;/p&gt;

&lt;h3 id=&#34;側面との当たり判定&#34;&gt;側面との当たり判定&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 左側
if (ball.left &amp;lt; block.left) {
  ball.right = block.left;
  ball.vx = -ball.vx;
  return true;
}
// 右側
if (block.right &amp;lt; ball.right) {
  ball.left = block.right;
  ball.vx = -ball.vx;
  return true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://alkn203.github.io/blog/img/left.png&#34; /&gt;
側面の場合は、&lt;strong&gt;vy&lt;/strong&gt;はそのままで&lt;strong&gt;vx&lt;/strong&gt;を反転させます。&lt;/p&gt;

&lt;h3 id=&#34;上下面との当たり判定&#34;&gt;上下面との当たり判定&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 上側
if (ball.top &amp;lt; block.top) {
  ball.bottom = block.top;
  ball.vy = -ball.vy;
  return true;
}
// 下側
if (block.bottom &amp;lt; ball.bottom) {
  ball.top = block.bottom;
  ball.vy = -ball.vy;
  return true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://alkn203.github.io/blog/img/top.png&#34; /&gt;
上下面の場合は、&lt;strong&gt;vx&lt;/strong&gt;はそのままで&lt;strong&gt;vy&lt;/strong&gt;を反転させます。&lt;/p&gt;

&lt;h2 id=&#34;ボールが当たったブロックを消去する&#34;&gt;ボールが当たったブロックを消去する&lt;/h2&gt;

&lt;p&gt;次はブロックの消去処理を追加します。コードは以下のとおりです。&lt;/p&gt;

&lt;div class=&#39;runstant&#39;&gt;&lt;iframe src=&#39;http://goo.gl/xF7tNc&#39; width=&#39;100%&#39; height=&#39;640px&#39; style=&#39;border:0px;box-shadow:0px 0px 2px 0px #aaa&#39;&gt;&lt;/iframe&gt;&lt;/div&gt;

&lt;h2 id=&#34;コード説明-1&#34;&gt;コード説明&lt;/h2&gt;

&lt;h3 id=&#34;消去処理&#34;&gt;消去処理&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// ブロック消去
block.remove();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当たり判定で当たったブロックについて、&lt;strong&gt;block.remove&lt;/strong&gt;として自身を消去しています。
この処理を各判定毎に行います。&lt;/p&gt;

&lt;h3 id=&#34;補足&#34;&gt;補足&lt;/h3&gt;

&lt;p&gt;お気づきの方もいらっしゃるかもしれませんが、このままの処理だと当たり具合によって内部のブロックまで消去されることがあります。
これを防ぐためには、当たったブロックが一番外側にあるかどうかの判定を追加する必要があるかと思いますが、今回は割愛したいと思います。&lt;/p&gt;

&lt;h2 id=&#34;今回はここまで&#34;&gt;今回はここまで&lt;/h2&gt;

&lt;p&gt;ここまでで、ボールを跳ね返してブロックが消去できるようになりました。
少しはブロック崩しらしくなってきたのではないかと思います。
次回は、&lt;strong&gt;phina.js&lt;/strong&gt;の目玉機能の１つとも言える&lt;strong&gt;Tweener&lt;/strong&gt;を使って、ブロックの消去アニメーションを行いと思います。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【phina.js】ゲーム作成チュートリアル（ブロック崩し）第4回＝ボールの作成＝</title>
      <link>https://alkn203.github.io/blog/2015/11/01/breakout-tut-04</link>
      <pubDate>Sun, 01 Nov 2015 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2015/11/01/breakout-tut-04</guid>
      <description>

&lt;h2 id=&#34;はじめに&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;前回は、プレイヤーが操作する&lt;strong&gt;パドル&lt;/strong&gt;を作成しました。
今回は、ブロック崩しの肝とも言える&lt;strong&gt;ボール&lt;/strong&gt;を作成したいと思います。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://alkn203.github.io/blog/images/breakout-tut-04.png&#34; alt=&#34;breakout-tut-04&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;コードは以下のとおりです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// グローバルに展開
phina.globalize();
/*
 * 定数
 */
var BLOCK_WIDTH = 40 * 2;
var BLOCK_HEIGHT = 60 / 2;
var PADDLE_WIDTH = BLOCK_WIDTH * 1.5;
var PADDLE_HEIGHT = BLOCK_HEIGHT;
var BALL_RADIUS = BLOCK_WIDTH / 8;
/*
 * メインシーン
 */
phina.define(&amp;quot;MainScene&amp;quot;, {
  // 継承
  superClass: &#39;DisplayScene&#39;,
  // コンストラクタ
  init: function() {
    // 親クラス初期化
    this.superInit();
    // 背景色
    this.backgroundColor = &#39;black&#39;;
    // ブロックグループ
    this.blockGroup = DisplayElement().addChildTo(this);
    // 位置判定用のRect
    var screenRect = Rect(0, 0, 640, 960);

    var self = this;
    // Gridを利用してブロック設置
    Array.range(2, 16, 2).each(function(spanX) {
      Array.range(1, 4, 0.5).each(function(spanY) {
        Block().addChildTo(self.blockGroup)
               .setPosition(self.gridX.span(spanX), self.gridY.span(spanY));
      });
    });
    // パドル移動ライン
    var paddleY = this.gridY.span(14.5);
    // パドル設置
    var paddle = Paddle().addChildTo(this)
                         .setPosition(this.gridX.center(), paddleY);
    // 画面上でのタッチ移動時
    this.onpointmove = function(e) {
      // タッチ位置に移動
      paddle.setPosition(e.pointer.x | 0, paddleY);
      // 画面はみ出し防止
      if (paddle.left &amp;lt; screenRect.left) { paddle.left = screenRect.left; }
      if (paddle.right &amp;gt; screenRect.right) { paddle.right = screenRect.right; }
    };
    // ボール作成
    this.ball = Ball().addChildTo(this);
    // シーン全体から参照可能にする
    this.paddle = paddle;
  },
  // 毎フレーム更新
  update: function() {
    var ball = this.ball;
    var paddle = this.paddle;
    // ボールはパドルの真上
    ball.x = paddle.x;
    ball.bottom = paddle.top;
  },
});
/*
 * ブロッククラス
 */
phina.define(&#39;Block&#39;, {
  // 親クラス指定
  superClass: &#39;RectangleShape&#39;,
  // コンストラクタ
  init: function() {
    // 親クラス初期化
    this.superInit({
      width: BLOCK_WIDTH,
      height: BLOCK_HEIGHT,
    });
  },
});
/*
 * パドルクラス
 */
phina.define(&#39;Paddle&#39;, {
  // 親クラス指定
  superClass: &#39;RectangleShape&#39;,
  // コンストラクタ
  init: function() {
    // 親クラス初期化
    this.superInit({
      width: PADDLE_WIDTH,
      height: PADDLE_HEIGHT,
      fill: &#39;silver&#39;,
    });
  },
});
/*
 * ボールクラス
 */
phina.define(&#39;Ball&#39;, {
  // 親クラス指定
  superClass: &#39;CircleShape&#39;,
  // コンストラクタ
  init: function() {
    // 親クラス初期化
    this.superInit({
      radius: BALL_RADIUS,
      fill: &#39;silver&#39;,
    });
  },
});
/*
 * メイン処理
 */
phina.main(function() {
  // アプリケーションを生成
  var app = GameApp({
    title: &#39;Break Out&#39;,
  });
  // 実行
  app.run();
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/0d1fb8d6&#34; target=&#34;_blank&#34;&gt;[runstantで確認]&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;コード説明&#34;&gt;コード説明&lt;/h2&gt;

&lt;h3 id=&#34;定数&#34;&gt;定数&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var BALL_RADIUS = BLOCK_WIDTH / 8;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;ボールの半径をブロックの幅の1/8のサイズにしています。つまり、直径がブロックの幅の1/4の円とします。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;ボールクラス&#34;&gt;ボールクラス&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;phina.define(&#39;Ball&#39;, {
  // 親クラス指定
  superClass: &#39;CircleShape&#39;,
  // コンストラクタ
  init: function() {
    // 親クラス初期化
    this.superInit({
      radius: BALL_RADIUS,
      fill: &#39;silver&#39;,
    });
  },
});
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;phina.define&lt;/strong&gt;で&lt;strong&gt;Ball&lt;/strong&gt;クラスを定義しています。&lt;/li&gt;
&lt;li&gt;ボールは円なので&lt;strong&gt;CircleShape&lt;/strong&gt;クラスを継承し、&lt;strong&gt;superInit&lt;/strong&gt;で親クラスへパラメータを渡しています。&lt;strong&gt;radius&lt;/strong&gt;は円の半径サイズです。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;ボールの追加&#34;&gt;ボールの追加&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    // ボール作成
    this.ball = Ball().addChildTo(this);
    // シーン全体から参照可能にする
    this.paddle = paddle;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;ボールを作成して&lt;strong&gt;MainScene&lt;/strong&gt;に追加しています。位置は別で設定するので、今回はシーンへの追加のみです。&lt;/li&gt;
&lt;li&gt;現在の&lt;strong&gt;paddle&lt;/strong&gt;変数は、&lt;strong&gt;init&lt;/strong&gt;関数内だけのスコープとなっているので、&lt;strong&gt;MainScene&lt;/strong&gt;全体から参照できるように&lt;strong&gt;this.paddle&lt;/strong&gt;に代入しています。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;フレーム処理&#34;&gt;フレーム処理&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // 毎フレーム更新
  update: function() {
    var ball = this.ball;
    var paddle = this.paddle;
    // ボールはパドルの真上
    ball.x = paddle.x;
    ball.bottom = paddle.top;
  },
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;update&lt;/strong&gt;関数には、毎フレーム行う処理を記載します。&lt;/li&gt;
&lt;li&gt;ボールをパドルの真上になるように設置します。&lt;/li&gt;
&lt;li&gt;毎フレーム呼ばれるので、パドルを移動してもボールが追従するようになります。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;ボールの発射-パドルおよび壁との反射処理&#34;&gt;ボールの発射、パドルおよび壁との反射処理&lt;/h2&gt;

&lt;p&gt;このままだと、ボールがパドルについたままですので、ボールの発射と反射処理を追加します。コードは以下のとおりです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// グローバルに展開
phina.globalize();
/*
 * 定数
 */
var BLOCK_WIDTH = 40 * 2;
var BLOCK_HEIGHT = 60 / 2;
var PADDLE_WIDTH = BLOCK_WIDTH * 1.5;
var PADDLE_HEIGHT = BLOCK_HEIGHT;
var BALL_RADIUS = BLOCK_WIDTH / 8;
/*
 * メインシーン
 */
phina.define(&amp;quot;MainScene&amp;quot;, {
  // 継承
  superClass: &#39;DisplayScene&#39;,
  // コンストラクタ
  init: function() {
    // 親クラス初期化
    this.superInit();
    // 背景色
    this.backgroundColor = &#39;black&#39;;
    // ブロックグループ
    this.blockGroup = DisplayElement().addChildTo(this);
    // 位置判定用のRect
    var screenRect = Rect(0, 0, 640, 960);

    var self = this;
    // Gridを利用してブロック設置
    Array.range(2, 16, 2).each(function(spanX) {
      Array.range(1, 4, 0.5).each(function(spanY) {
        Block().addChildTo(self.blockGroup)
               .setPosition(self.gridX.span(spanX), self.gridY.span(spanY));
      });
    });
    // パドル移動ライン
    var paddleY = this.gridY.span(14.5);
    // パドル設置
    var paddle = Paddle().addChildTo(this)
                         .setPosition(this.gridX.center(), paddleY);
    // 画面上でのタッチ移動時
    this.onpointmove = function(e) {
      // タッチ位置に移動
      paddle.setPosition(e.pointer.x | 0, paddleY);
      // 画面はみ出し防止
      if (paddle.left &amp;lt; screenRect.left) { paddle.left = screenRect.left; }
      if (paddle.right &amp;gt; screenRect.right) { paddle.right = screenRect.right; }
    };
    // 画面上でタッチが離れた時
    this.onpointend = function() {
      if (self.status === &#39;ready&#39;) {
        // ボール発射
        self.ball.vy = -self.ball.speed;
        self.status = &#39;move&#39;;
      }
    };
    // ボール作成
    this.ball = Ball().addChildTo(this);
    // シーン全体から参照可能にする
    this.paddle = paddle;
    this.screenRect = screenRect;
    // ゲーム状態
    this.status = &#39;ready&#39;;
  },
  // 毎フレーム更新
  update: function() {
    var ball = this.ball;
    var paddle = this.paddle;
    var screenRect = this.screenRect;
    // ボール待機中
    if (this.status === &#39;ready&#39;) {
      // ボールはパドルの真上
      ball.vx = ball.vy = 0;
      ball.x = paddle.x;
      ball.bottom = paddle.top;
    }
    // ボール移動中
    if (this.status === &#39;move&#39;) {
      // ボール移動
      ball.moveBy(ball.vx, ball.vy);
      // 画面端反射
      // 上
      if (ball.top &amp;lt; screenRect.top) {
        ball.top = screenRect.top;
        ball.vy = -ball.vy;
      }
      // 左
      if (ball.left &amp;lt; screenRect.left) {
        ball.left = screenRect.left;
        ball.vx = -ball.vx;
      }
      // 右
      if (ball.right &amp;gt; screenRect.right) {
        ball.right = screenRect.right;
        ball.vx = -ball.vx;
      }
      // 落下
      if (ball.top &amp;gt; screenRect.bottom) {
        // 準備状態へ
        this.status = &#39;ready&#39;;
      }
      // パドルとの反射
      if (ball.hitTestElement(paddle) &amp;amp;&amp;amp; ball.vy &amp;gt; 0) {
        ball.bottom = paddle.top;
        ball.vy = -ball.vy;
        // 当たった位置で角度を変化させる
        var dx = paddle.x - ball.x;
        ball.vx = -dx / 5;
      }
    }
  },
});
/*
 * ブロッククラス
 */
phina.define(&#39;Block&#39;, {
  // 親クラス指定
  superClass: &#39;RectangleShape&#39;,
  // コンストラクタ
  init: function() {
    // 親クラス初期化
    this.superInit({
      width: BLOCK_WIDTH,
      height: BLOCK_HEIGHT,
    });
  },
});
/*
 * パドルクラス
 */
phina.define(&#39;Paddle&#39;, {
  // 親クラス指定
  superClass: &#39;RectangleShape&#39;,
  // コンストラクタ
  init: function() {
    // 親クラス初期化
    this.superInit({
      width: PADDLE_WIDTH,
      height: PADDLE_HEIGHT,
      fill: &#39;silver&#39;,
    });
  },
});
/*
 * ボールクラス
 */
phina.define(&#39;Ball&#39;, {
  // 親クラス指定
  superClass: &#39;CircleShape&#39;,
  // コンストラクタ
  init: function() {
    // 親クラス初期化
    this.superInit({
      radius: BALL_RADIUS,
      fill: &#39;silver&#39;,
    });
    // スピード
    this.speed = 6;
  },
});
/*
 * メイン処理
 */
phina.main(function() {
  // アプリケーションを生成
  var app = GameApp({
    title: &#39;Break Out&#39;,
  });
  // fps変更
  app.fps = 60;
  // 実行
  app.run();
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/9bf709b3&#34; target=&#34;_blank&#34;&gt;[runstantで確認]&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;コード説明-1&#34;&gt;コード説明&lt;/h2&gt;

&lt;h3 id=&#34;ボールのスピード&#34;&gt;ボールのスピード&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    // スピード
    this.speed = 6;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Ball&lt;/strong&gt;クラスにボールのスピードのプロパティを追加します。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;ゲームステータス&#34;&gt;ゲームステータス&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    // ゲーム状態
    this.status = &#39;ready&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;ボールの状態管理のための変数を追加します。&lt;strong&gt;ready&lt;/strong&gt;は、パドルの上で待機中の状態とします。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;ボールの発射&#34;&gt;ボールの発射&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    // 画面上でタッチが離れた時
    this.onpointend = function() {
      if (self.status === &#39;ready&#39;) {
        // ボール発射
        self.ball.vy = -self.ball.speed;
        self.status = &#39;move&#39;;
      }
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;ボールはタッチを離した時に発射させたいので、&lt;strong&gt;pointend&lt;/strong&gt;イベントを拾う&lt;strong&gt;this.onpointend&lt;/strong&gt;関数内に処理を書きます。&lt;/li&gt;
&lt;li&gt;ボールの状態が&lt;strong&gt;ready&lt;/strong&gt;の場合に、&lt;strong&gt;ball.vy&lt;/strong&gt;として、スピードを元にした画面上方向の移動量を設定します。&lt;/li&gt;
&lt;li&gt;ボール発射後は、状態を&lt;strong&gt;move&lt;/strong&gt;としています。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;ボールの状態で処理を分ける&#34;&gt;ボールの状態で処理を分ける&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    // ボール待機中
    if (this.status === &#39;ready&#39;) {
      // ボールはパドルの真上
      ball.vx = ball.vy = 0;
      ball.x = paddle.x;
      ball.bottom = paddle.top;
    }
    // ボール移動中
    if (this.status === &#39;move&#39;) {
      // ボール移動
      ball.moveBy(ball.vx, ball.vy);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;update&lt;/strong&gt;関数内の処理をボールの状態で分けます。&lt;/li&gt;
&lt;li&gt;移動中の場合は、&lt;strong&gt;moveBy&lt;/strong&gt;関数でx方向、y方向の移動量を元に移動処理を行います。ゲーム作りにおいてよく使われる手法です。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;壁との発射処理&#34;&gt;壁との発射処理&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;      // 画面端反射
      // 上
      if (ball.top &amp;lt; screenRect.top) {
        ball.top = screenRect.top;
        ball.vy = -ball.vy;
      }
      // 左
      if (ball.left &amp;lt; screenRect.left) {
        ball.left = screenRect.left;
        ball.vx = -ball.vx;
      }
      // 右
      if (ball.right &amp;gt; screenRect.right) {
        ball.right = screenRect.right;
        ball.vx = -ball.vx;
      }
      // 落下
      if (ball.top &amp;gt; screenRect.bottom) {
        // 準備状態へ
        this.status = &#39;ready&#39;;
      }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;画面上と左右を壁とみなして、反射処理を行います。&lt;/li&gt;
&lt;li&gt;上の場合は&lt;strong&gt;vy&lt;/strong&gt;を反転、左右の場合は、&lt;strong&gt;vx&lt;/strong&gt;を反転させています。&lt;/li&gt;
&lt;li&gt;反射をきれいに見せるために、ボール位置の補正をしています。&lt;/li&gt;
&lt;li&gt;画面下の場合は落下とみなして、ボールを初期状態に戻しています。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;パドルとの発射処理&#34;&gt;パドルとの発射処理&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;      // パドルとの反射
      if (ball.hitTestElement(paddle) &amp;amp;&amp;amp; ball.vy &amp;gt; 0) {
        ball.bottom = paddle.top;
        ball.vy = -ball.vy;
        // 当たった位置で角度を変化させる
        var dx = paddle.x - ball.x;
        ball.vx = -dx / 5;
      }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;hitTestElement&lt;/strong&gt;でボールとパドルの当たり判定を行っています。&lt;/li&gt;
&lt;li&gt;想定外の反射を防ぐために、ボールの移動方向が下向きであるかを併せてチェックしています。&lt;/li&gt;
&lt;li&gt;初期設定のままだとボールが縦方向へ行ったり来たりしかしないので、パドルに当たった位置に応じて、角度を変化させています。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;今回はここまで&#34;&gt;今回はここまで&lt;/h2&gt;

&lt;p&gt;ここまでで、ボールを発射してパドルで跳ね返すことができるようになりました。
次回は、ボールとブロックの反射を追加したいと思います。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【phina.js】ゲーム作成チュートリアル（ブロック崩し）第3回＝パドルの作成＝</title>
      <link>https://alkn203.github.io/blog/2015/10/29/breakout-tut-03</link>
      <pubDate>Thu, 29 Oct 2015 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2015/10/29/breakout-tut-03</guid>
      <description>

&lt;h2 id=&#34;はじめに&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;前回は、画面上部にブロックを配置しました。
今回は、プレイヤーが操作する&lt;strong&gt;パドル&lt;/strong&gt;を作成したいと思います。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://alkn203.github.io/blog/images/breakout-tut-03.png&#34; alt=&#34;breakout-tut-03&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;h2 id=&#34;定数とpaddleクラスを定義する&#34;&gt;定数とPaddleクラスを定義する&lt;/h2&gt;

&lt;p&gt;パドル用の定数を追加して、&lt;strong&gt;Paddle&lt;/strong&gt;クラスを&lt;strong&gt;phina.define&lt;/strong&gt;で定義します。コードは以下のとおりです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// グローバルに展開
phina.globalize();
/*
 * 定数
 */
var BLOCK_WIDTH = 40 * 2;
var BLOCK_HEIGHT = 60 / 2;
var PADDLE_WIDTH = BLOCK_WIDTH * 1.5;
var PADDLE_HEIGHT = BLOCK_HEIGHT;
/*
 * メインシーン
 */
phina.define(&amp;quot;MainScene&amp;quot;, {
  // 継承
  superClass: &#39;DisplayScene&#39;,
  // コンストラクタ
  init: function() {
    // 親クラス初期化
    this.superInit();
    // 背景色
    this.backgroundColor = &#39;black&#39;;
    // ブロックグループ
    this.blockGroup = DisplayElement().addChildTo(this);

    var self = this;
    // Gridを利用してブロック設置
    Array.range(2, 16, 2).each(function(spanX) {
      Array.range(1, 4, 0.5).each(function(spanY) {
        Block().addChildTo(self.blockGroup)
               .setPosition(self.gridX.span(spanX), self.gridY.span(spanY));
      });
    });
    // パドル移動ライン
    var paddleY = this.gridY.span(14.5);
    // パドル設置
    var paddle = Paddle().addChildTo(this)
                         .setPosition(this.gridX.center(), paddleY);
  },
});
/*
 * ブロッククラス
 */
phina.define(&#39;Block&#39;, {
  // 親クラス指定
  superClass: &#39;RectangleShape&#39;,
  // コンストラクタ
  init: function() {
    // 親クラス初期化
    this.superInit({
      width: BLOCK_WIDTH,
      height: BLOCK_HEIGHT,
    });
  },
});
/*
 * パドルクラス
 */
phina.define(&#39;Paddle&#39;, {
  // 親クラス指定
  superClass: &#39;RectangleShape&#39;,
  // コンストラクタ
  init: function() {
    // 親クラス初期化
    this.superInit({
      width: PADDLE_WIDTH,
      height: PADDLE_HEIGHT,
      fill: &#39;silver&#39;,
    });
  },
});
/*
 * メイン処理
 */
phina.main(function() {
  // アプリケーションを生成
  var app = GameApp({
    title: &#39;Break Out&#39;,
  });
  // 実行
  app.run();
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/305fd254&#34; target=&#34;_blank&#34;&gt;[runstantで確認]&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;コード説明&#34;&gt;コード説明&lt;/h2&gt;

&lt;h3 id=&#34;定数&#34;&gt;定数&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var PADDLE_WIDTH = BLOCK_WIDTH * 1.5;
var PADDLE_HEIGHT = BLOCK_HEIGHT;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;パドルの横幅はブロックの横幅の1.5倍、縦幅はブロックの縦幅と同じにします。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;パドルクラス&#34;&gt;パドルクラス&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;phina.define(&#39;Paddle&#39;, {
  // 親クラス指定
  superClass: &#39;RectangleShape&#39;,
  // コンストラクタ
  init: function() {
    // 親クラス初期化
    this.superInit({
      width: PADDLE_WIDTH,
      height: PADDLE_HEIGHT,
      fill: &#39;silver&#39;,
    });
  },
});
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;phina.define&lt;/strong&gt;で&lt;strong&gt;Paddle&lt;/strong&gt;クラスを定義しています。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Block&lt;/strong&gt;クラスと同様に&lt;strong&gt;RectangleShape&lt;/strong&gt;クラスを継承し、&lt;strong&gt;superInit&lt;/strong&gt;で親クラスへパラメータを渡しています。&lt;/li&gt;
&lt;li&gt;パラメータの&lt;strong&gt;fill&lt;/strong&gt;は塗りつぶしの色です。 &lt;strong&gt;phina.js&lt;/strong&gt;では、他に&lt;strong&gt;rgb&lt;/strong&gt;や&lt;strong&gt;hsl&lt;/strong&gt;形式でも色を指定できます。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;パドルの配置&#34;&gt;パドルの配置&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    // パドル移動ライン
    var paddleY = this.gridY.span(14.5);
    // パドル設置
    var paddle = Paddle().addChildTo(this)
                         .setPosition(this.gridX.center(), paddleY);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;paddleY&lt;/strong&gt;は、パドルが移動するラインのy座標です。&lt;/li&gt;
&lt;li&gt;パドルを作成して&lt;strong&gt;MainScene&lt;/strong&gt;に追加しています。&lt;/li&gt;
&lt;li&gt;初期位置は、画面の中央下としています。&lt;strong&gt;this.gridX.center()&lt;/strong&gt;で、画面中央のx座標を得ることができます。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;パドルの移動処理&#34;&gt;パドルの移動処理&lt;/h3&gt;

&lt;p&gt;このままではハドルが画面に表示されただけですので、移動処理を追加します。
コードは以下のとおりです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// グローバルに展開
phina.globalize();
/*
 * 定数
 */
var BLOCK_WIDTH = 40 * 2;
var BLOCK_HEIGHT = 60 / 2;
var PADDLE_WIDTH = BLOCK_WIDTH * 1.5;
var PADDLE_HEIGHT = BLOCK_HEIGHT;
/*
 * メインシーン
 */
phina.define(&amp;quot;MainScene&amp;quot;, {
  // 継承
  superClass: &#39;DisplayScene&#39;,
  // コンストラクタ
  init: function() {
    // 親クラス初期化
    this.superInit();
    // 背景色
    this.backgroundColor = &#39;black&#39;;
    // ブロックグループ
    this.blockGroup = DisplayElement().addChildTo(this);
    // 位置判定用のRect
    var screenRect = Rect(0, 0, 640, 960);

    var self = this;
    // Gridを利用してブロック設置
    Array.range(2, 16, 2).each(function(spanX) {
      Array.range(1, 4, 0.5).each(function(spanY) {
        Block().addChildTo(self.blockGroup)
               .setPosition(self.gridX.span(spanX), self.gridY.span(spanY));
      });
    });
    // パドル移動ライン
    var paddleY = this.gridY.span(14.5);
    // パドル設置
    var paddle = Paddle().addChildTo(this)
                         .setPosition(this.gridX.center(), paddleY);
    // 画面上でのタッチ移動時
    this.onpointmove = function(e) {
      // タッチ位置に移動
      paddle.setPosition(e.pointer.x | 0, paddleY);
      // 画面はみ出し防止
      if (paddle.left &amp;lt; screenRect.left) { paddle.left = screenRect.left; }
      if (paddle.right &amp;gt; screenRect.right) { paddle.right = screenRect.right; }
    };
  },
});
/*
 * ブロッククラス
 */
phina.define(&#39;Block&#39;, {
  // 親クラス指定
  superClass: &#39;RectangleShape&#39;,
  // コンストラクタ
  init: function() {
    // 親クラス初期化
    this.superInit({
      width: BLOCK_WIDTH,
      height: BLOCK_HEIGHT,
    });
  },
});
/*
 * パドルクラス
 */
phina.define(&#39;Paddle&#39;, {
  // 親クラス指定
  superClass: &#39;RectangleShape&#39;,
  // コンストラクタ
  init: function() {
    // 親クラス初期化
    this.superInit({
      width: PADDLE_WIDTH,
      height: PADDLE_HEIGHT,
      fill: &#39;silver&#39;,
    });
  },
});
/*
 * メイン処理
 */
phina.main(function() {
  // アプリケーションを生成
  var app = GameApp({
    title: &#39;Break Out&#39;,
  });
  // 実行
  app.run();
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/247775fb&#34; target=&#34;_blank&#34;&gt;[runstantで確認]&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;コード説明-1&#34;&gt;コード説明&lt;/h2&gt;

&lt;h3 id=&#34;画面の矩形&#34;&gt;画面の矩形&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var screenRect = Rect(0, 0, 640, 960);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;画面端との位置判定用に、画面と同じサイズの&lt;strong&gt;Rect&lt;/strong&gt;オブジェクトを作成します。&lt;strong&gt;Rect&lt;/strong&gt;クラスは、実体は無く、矩形の位置やサイズ情報だけを持ったものと理解して下さい。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;移動処理&#34;&gt;移動処理&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    // 画面上でのタッチ移動時
    this.onpointmove = function(e) {
      // タッチ位置に移動
      paddle.setPosition(e.pointer.x | 0, paddleY);
      // 画面はみ出し防止
      if (paddle.left &amp;lt; screenRect.left) { paddle.left = screenRect.left; }
      if (paddle.right &amp;gt; screenRect.right) { paddle.right = screenRect.right; }
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;パドルの移動処理です。&lt;/li&gt;
&lt;li&gt;画面上でタッチが移動した時に&lt;strong&gt;onpointmove&lt;/strong&gt;イベントが発生しますので、それを拾って関数に処理を書きます。&lt;/li&gt;
&lt;li&gt;引数の&lt;strong&gt;e&lt;/strong&gt;にポイント関係の情報が入ってきますので、&lt;strong&gt;e.pointer.x&lt;/strong&gt;でタッチされているx座標だけを取得します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;setPosition&lt;/strong&gt;で、パドルをタッチされている位置に移動させます。この時、Y座標は固定したままにします。&lt;/li&gt;
&lt;li&gt;次の&lt;strong&gt;if&lt;/strong&gt;文は、パドルが画面からはみ出さないように調整しています。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Shape&lt;/strong&gt;などは、&lt;strong&gt;left、right、top、bottom&lt;/strong&gt;プロパティを持っているので、それを活用して上記のような位置合わせを簡単に行うことができます。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;今回はここまで&#34;&gt;今回はここまで&lt;/h2&gt;

&lt;p&gt;ここまでで、パドルを動かせるようになり、少しずつブロック崩しらしくなってきました。
次回は、ボールを追加したいと思います。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【phina.js】ゲーム作成チュートリアル（ブロック崩し）第2回＝ブロックの配置＝</title>
      <link>https://alkn203.github.io/blog/2015/10/29/breakout-tut-02</link>
      <pubDate>Thu, 29 Oct 2015 20:50:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2015/10/29/breakout-tut-02</guid>
      <description>

&lt;h2 id=&#34;目的&#34;&gt;目的&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://alkn203.github.io/blog/2015/10/26/beakout-tut-01/&#34;&gt;前回&lt;/a&gt;は、&lt;a href=&#34;https://github.com/phi-jp/phina.js&#34;&gt;phina.js&lt;/a&gt;のテンプレートからゲーム作成の下準備をしました。今回からゲーム内容のコーディングをしていきます。
まず最初に以下のように&lt;strong&gt;ブロック&lt;/strong&gt;を配置したいと思います。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://alkn203.github.io/blog/images/breakout-tut-02.png&#34; alt=&#34;breakout-tut-02&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;h2 id=&#34;定数とblockクラスを定義する&#34;&gt;定数とBlockクラスを定義する&lt;/h2&gt;

&lt;p&gt;ゲーム内で使用する定数は通常の&lt;strong&gt;var&lt;/strong&gt;で、&lt;strong&gt;Block&lt;/strong&gt;クラスは&lt;strong&gt;phina.define&lt;/strong&gt;を使って定義します。コードは以下のとおりです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;phina.globalize();
/*
 * 定数
 */
var BLOCK_WIDTH = 40 * 2;
var BLOCK_HEIGHT = 60 / 2;
/*
 * メインシーン
 */
phina.define(&#39;MainScene&#39;, {
  superClass: &#39;DisplayScene&#39;,
  // コンストラクタ
  init: function() {
    // 親クラス初期化
    this.superInit();
    // 背景色
    this.backgroundColor = &#39;black&#39;;
  },
});
/*
 * ブロッククラス
 */
phina.define(&#39;Block&#39;, {
  // 親クラス指定
  superClass: &#39;RectangleShape&#39;,
  // コンストラクタ
  init: function() {
    // 親クラス初期化
    this.superInit({
      width: BLOCK_WIDTH,
      height: BLOCK_HEIGHT,
    });
  },
});
/*
 * メイン処理
 */
phina.main(function() {
  // アプリケーションを生成
  var app = GameApp({
    title: &#39;Break Out&#39;,
  });
  // 実行
  app.run();
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;コード説明&#34;&gt;コード説明&lt;/h2&gt;

&lt;h3 id=&#34;定数&#34;&gt;定数&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var BLOCK_WIDTH = 40 * 2;
var BLOCK_HEIGHT = 60 / 2;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;BLOCK_WIDTH&lt;/strong&gt;はブロックの横幅、&lt;strong&gt;BLOCK_HEIGHT&lt;/strong&gt;はブロックの縦幅です。&lt;/li&gt;
&lt;li&gt;40 や 60という数値を基準にしているのは、&lt;strong&gt;Scene&lt;/strong&gt;にデフォルトで設定されている&lt;strong&gt;Grid&lt;/strong&gt;の存在を意識しているためです。&lt;strong&gt;Grid&lt;/strong&gt;については後述します。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;ブロッククラス&#34;&gt;ブロッククラス&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;phina.define(&#39;Block&#39;, {
  // 親クラス指定
  superClass: &#39;RectangleShape&#39;,
  // コンストラクタ
  init: function() {
    // 親クラス初期化
    this.superInit({
      width: BLOCK_WIDTH,
      height: BLOCK_HEIGHT,
    });
  },
});
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;phina.define&lt;/strong&gt;で&lt;strong&gt;Block&lt;/strong&gt;クラスを定義しています。&lt;/li&gt;
&lt;li&gt;ブロックのグラフィックは、画像ファイルを使わずに&lt;strong&gt;phina.js&lt;/strong&gt;で用意されている基本図形の&lt;strong&gt;Shape&lt;/strong&gt;を活用します。&lt;/li&gt;
&lt;li&gt;今回はその中の１つである&lt;strong&gt;RectangleShape&lt;/strong&gt;（矩形）クラスを継承しています。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;this.superInit&lt;/strong&gt;で、親クラス(&lt;strong&gt;RectangleShape&lt;/strong&gt;)の&lt;strong&gt;width&lt;/strong&gt;と&lt;strong&gt;height&lt;/strong&gt;プロパティに、定数で定義したブロックのサイズをそれぞれ渡しています。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;ブロックを配置する&#34;&gt;ブロックを配置する&lt;/h2&gt;

&lt;p&gt;オーソドックスなブロック崩しの場合、ブロックはタイル状に並んで配置されています。そこで、&lt;strong&gt;phina.js&lt;/strong&gt;で用意されている&lt;strong&gt;Grid&lt;/strong&gt;クラスを利用してタイル状に並べたいと思います。
まずはコードをご覧下さい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// グローバルに展開
phina.globalize();
/*
 * 定数
 */
var BLOCK_WIDTH = 40 * 2;
var BLOCK_HEIGHT = 60 / 2;
/*
 * メインシーン
 */
phina.define(&amp;quot;MainScene&amp;quot;, {
  // 継承
  superClass: &#39;DisplayScene&#39;,
  // コンストラクタ
  init: function() {
    // 親クラス初期化
    this.superInit();
    // 背景色
    this.backgroundColor = &#39;black&#39;;
    // ブロックグループ
    this.blockGroup = DisplayElement().addChildTo(this);

    var self = this;
    // Gridを利用してブロック設置
    Array.range(2, 16, 2).each(function(spanX) {
      Array.range(1, 4, 0.5).each(function(spanY) {
        Block().addChildTo(self.blockGroup)
               .setPosition(self.gridX.span(spanX), self.gridY.span(spanY));
      });
    });
  },
});
/*
 * ブロッククラス
 */
phina.define(&#39;Block&#39;, {
  // 親クラス指定
  superClass: &#39;RectangleShape&#39;,
  // コンストラクタ
  init: function() {
    // 親クラス初期化
    this.superInit({
      width: BLOCK_WIDTH,
      height: BLOCK_HEIGHT,
    });
  },
});
/*
 * メイン処理
 */
phina.main(function() {
  // アプリケーションを生成
  var app = GameApp({
    title: &#39;Break Out&#39;,
  });
  // 実行
  app.run();
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/8308f430&#34; target=&#34;_blank&#34;&gt;[runstantで確認]&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;コード説明-1&#34;&gt;コード説明&lt;/h2&gt;

&lt;h3 id=&#34;ブロックグループの作成&#34;&gt;ブロックグループの作成&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;this.blockGroup = DisplayElement().addChildTo(this);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;作成するブロックは&lt;strong&gt;GameScene&lt;/strong&gt;に直接追加しても良いのですが、利便性を考えて、ブロック管理用のグループを作成します。&lt;/li&gt;
&lt;li&gt;グループは&lt;strong&gt;DisplayElement&lt;/strong&gt;クラスで作成し、&lt;strong&gt;addChildTo(this)&lt;/strong&gt;で&lt;strong&gt;GameScene&lt;/strong&gt;に追加しています。&lt;/li&gt;
&lt;li&gt;個々のブロックは、後のループ処理でグループに追加するようにします。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;gridを使った配置&#34;&gt;Gridを使った配置：&lt;/h3&gt;

&lt;p&gt;ループ使って、ブロックをタイル状に配置する処理です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    var self = this;
    // Gridを利用してブロック設置
    Array.range(2, 16, 2).each(function(spanX) {
      Array.range(1, 4, 0.5).each(function(spanY) {
        Block().addChildTo(self.blockGroup)
               .setPosition(self.gridX.span(spanX), self.gridY.span(spanY));
      });
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まずループ処理について見てみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Array.range(2, 16, 2).each(function(spanX) {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;phina.js&lt;/strong&gt;では、元々の&lt;strong&gt;javascript&lt;/strong&gt;の&lt;strong&gt;Array&lt;/strong&gt;に様々な拡張が施されています。
&lt;strong&gt;range&lt;/strong&gt;はその中の１つで、&lt;strong&gt;範囲指定した数値の配列&lt;/strong&gt;を新たに作ってくれます。&lt;strong&gt;Python&lt;/strong&gt;の&lt;strong&gt;range&lt;/strong&gt;と同じ仕様です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Array.range(開始、終了、ステップ数)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今回の場合は、&lt;strong&gt;[2,4,6,8,10,12,14]&lt;/strong&gt;という配列を作成したことになります。
次の&lt;strong&gt;each&lt;/strong&gt;は、基本的に&lt;strong&gt;javascript&lt;/strong&gt;の&lt;strong&gt;forEach&lt;/strong&gt;と同じで、引数で与えられたコールバック関数内の処理を配列の各要素に適用します。
まとめると、&lt;strong&gt;[2,4,6,8,10,12,14]&lt;/strong&gt;という配列の各々の要素に対して、&lt;strong&gt;function&lt;/strong&gt;内の処理を適用するということになります。各要素は、引数の&lt;strong&gt;spanX&lt;/strong&gt;で参照することができます。
同様に、以下で縦方向の繰り返しを行っています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Array.range(1, 4, 0.5).each(function(spanY) {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ループ処理について、今回は&lt;strong&gt;phina.js&lt;/strong&gt;らしい書き方にしてみましたが、もちろん通常の&lt;strong&gt;for&lt;/strong&gt;文を使っても全く問題ありません。&lt;/p&gt;

&lt;p&gt;最後に、個々のブロックを作成して追加する処理について説明します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;        Block().addChildTo(self.blockGroup)
               .setPosition(self.gridX.span(spanX), self.gridY.span(spanY));
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Block&lt;/strong&gt;クラスのオブジェクトを作成して、前もって作っておいた&lt;strong&gt;blockGroup&lt;/strong&gt;に追加しています。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;this.blockGroup&lt;/strong&gt;と書きたいところですが、&lt;strong&gt;function&lt;/strong&gt;内の&lt;strong&gt;this&lt;/strong&gt;と&lt;strong&gt;GameScene&lt;/strong&gt;内での&lt;strong&gt;this&lt;/strong&gt;は参照先が異なるため、そのままだとエラーになってしまいます。&lt;/li&gt;
&lt;li&gt;そこで、ループ処理に入る前に&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var self = this;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と書いて、&lt;strong&gt;self&lt;/strong&gt;が正しい参照(&lt;strong&gt;GameScene&lt;/strong&gt;)となるようにしています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;次の&lt;strong&gt;setPosition&lt;/strong&gt;で、ブロックの位置を決めています。&lt;/li&gt;
&lt;li&gt;オブジェクトの作成から配置まで、&lt;strong&gt;jquery&lt;/strong&gt;のチェインメソッドのように繋げています。&lt;strong&gt;phina.js&lt;/strong&gt;では、大半がチェインメソッドに対応していますので、スッキリ書けて便利です。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;gridX.span(spanX)&lt;/strong&gt;は、横方向の&lt;strong&gt;Grid&lt;/strong&gt;で&lt;strong&gt;spanX&lt;/strong&gt;グリッド目の位置を表します。&lt;strong&gt;gridY.span(spanY)&lt;/strong&gt;は縦方向です。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Grid&lt;/strong&gt;を活用して縦と横方向にループ処理することで、このようにブロックをタイル状に配置することができます。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;gridについて&#34;&gt;Gridについて&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;phina.js&lt;/strong&gt;では、&lt;strong&gt;Scene&lt;/strong&gt;にデフォルトで&lt;strong&gt;Grid&lt;/strong&gt;というものが設定されています。
&lt;strong&gt;Grid&lt;/strong&gt;は、&lt;strong&gt;Scene&lt;/strong&gt;(スクリーン)を格子状に分けた情報を持っており、横方向、縦方向にそれぞれ16分割されています。
横方向のグリッドは&lt;strong&gt;this.gridX&lt;/strong&gt;、縦方向は&lt;strong&gt;this.gridY&lt;/strong&gt;でアクセスできます。
オブジェクトの配置の際に&lt;strong&gt;Grid&lt;/strong&gt;はとても便利な機能ですので、別の機会に掘り下げて説明したいと思います。&lt;/p&gt;

&lt;h2 id=&#34;今回はここまで&#34;&gt;今回はここまで&lt;/h2&gt;

&lt;p&gt;説明が長くなってしまいましたが、ここまでで、ブロックを配置することができました。しかし、ゲームとしての動きが何もないため面白くないですね。
次回は、プレイヤーが操作するパドルを作成して、徐々にゲームらしくしていきたいと思います。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;2015/10/30 修正&lt;/em&gt;
&lt;em&gt;本文中でブロックとBrickが混在していたため、BrickクラスからBlockクラスに変更しました。&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【phina.js】ゲーム作成チュートリアル（ブロック崩し）第1回＝テンプレートから作成する＝</title>
      <link>https://alkn203.github.io/blog/2015/10/26/beakout-tut-01</link>
      <pubDate>Mon, 26 Oct 2015 20:50:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2015/10/26/beakout-tut-01</guid>
      <description>

&lt;h2 id=&#34;はじめに&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;前回では、&lt;a href=&#34;https://github.com/phi-jp/phina.js&#34;&gt;phina.js&lt;/a&gt;についての簡単な説明と、作成するゲームの仕上がりをお見せしました。それでは、今回からステップ毎に説明を始めていきたいと思います。&lt;/p&gt;

&lt;h2 id=&#34;phina-jsのテンプレート&#34;&gt;phina.jsのテンプレート&lt;/h2&gt;

&lt;p&gt;Runstantで用意した&lt;a href=&#34;http://runstant.com/alkn203/projects/8f0388a4&#34;&gt;テンプレート&lt;/a&gt;を使います。後々の利便性を考え、リンクをブラウザの新しいタブで開いた方が良いでしょう。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://alkn203.github.io/blog/images/phina-template.png&#34; alt=&#34;phina-template&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// グローバルに展開
phina.globalize();
/*
 * メインシーン
 */
phina.define(&amp;quot;MainScene&amp;quot;, {
  // 継承
  superClass: &#39;DisplayScene&#39;,
  // 初期化
  init: function() {
    // 親クラス初期化
    this.superInit();
    // 背景色
    this.backgroundColor = &#39;black&#39;;
    // 以下にコードを書いていく
  },
});
/*
 * メイン処理
 */
phina.main(function() {
  // アプリケーションを生成
  var app = GameApp({
    // MainScene から開始
    startLabel: &#39;main&#39;,
  });
  // fps表示
  //app.enableStats();
  // 実行
  app.run();
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;コード説明&#34;&gt;コード説明&lt;/h2&gt;

&lt;h3 id=&#34;グローバル展開&#34;&gt;グローバル展開&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;phina.globalize();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;phina.game.GameApp&lt;/strong&gt;のように階層的に定義されているクラスを&lt;strong&gt;GameApp&lt;/strong&gt;だけで呼び出せるようにする処理などをしています。とりあえずは、必要なおまじないと覚えておいてください。&lt;/p&gt;

&lt;h3 id=&#34;メインシーン&#34;&gt;メインシーン&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;phina.define(&amp;quot;MainScene&amp;quot;, {
  // 継承
  superClass: &#39;DisplayScene&#39;,
  // 初期化
  init: function() {
    // 親クラス初期化
    this.superInit();
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;phina.define&lt;/strong&gt;は、クラスを定義する関数です。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DisplayScene&lt;/strong&gt;を継承した&lt;strong&gt;MainScene&lt;/strong&gt;を定義しています。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;init&lt;/strong&gt;関数は、いわゆる&lt;strong&gt;コンストラクタ&lt;/strong&gt;です。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;this.superInit&lt;/strong&gt;で親クラスの&lt;strong&gt;コンストラクタ&lt;/strong&gt;を呼び出しています。この後に、実際のゲーム処理コードを書いていくことになります。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;メイン処理&#34;&gt;メイン処理&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;phina.main(function() {
  // アプリケーションを生成
  var app = GameApp({
    // MainScene から開始
    startLabel: &#39;main&#39;,
  });
  // fps表示
  //app.enableStats();
  // 実行
  app.run();
});
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;phina.main&lt;/strong&gt;は、メイン関数です。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GameApp&lt;/strong&gt;のコンストラクタに、&lt;strong&gt;連想配列形式&lt;/strong&gt;でパラメータを与えます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;startLabel&lt;/strong&gt;で最初に読み込む&lt;strong&gt;Scene&lt;/strong&gt;を指定します。今回は&lt;strong&gt;main&lt;/strong&gt;が指定されているので、&lt;strong&gt;MainScene&lt;/strong&gt;が最初に表示されます。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;テンプレートの修正&#34;&gt;テンプレートの修正&lt;/h2&gt;

&lt;p&gt;今回作成するゲーム用に、テンプレートを修正します。&lt;/p&gt;

&lt;h2 id=&#34;コード説明-追加-修正部分&#34;&gt;コード説明（追加・修正部分）&lt;/h2&gt;

&lt;h3 id=&#34;gameapp関数&#34;&gt;GameApp関数&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  var app = GameApp({
    title: &#39;Break Out&#39;,
  });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/5c10f897&#34; target=&#34;_blank&#34;&gt;[runstantで確認]&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;title&lt;/strong&gt;で&lt;strong&gt;TitleScene&lt;/strong&gt;に表示されるタイトル名を設定します。&lt;/li&gt;
&lt;li&gt;今回は&lt;strong&gt;Break Out&lt;/strong&gt;というタイトルにしました。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;今回はここまで&#34;&gt;今回はここまで&lt;/h2&gt;

&lt;p&gt;以上で、ゲームを作成していくための下準備は整いました。
次回から、具体的なゲーム処理を書いていきたいと思います。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>【phina.js】ゲーム作成チュートリアル（ブロック崩し）第0回</title>
      <link>https://alkn203.github.io/blog/2015/10/22/beakout-tut-00</link>
      <pubDate>Thu, 22 Oct 2015 20:50:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2015/10/22/beakout-tut-00</guid>
      <description>

&lt;h3 id=&#34;はじめに&#34;&gt;はじめに&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/phi-jp/phina.js&#34;&gt;phina.js&lt;/a&gt;は、javascriptのゲームライブラリである&lt;a href=&#34;https://github.com/phi-jp/tmlib.js&#34;&gt;tmlib.js&lt;/a&gt;の後継という位置づけで、&lt;a href=&#34;https://gitter.im/phi-jp/phina.js&#34;&gt;gitter&lt;/a&gt;などを活用しながらオープンソースで開発が進められています。正式リリース前ではありますが、既にゲームを作成できる機能が十分に備わっています。
そこで、できるだけ多くの方々に知ってもらいたいという思いで、勝手ながらではありますが、今回から&lt;strong&gt;phina.js&lt;/strong&gt;を使った簡単なゲーム作成を通して、その機能や魅力などを紹介していきたいと思います。
なお、開発中ということもありますので、今後仕様変更などがあり得ることを申し添えます。&lt;/p&gt;

&lt;h3 id=&#34;tmlib-jsとの違いは&#34;&gt;tmlib.jsとの違いは？&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;phina.js&lt;/strong&gt;は、基本的に&lt;strong&gt;tmlib.js&lt;/strong&gt;をベースにリファクタリングして作られているので、基本機能という点では、大きな違いはないと言えるかと思います。その代わり、&lt;strong&gt;phina.js&lt;/strong&gt;では、新たに&lt;strong&gt;マルチタッチ対応、box2d対応、処理の高速化&lt;/strong&gt;などが図られています。
従って、&lt;strong&gt;tmlib.js&lt;/strong&gt;を触り始めたばかりの方、これから始めようと考えている方には、個人的には最初から&lt;strong&gt;phina.js&lt;/strong&gt;を使用することをお薦めします。&lt;/p&gt;

&lt;h3 id=&#34;準備&#34;&gt;準備&lt;/h3&gt;

&lt;p&gt;今回は、Webブラウザ上で簡単にコーディングができる&lt;a href=&#34;http://runstant.com/&#34;&gt;Runstant&lt;/a&gt;をエディタとして使用したいと思います。
&lt;strong&gt;Runstant&lt;/strong&gt;を使うと、気軽にコーディングできて、即座に動作確認ができます。思い立ったアイディアなどをすぐに形にできる非常に便利なツールです。&lt;/p&gt;

&lt;h3 id=&#34;作成するゲーム&#34;&gt;作成するゲーム&lt;/h3&gt;

&lt;p&gt;今回作成するのは、馴染みの深いオーソドックスな&lt;strong&gt;ブロック崩しゲーム&lt;/strong&gt;です。
仕上がりの目標は、以下のとおりです。（画面タッチ移動でパドルを操作　離すとボール発射）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://alkn203.github.io/blog/images/breakout.png&#34; alt=&#34;breakout&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/d64c3db0&#34; target=&#34;_blank&#34;&gt;[runstantで確認]&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;作成にあたって、言語こそ違いますが&lt;a href=&#34;http://aidiary.hatenablog.com/entry/20080507/1269694935&#34;&gt;Pythonでゲーム作りますが何か？ - 人工知能に関する断創録&lt;/a&gt;を参考にさせて頂きました。&lt;/p&gt;

&lt;h3 id=&#34;今回はここまで&#34;&gt;今回はここまで&lt;/h3&gt;

&lt;p&gt;前置きが長くなってしまいましたが、次回から&lt;strong&gt;phina.js&lt;/strong&gt;を使った具体的なゲーム作成について、作成のステップ毎に説明していきたいと思います。ここまで読んで頂きありがとうございました。&lt;/p&gt;

&lt;h3 id=&#34;リファレンス&#34;&gt;リファレンス&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://aidiary.hatenablog.com/entry/20080507/1269694935&#34;&gt;Pythonでゲーム作りますが何か？ - 人工知能に関する断創録&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>