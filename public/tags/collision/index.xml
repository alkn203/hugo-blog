<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>collision on Keep On Coding</title>
    <link>https://alkn203.github.io/blog/tags/collision/</link>
    <description>Recent content in collision on Keep On Coding</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Sun, 01 Sep 2019 20:55:06 +0900</lastBuildDate>
    
	<atom:link href="https://alkn203.github.io/blog/tags/collision/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>【phina.js】反射ベクトルを使った反射処理</title>
      <link>https://alkn203.github.io/blog/2019/09/01/phina-reflect/</link>
      <pubDate>Sun, 01 Sep 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2019/09/01/phina-reflect/</guid>
      <description>はじめに 反射処理の代表的なものといえば、ブロック崩しですが、ブロック崩しの場合、縦方向あるいは横方向の速度の向きを反転させるだけなので、比較的簡単です。
しかし、角度がついた壁に対して正確に反射させるにはそう単純にはいきません。この場合は、反射ベクトルというテクニックを使う必要があります。
実行サンプル(runstant)
Vecter2クラスのreflectメソッド  phina.jsのVector2クラスには、反射ベクトルを求めるreflectというメソッドが用意されています。 reflectメソッドは、入射ベクトルと壁の向きの法線ベクトルから反射ベクトルを求めて返します。  // 線分の法線ベクトル（正規化） var n = Vector2.normal(p1, p2).normalize(); // 反射ベクトル適用 var r = Vector2.reflect(this.circle.physical.velocity, n); サンプルコード phina.globalize(); // メインシーン phina.define(&amp;#39;MainScene&amp;#39;, { superClass: &amp;#39;DisplayScene&amp;#39;, // コンストラクタ  init: function() { // 親クラス初期化  this.superInit(); // 背景色  this.backgroundColor = &amp;#39;#444&amp;#39;; // canvas要素描画用  var elem = PlainElement({ width: this.gridX.width, height: this.gridY.width, }).addChildTo(this).setPosition(this.gridX.center(), this.gridY.center()); // canvasパラメータ指定  elem.canvas.context.strokeStyle = &amp;#39;white&amp;#39;; elem.canvas.context.lineWidth = 4; // 線分配列  this.</description>
    </item>
    
    <item>
      <title>【phina.js】当たり判定について考える</title>
      <link>https://alkn203.github.io/blog/2019/08/17/phina-collision/</link>
      <pubDate>Sat, 17 Aug 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2019/08/17/phina-collision/</guid>
      <description>はじめに ゲーム作りにおいて、当たり判定ほど奥深く悩まされるものはないと言ってよいでしょう。
今回は、phina.jsにおける当たり判定のアプローチについての自分なりの考察です。
hitTestElementを使う  phina.app.Object2dを継承したクラスであれば、hitTestElementを使えば手軽に当たり判定ができます。 矩形同士での判定になりますので、一番手軽です。一方で、グラフィックが矩形より小さいと大雑把な判定になってしまうという欠点があります。   参考記事
[phina.js-Tips-41] 当たり判定を行う（矩形判定）
 Collisionを自前で用意する  【phina.js】2Dシューティングチュートリアル =第6回 当たり判定とアニメーションイベントとグループ=で自前で作ったようなCollisionクラスを使う方法です。 任意の位置やサイズに設定することができるので柔軟性があります。一方で、絶対座標と相対座標の関係に気を付けないと、正しい当たり判定ができないという欠点があります。   参考記事
[phina.js]Colliderアクセサリを作ってみた話
 当たり判定用のShapeを親にしてスプライトなどを子として追加する  RectangleShapeやCircleShapeを当たり判定の対象として、スプライトをその子要素として追加する方法です。 絶対座標で当たり判定ができるというメリットがあります。 Shapeをhideメソッドで隠すと子要素まで隠れてしまいますので、Shapeのコンストラクタでfillとstrokeを透明にすると見えないようにすることができます。  サンプルコード 当たり判定を行う（当たり判定用矩形にスプライト追加）(runstant)
// グローバルに展開 phina.globalize(); // アセット var ASSETS = { // 画像  image: { &amp;#39;tomapiko&amp;#39;: &amp;#39;https://cdn.jsdelivr.net/gh/phinajs/phina.js@develop/assets/images/tomapiko.png&amp;#39;, }, }; /* * メインシーン */ phina.define(&amp;#34;MainScene&amp;#34;, { // 継承  superClass: &amp;#39;DisplayScene&amp;#39;, // コンストラクタ  init: function() { // 親クラス初期化  this.</description>
    </item>
    
    <item>
      <title>【phina.js】上方向だけすり抜ける床を作る</title>
      <link>https://alkn203.github.io/blog/2019/06/13/phina-up-direction/</link>
      <pubDate>Thu, 13 Jun 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2019/06/13/phina-up-direction/</guid>
      <description>上方向だけすり抜ける床  ジャンプゲームなどでは、上方向にすり抜け下方向にはすり抜けない床がよくあります。 今回は基本的なジャンプ処理とともに、phina.jsを使って自分なりに実装してみました。  動作サンプル まずは以下のサンプルを確認して下さい。 画面タッチでキャラがジャンプしますが、上方向にはブロックをすり抜けて、その後に下のブロックに着地します。
runstantで確認
プレイヤーとブロックの作成 プレイヤーとブロックは、それぞれSpriteクラスを継承して作成しました。
// プレイヤークラスphina.define(&amp;#39;Player&amp;#39;, {superClass: &amp;#39;Sprite&amp;#39;,// コンストラクタ init: function() {// 親クラス初期化 this.superInit(&amp;#39;tomapiko&amp;#39;, SPRITE_SIZE, SPRITE_SIZE);// フレームアニメーションをアタッチ this.anim = FrameAnimation(&amp;#39;tomapiko_ss&amp;#39;).attachTo(this);// スプライトシートのサイズにフィットさせない this.anim.fit = false;// 縦移動速度 this.vy = 0;// サイズ変更 this.setSize(CHARA_SIZE, CHARA_SIZE);},  デフォルトのスプライトサイズから半分のサイズにしています。 FrameAnimationクラスのプロパティfitをfalseにしないと、スプライトシートに書いている切り出しサイズが適用されるので注意して下さい。  // ブロッククラスphina.define(&amp;#39;Block&amp;#39;, {superClass: &amp;#39;Sprite&amp;#39;,// コンストラクタ init: function() {// 親クラス初期化 this.</description>
    </item>
    
  </channel>
</rss>