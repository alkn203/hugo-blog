<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Canvas on Keep Coding</title>
    <link>https://alkn203.github.io/blog/tags/canvas/</link>
    <description>Recent content in Canvas on Keep Coding</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Fri, 16 Dec 2016 00:01:08 +0900</lastBuildDate>
    <atom:link href="https://alkn203.github.io/blog/tags/canvas/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Collisionクラスを使った当たり判定</title>
      <link>https://alkn203.github.io/blog/2016/12/16/phina-advent-16th</link>
      <pubDate>Fri, 16 Dec 2016 00:01:08 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2016/12/16/phina-advent-16th</guid>
      <description>

&lt;h2 id=&#34;はじめに&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;この記事は、&lt;a href=&#34;http://qiita.com/advent-calendar/2016/phinajs&#34;&gt;phina.js Advent Calendar 2016&lt;/a&gt; の16日目の記事です。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;15日目：&lt;a href=&#34;http://qiita.com/minimo/items/8aca8ee80196ad045b87&#34;&gt;phina.jsとFirebaseで簡単にオンラインゲームを作ってみる by minimoさん&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;17日目：&lt;a href=&#34;http://qiita.com/minimo/items/b55b792c2fa19964acb4&#34;&gt;phina.jsでTiledMapEditorを利用するy minimoさん&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;collisionクラスについて&#34;&gt;Collisionクラスについて&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;phina.geom.Collision&lt;/strong&gt;は、当たり判定を行うためのクラスです。
&lt;strong&gt;phina.js&lt;/strong&gt;の当たり判定で良く使うのは、&lt;strong&gt;phina.app.Object2d&lt;/strong&gt;クラスの&lt;strong&gt;hitTest&lt;/strong&gt;メソッドかと思いますが、このメソッドを使うためには以下のようにインスタンス経由となります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;obj.hitTest(target);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;対して、&lt;strong&gt;Collision&lt;/strong&gt;クラスのメソッドは全て&lt;strong&gt;static&lt;/strong&gt;なメソッドとなっています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Collision.メソッド名(引数1, 引数2);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;collisionクラスのメソッド&#34;&gt;Collisionクラスのメソッド&lt;/h2&gt;

&lt;h3 id=&#34;testcirclecircle&#34;&gt;testCircleCircle&lt;/h3&gt;

&lt;p&gt;円同士が重なっているかを判定します。&lt;/p&gt;

&lt;h3 id=&#34;testrectrect&#34;&gt;testRectRect&lt;/h3&gt;

&lt;p&gt;矩形同士が重なっているかを判定します。&lt;/p&gt;

&lt;h3 id=&#34;testcirclerect&#34;&gt;testCircleRect&lt;/h3&gt;

&lt;p&gt;円と矩形が重なってるかを判定します。&lt;/p&gt;

&lt;h3 id=&#34;testcircleline&#34;&gt;testCircleLine&lt;/h3&gt;

&lt;p&gt;円と線分が重なってるかを判定します。&lt;/p&gt;

&lt;h2 id=&#34;サンプルコード&#34;&gt;サンプルコード&lt;/h2&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://alkn203.github.io/blog/images/phina-advent-16th.png&#34; alt=&#34;phina-advent-16th&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// グローバルに展開
phina.globalize();
/*
 * メインシーン
 */
phina.define(&amp;quot;MainScene&amp;quot;, {
  // 継承
  superClass: &#39;DisplayScene&#39;,
  // 初期化
  init: function() {
    // 親クラス初期化
    this.superInit();
    // 背景色
    this.backgroundColor = &#39;black&#39;;
    // ラベル1
    this.label1 = Label({
      text: &#39;図形をドラッグして重ねよう&#39;,
      fill: &#39;white&#39;,
      fontSize: 48,
    }).addChildTo(this).setPosition(this.gridX.center(), this.gridY.center(-6));
    // ラベル2
    this.label2 = Label({
      fill: &#39;white&#39;,
      fontSize: 48,
    }).addChildTo(this).setPosition(this.gridX.center(), this.gridY.center(6));
    // 円1
    var circle1 = CircleShape({
      fill: null,
    }).addChildTo(this).setPosition(this.gridX.center(), this.gridY.center(-2));
    // ドラッグ可能にする
    Draggable().attachTo(circle1);
    // 円2
    var circle2 = CircleShape({
      fill: null,
    }).addChildTo(this).setPosition(this.gridX.center(), this.gridY.center(2));
    // ドラッグ可能にする
    Draggable().attachTo(circle2); 
    // 矩形1
    var rect1 = RectangleShape({
      fill: null,
    }).addChildTo(this).setPosition(this.gridX.center(-3), this.gridY.center());
    Draggable().attachTo(rect1);
    // 矩形2
    var rect2 = RectangleShape({
      fill: null,
    }).addChildTo(this).setPosition(this.gridX.center(3), this.gridY.center());
    Draggable().attachTo(rect2);
    // canvas要素描画用
    var elem  = PlainElement({
      width: this.gridX.width,
      height: this.gridY.width, 
    }).addChildTo(this).setPosition(this.gridX.center(), this.gridY.center());
    // canvasパラメータ指定
    elem.canvas.context.strokeStyle = &#39;white&#39;;
    elem.canvas.context.lineWidth = 4;
    // 線分の両端の座標
    this.points = [Vector2(this.gridX.center(-3), this.gridY.center(-3)),
                   Vector2(this.gridX.center(3), this.gridY.center(3))];
    
    var p1 = this.points[0];
    var p2 = this.points[1];
    // 線を引く
    elem.canvas.drawLine(p1.x, p1.y, p2.x, p2.y);
    // 参照用
    this.circle1 = circle1;
    this.circle2 = circle2;
    this.rect1 = rect1;
    this.rect2 = rect2;
  },

  update: function() {
    var c1 = this.circle1;
    var c2 = this.circle2;
    var r1 = this.rect1;
    var r2 = this.rect2;
    // 円同士の当たり判定
    if (Collision.testCircleCircle(c1, c2)) {
      this.label2.text = &#39;Circle And Circle&#39;;
      return;
    }
    // 矩形同士の当たり判定
    if (Collision.testRectRect(r1, r2)) {
      this.label2.text = &#39;Rect And Rect&#39;;
      return;  
    }
    // 円と矩形の当たり判定
    if (Collision.testCircleRect(c1, r1) || Collision.testCircleRect(c1, r2) ||
        Collision.testCircleRect(c2, r1) || Collision.testCircleRect(c2, r2)) {
          this.label2.text = &#39;Circle And Rect&#39;;
          return;  
    }

    var p1 = this.points[0];
    var p2 = this.points[1];
    var bc1 = Circle(c1.x, c1.y, c1.radius);
    var bc2 = Circle(c2.x, c2.y, c2.radius);
    // 円と線分の当たり判定
    if (Collision.testCircleLine(bc1, p1, p2) ||
        Collision.testCircleLine(bc2, p1, p2)) {
          this.label2.text = &#39;Circle And Line&#39;;
          return;  
    }
    
    this.label2.text = &#39;&#39;;
  },
});
/*
 * メイン処理
 */
phina.main(function() {
  // アプリケーションを生成
  var app = GameApp({
    // MainScene から開始
    startLabel: &#39;main&#39;,
  });
  // 実行
  app.run();
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/9872a6f6&#34; target=&#34;_blank&#34;&gt;[runstantで確認]&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;おわりに&#34;&gt;おわりに&lt;/h2&gt;

&lt;p&gt;現在の&lt;strong&gt;Collision&lt;/strong&gt;クラスで大体の当たり判定の処理はできるかと思いますが、&lt;strong&gt;線分と線分&lt;/strong&gt;、&lt;strong&gt;矩形と線分&lt;/strong&gt;、&lt;strong&gt;多角形と多角形&lt;/strong&gt;といった当たり判定を追加しても良いかもしれません。ライブラリ開発に少しでもコントリビュートしていけるのが&lt;strong&gt;phina.js&lt;/strong&gt;の醍醐味でもあります。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PlainElementでCanvas描画</title>
      <link>https://alkn203.github.io/blog/2016/12/05/phina-advent-5th</link>
      <pubDate>Mon, 05 Dec 2016 00:01:08 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2016/12/05/phina-advent-5th</guid>
      <description>

&lt;h2 id=&#34;はじめに&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;この記事は、&lt;a href=&#34;http://qiita.com/tamochu3141/items/8094aec3348dc9a6ae9d&#34;&gt;phina.js Advent Calendar 2016&lt;/a&gt; の5日目の記事です。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;4日目：&lt;a href=&#34;http://qiita.com/tamochu3141/items/8094aec3348dc9a6ae9d&#34;&gt;phina.jsでの多人数参加型ゲームの作製 by tamochu3141さん&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;6日目：&lt;a href=&#34;http://qiita.com/simiraaaa/items/ba1f1648a6d0451b5abc&#34;&gt;Shapeを画像として使う by simiraaaaさん&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;phina-jsの描画機能&#34;&gt;phina.jsの描画機能&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;phina.js&lt;/strong&gt;の描画機能は、&lt;strong&gt;HTML5 Canvas&lt;/strong&gt;がベースになっています。&lt;strong&gt;Canvas&lt;/strong&gt;をある程度知っている人は、&lt;strong&gt;phina.js&lt;/strong&gt;を使ってみてピンと来るところがあると思います。加えて、&lt;strong&gt;phina.js&lt;/strong&gt;にはデフォルトの&lt;strong&gt;Canvas&lt;/strong&gt;の機能を拡張した&lt;a href=&#34;https://github.com/phi-jp/phina.js/blob/develop/src/graphics/canvas.js&#34;&gt;&lt;strong&gt;phina.graphics.Canvas&lt;/strong&gt;&lt;/a&gt;というクラスが用意されており、デフォルトのメソッドに加え、簡単に線を描画できる&lt;strong&gt;drawLine&lt;/strong&gt;など便利なメソッド群が追加で実装されています。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;phina.js&lt;/strong&gt;で&lt;strong&gt;Canvas&lt;/strong&gt;のメソッドを使用したい場合は、&lt;strong&gt;phina.graphics.Canvas&lt;/strong&gt;のインスタンスを作ってそこに描画する方法がありますが、多少手間がかかるところがありますので、今回は手軽に&lt;strong&gt;Canvas&lt;/strong&gt;の機能が使える&lt;strong&gt;PlainElement&lt;/strong&gt;というクラスを紹介したいと思います。&lt;/p&gt;

&lt;h2 id=&#34;plainelementクラス&#34;&gt;PlainElementクラス&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;phina.display.PlainElement&lt;/strong&gt;は、内部に&lt;strong&gt;Canvas&lt;/strong&gt;クラスを持っているだけのシンプルなクラスで、&lt;strong&gt;Shape&lt;/strong&gt;の親クラスとして位置付けられています。
内部に&lt;strong&gt;Canvas&lt;/strong&gt;を持っているので、&lt;strong&gt;Canvas&lt;/strong&gt;で使えるメソッドは一通り使うことができます。&lt;/p&gt;

&lt;h2 id=&#34;plainelementクラスの使用例-簡単なお絵描き風プログラム&#34;&gt;PlainElementクラスの使用例（簡単なお絵描き風プログラム）&lt;/h2&gt;

&lt;p&gt;お絵描きと呼べる程ではありませんが、今回は、マウスドラッグで線が引けるだけの簡単なサンプルを作ってみました。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://alkn203.github.io/blog/images/phina-advent-5th.png&#34; alt=&#34;phina-advent-5th&#34; /&gt;&lt;/p&gt;

&lt;p&gt;コードは以下のとおりです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;phina.globalize();
// メインシーン
phina.define(&#39;MainScene&#39;, {
  superClass: &#39;DisplayScene&#39;,
  // コンストラクタ
  init: function() {
    // 親クラス初期化
    this.superInit();
    // 背景色
    this.backgroundColor = &#39;black&#39;;
    // canvas要素描画用
    var elem  = PlainElement({
      width: this.gridX.width,
      height: this.gridY.width, 
    }).addChildTo(this).setPosition(this.gridX.center(), this.gridY.center());
    // canvasパラメータ指定
    elem.canvas.context.strokeStyle = &#39;white&#39;;
    elem.canvas.context.lineWidth = 4;
    // 参照用
    this.elem = elem;
  },
  // タッチ開始
  onpointstart: function(e) {
    // タッチされた位置を記憶
    this.prev = Vector2(e.pointer.x, e.pointer.y);
  },
  // タッチ移動中
  onpointmove: function(e) {
    // 現在のタッチ位置を記憶
    var current = Vector2(e.pointer.x, e.pointer.y);
    // 前の位置から現在の位置まで線を引く
    this.elem.canvas.drawLine(this.prev.x, this.prev.y, current.x, current.y);
    // 前の位置を現在の位置に更新
    this.prev = current;
  },
  // タッチ終了
  onpointend: function() {
    // 位置情報をクリア
    this.prev = null;  
  },
});
// メイン
phina.main(function() {
  var app = GameApp({
    startLabel: &#39;main&#39;,
  });
  app.run();
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/783bf264&#34; target=&#34;_blank&#34;&gt;[runstantで確認]&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;コード説明&#34;&gt;コード説明&lt;/h2&gt;

&lt;h3 id=&#34;plainelementの追加&#34;&gt;PlainElementの追加&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    // canvas要素描画用
    var elem  = PlainElement({
      width: this.gridX.width,
      height: this.gridY.width, 
    }).addChildTo(this).setPosition(this.gridX.center(), this.gridY.center());
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;PlainElement&lt;/strong&gt;を作成して、&lt;strong&gt;Scene&lt;/strong&gt;に追加しています。&lt;/li&gt;
&lt;li&gt;コンストラクでは、横と縦のサイズを指定します。今回は、画面と同じサイズにして重ねています。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;canvasのcontext指定&#34;&gt;canvasのcontext指定&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// canvasパラメータ指定
elem.canvas.context.strokeStyle = &#39;white&#39;;
elem.canvas.context.lineWidth = 4;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;PlainElement&lt;/strong&gt;内部の&lt;strong&gt;Canvas&lt;/strong&gt;には、&lt;strong&gt;canvas&lt;/strong&gt;プロパティでアクセスできます。&lt;/li&gt;
&lt;li&gt;ここでは&lt;strong&gt;canvas&lt;/strong&gt;の&lt;strong&gt;context&lt;/strong&gt;を経由して、線の色と幅を指定しています。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;タッチ開始時処理&#34;&gt;タッチ開始時処理&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// タッチ開始
onpointstart: function(e) {
  // タッチされた位置を記憶
  this.prev = Vector2(e.pointer.x, e.pointer.y);
},
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;イベントからマウスが押された位置を取得します。&lt;/li&gt;
&lt;li&gt;線の始点の座標を&lt;strong&gt;Vector2&lt;/strong&gt;クラスを使って記憶します。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;タッチ移動時処理&#34;&gt;タッチ移動時処理&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// タッチ移動中
onpointmove: function(e) {
  // 現在のタッチ位置を記憶
  var current = Vector2(e.pointer.x, e.pointer.y);
  // 前の位置から現在の位置まで線を引く
  this.elem.canvas.drawLine(this.prev.x, this.prev.y, current.x, current.y);
  // 前の位置を更新
  this.prev = current;
},
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;現在のタッチ位置を線の終点として記憶します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;canvas&lt;/strong&gt;の&lt;strong&gt;drawLine&lt;/strong&gt;メソッドで線を引きます。&lt;/li&gt;
&lt;li&gt;最後の前の位置を現在の位置に更新します。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;タッチ終了時処理&#34;&gt;タッチ終了時処理&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// タッチ終了
onpointend: function() {
  // 位置情報をクリア
  this.prev = null;  
},
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;線を引き終わった後は、始点の位置情報をクリアします。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;補足&#34;&gt;補足&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;phinajs&lt;/strong&gt;には他に&lt;strong&gt;PathShape&lt;/strong&gt;というクラスがあります。線の描画に特化したクラスで、座標値データ群を与えるだけでその点を結んだ線を自動で描画してくれる優れものです。こちらはまた別の機会に紹介したいと思います。&lt;/p&gt;

&lt;h2 id=&#34;おわりに&#34;&gt;おわりに&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;phina.js&lt;/strong&gt;でゲームを作るときは&lt;strong&gt;Sprite&lt;/strong&gt;画像を使うことが多いかもしれませんが、上で説明した&lt;strong&gt;PlainElement&lt;/strong&gt;、つまり、&lt;strong&gt;Canvas&lt;/strong&gt;の機能を併用することで、よりゲームの表現性が増すのではないでしょうか。可能であれば、今回のアドベントカレンダーの期間内で簡単なサンプルゲームを作ってみたいと思います。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ShapeとCanvas描画を組み合わせたサンプル（時計Shape）</title>
      <link>https://alkn203.github.io/blog/2016/02/16/phina-canvas2</link>
      <pubDate>Tue, 16 Feb 2016 23:59:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2016/02/16/phina-canvas2</guid>
      <description>

&lt;h3 id=&#34;今回の内容&#34;&gt;今回の内容&lt;/h3&gt;

&lt;p&gt;以前に&lt;strong&gt;tmlib.js&lt;/strong&gt;で作った物を&lt;strong&gt;phina.js&lt;/strong&gt;にリファクタリングしてみました。
&lt;strong&gt;Shape&lt;/strong&gt;を通常の&lt;strong&gt;canvas&lt;/strong&gt;と見なせますので、今回の時計に限らず、&lt;strong&gt;canvas&lt;/strong&gt;で描けるものは全て&lt;strong&gt;Shape&lt;/strong&gt;として取り扱うことができます。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://alkn203.github.io/blog/images/phina-canvas2.png&#34; alt=&#34;phina-canvas2&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;h3 id=&#34;コード&#34;&gt;コード&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// グローバルに展開
phina.globalize();
// 定数
var SCREEN_WIDTH = 640;
var SCREEN_HEIGHT = 960;
var CENTER_X = SCREEN_WIDTH / 2;
var CENTER_Y = SCREEN_HEIGHT / 2;
/*
 * メインシーン
 */
phina.define(&amp;quot;MainScene&amp;quot;, {
  // 継承
  superClass: &#39;DisplayScene&#39;,
  // 初期化
  init: function() {
    // 親クラス初期化
    this.superInit();
    // 背景色
    this.backgroundColor = &#39;black&#39;;
    // 時計Shapeを作成
    this.clock = ClockShape({
      width: 320, // 幅
      height: 320, // 高さ
      fill: &amp;quot;silver&amp;quot;,
      stroke: &amp;quot;gray&amp;quot;,
    }).addChildTo(this).setPosition(320, 480);
    
    this.clock.physical.gravity.y = 0.5;
  },
  // 毎フレーム更新
  update: function() {
    // canvasを再描画するようにフラグを立てる
    this.clock._dirtyDraw = true;
    
    if (this.clock.bottom &amp;gt; 960) {
      this.clock.physical.force(0, -10);
    }
  },
});
/*
 * 時計Shapeクラス
 */ 
phina.define(&#39;ClockShape&#39;, {
  // Shapeクラスを継承
  superClass: &#39;Shape&#39;,
  // コンストラクタ
  init: function(options) {
    this.superInit(options);
    this.backgroundColor = &#39;transparent&#39;;
  },
  // 自身のcanvasの描画内容
  prerender: function(canvas) {
    // 描画領域クリア
    canvas.clear();
    // スタイル指定
    canvas.fillStyle = this.fill;
    canvas.strokeStyle = this.stroke;
    // 半径
    var radius = this.radius;
    // canvasの中心
    var cx = 0;
    var cy = 0;
    var baseW = radius / 50;
    // 時計盤描画
    canvas.fillCircle(cx, cy, radius);
    canvas.lineWidth = baseW;
    canvas.strokeCircle(cx, cy, radius - 2);
    canvas.lineWidth = baseW * 2;
    canvas.strokeCircle(cx, cy, radius * 9.0 / 10);
    // 目盛終点
    var tr = radius * 8.3 / 10;
    // 角度
    var deg = 0;
    canvas.lineWidth = baseW;
    // 繰り返し
    (60).times(function(i) {
      // 目盛始点（5分毎の目盛か判定）
      var fr = deg % 30 === 0 ? radius * 7.5 / 10 : radius * 8.0 / 10; 
      // 目盛描画
      var rad = Math.degToRad(deg);
      var fromX = cx + fr * Math.cos(rad);
      var fromY = cx + fr * Math.sin(rad);
      var toX = cx + tr * Math.cos(rad);
      var toY = cx + tr * Math.sin(rad);
      canvas.drawLine(fromX, fromY, toX, toY);
      // 角度を進める
      deg += 6;
    });
    // 現在の時刻
    var d = new Date();
    // 時は12時間表記へ
    var hour = d.getHours() - 12;
    var minute = d.getMinutes();
    var second = d.getSeconds();
    // 短針の長さ
    var hr = radius * 6.0 / 10;
    // 長針、秒針の長さ
    var sr = radius * 7.7 / 10;
    // 角度補正値
    var adj = 90;
    // 短針描画
    this.drawRadialLine(cx, cy, hr, hour * 30 + minute / 2 - adj);
    // 長針描画
    this.drawRadialLine(cx, cy, sr, minute * 6 - adj);
    // 秒針描画
    canvas.lineWidth = baseW / 2;
    this.drawRadialLine(cx, cy, sr, second * 6 - adj);
    this.drawRadialLine(cx, cy, -radius * 2.0 / 10, second * 6 - adj);
    // 中央円
    canvas.save();
    canvas.fillStyle = canvas.strokeStyle;
    canvas.fillCircle(cx, cy, radius * 0.4 / 10);
    canvas.restore();
  },
  // 中心から放射状に線を描画
  drawRadialLine: function(cx, cy, radius, deg) {
    var rad = Math.degToRad(deg);
    // 円周上の点計算
    var toX = cx + radius * Math.cos(rad);
    var toY = cy + radius * Math.sin(rad);
    // 線描画
    this.canvas.drawLine(cx, cy, toX, toY);
  },
});
/*
 * メイン処理
 */
phina.main(function() {
  // アプリケーションを生成
  var app = GameApp({
    // MainScene から開始
    startLabel: &#39;main&#39;,
  });
  // fps表示
  //app.enableStats();
  // 実行
  app.run();
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/7610ec35&#34; target=&#34;_blank&#34;&gt;[runstantで確認]&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>