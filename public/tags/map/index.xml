<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>map on Keep On Coding</title>
    <link>https://alkn203.github.io/blog/tags/map/</link>
    <description>Recent content in map on Keep On Coding</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Fri, 03 Jan 2020 20:55:06 +0900</lastBuildDate>
    
	<atom:link href="https://alkn203.github.io/blog/tags/map/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>【phina.js】Mapクラスを作ってみた</title>
      <link>https://alkn203.github.io/blog/2020/01/03/phina-map-class/</link>
      <pubDate>Fri, 03 Jan 2020 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2020/01/03/phina-map-class/</guid>
      <description>はじめに RPGなどで固定マップで単純な当たり判定を行いたい時は、Mapデータと当たり判定データを読み込んで行う方法が便利です。 今回は、enchant.jsにあったMapクラスを参考にphina.js版を作ってみました。
コンストラクタ var map = phina.util.Map({ tileWidth: 64, tileHeight: 64, imageName: &amp;#39;tile&amp;#39;, mapData: data, collisionData: collision, }).addChildTo(this); プロパティ    プロパティ 説明     tileWidth タイルの幅   tileHeight タイルの高さ   imageName タイルセット画像の名前   mapData マップデータの2次元配列   collisionData タイル衝突判定用の2次元配列    メンバ関数    関数 説明     hitTest マップとの衝突判定を行う(座標から)   hitTestByIndex マップとの衝突判定を行う(インデックスから)   checkTile タイルが何か調べる(座標から)   checkTileByIndex タイルが何か調べる(インデックスから)   setTile タイルを更新する   getChild 子要素を得る（座標から）   getChildByIndex 子要素を得る（インデックスから）    おわりに 本格的なマップ作成には、タイルマップエディタが必要になってくると思いますが、簡単なゲームであれば、この程度の機能でも使えるのではないでしょうか。</description>
    </item>
    
    <item>
      <title>【phina.js】マップデータの読み込みにおける工夫</title>
      <link>https://alkn203.github.io/blog/2019/08/23/phina-mapdata/</link>
      <pubDate>Fri, 23 Aug 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2019/08/23/phina-mapdata/</guid>
      <description>はじめに ゲーム作りにおいてステージを作成する時、オブジェクトが少ない場合は１つ１つ位置を指定して追加していくこともできるでしょう。 でも、最終的には2次元配列でマップデータを作成して、プログラム内から読み込む方法などに落ち着くかと思います。
サンプルコード(runstant)
2次元配列のマップデータ 通常は、以下のようなデータを作成します。
// ステージデータ var STAGE = [&amp;#39;4&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;], [&amp;#39;4&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;], [&amp;#39;4&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;], [&amp;#39;4&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;], [&amp;#39;4&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;]];  配列ですので、それぞれの要素をシングルクオーテーションで囲む必要があり、データの修正などが結構面倒です。  マップデータを簡素化する  少し簡略化した以下の形式で読め込めるようにします。 1次元の配列になっており、コピーアンドペーストも楽です。  // ステージデータ var STAGE = [&amp;#39;4000000000&amp;#39;, &amp;#39;4000000000&amp;#39;, &amp;#39;4000000000&amp;#39;, &amp;#39;4000000000&amp;#39;, &amp;#39;4000000000&amp;#39;]; マップデータ読み込み処理  マップデータを読み込んでオブジェクトを配置する処理は、以下のとおりです。  // マップ作成 setStage: function(stage) { var half = GRID_SIZE / 2; var self = this; // マップデータをループ  stage.each(function(arr, j) { // 文字列を配列に変換  arr.toArray().each(function(id, i) { var x = self.gx.span(i) + half; var y = self.</description>
    </item>
    
  </channel>
</rss>