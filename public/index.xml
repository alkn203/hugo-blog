<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Keep Coding</title>
    <link>https://alkn203.github.io/blog/</link>
    <description>Recent content on Keep Coding</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Sun, 09 Oct 2016 00:01:08 +0900</lastBuildDate>
    <atom:link href="https://alkn203.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>004-Shapeの背景色指定</title>
      <link>https://alkn203.github.io/blog/2016/10/09/phina-bg-shape</link>
      <pubDate>Sun, 09 Oct 2016 00:01:08 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2016/10/09/phina-bg-shape</guid>
      <description>

&lt;h2 id=&#34;内容&#34;&gt;内容&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Shape&lt;/strong&gt;の背景色の指定方法について説明します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://alkn203.github.io/blog/images/phina-bg-shape.png&#34; alt=&#34;phina-bg-shape&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;背景色指定&#34;&gt;背景色指定&lt;/h2&gt;

&lt;p&gt;背景色は&lt;strong&gt;backgroundColor&lt;/strong&gt;プロパティで指定します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;shape.backgroundColor = &#39;red&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/57cab291&#34; target=&#34;_blank&#34;&gt;[runstantで確認]&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;他の指定方法&#34;&gt;他の指定方法&lt;/h2&gt;

&lt;h3 id=&#34;16進数&#34;&gt;16進数&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;css&lt;/strong&gt;と同様に指定できます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;shape.backgroundColor = &#39;#ffff00&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/6a5a9d1d&#34; target=&#34;_blank&#34;&gt;[runstantで確認]&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;rgb&#34;&gt;RGB&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Rgb&lt;/strong&gt;クラスを使って指定できます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;shape.backgroundColor = `rgb(0, 255, 255)`;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/cb651549&#34; target=&#34;_blank&#34;&gt;[runstantで確認]&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;hsl&#34;&gt;hsl&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;css&lt;/strong&gt;と同様に指定できます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;shape.backgroundColor = `hsl(300, 75%, 50%)`;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/accb7a5a&#34; target=&#34;_blank&#34;&gt;[runstantで確認]&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>003-Shapeの幅・高さ指定</title>
      <link>https://alkn203.github.io/blog/2016/10/06/phina-resize-shape</link>
      <pubDate>Thu, 06 Oct 2016 00:01:08 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2016/10/06/phina-resize-shape</guid>
      <description>

&lt;h2 id=&#34;内容&#34;&gt;内容&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Shape&lt;/strong&gt;の幅・高さの指定方法について説明します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://alkn203.github.io/blog/images/phina-resize-shape.png&#34; alt=&#34;phina-resize-shape&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;幅指定&#34;&gt;幅指定&lt;/h2&gt;

&lt;p&gt;幅は&lt;strong&gt;width&lt;/strong&gt;プロパティで指定します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;shape.width = 128;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/7fad0439&#34;&gt;[runstantで確認]&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;高さ指定&#34;&gt;高さ指定&lt;/h2&gt;

&lt;p&gt;高さは&lt;strong&gt;height&lt;/strong&gt;プロパティで指定します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;shape.height = 128;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/5da92e05&#34;&gt;[runstantで確認]&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;幅-高さを一括指定&#34;&gt;幅・高さを一括指定&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;setSize&lt;/strong&gt;を使えば、幅と高さを一括で指定できます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;shape.setSize(128, 256);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/8de8694c&#34;&gt;[runstantで確認]&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;コンストラクタ内で指定&#34;&gt;コンストラクタ内で指定&lt;/h2&gt;

&lt;p&gt;位置指定と同じくコンストラクタ内で幅・高さを指定することも可能です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    var shape = Shape({
      // 位置・幅・高さ指定
      x: 320,
      y: 480,
      width: 128,
      height: 256,
    }).addChildTo(this);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/1a3e59cf&#34;&gt;[runstantで確認]&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>002-Shapeの位置指定</title>
      <link>https://alkn203.github.io/blog/2016/10/03/phina-locate-shape</link>
      <pubDate>Mon, 03 Oct 2016 00:01:08 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2016/10/03/phina-locate-shape</guid>
      <description>

&lt;h2 id=&#34;内容&#34;&gt;内容&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Shape&lt;/strong&gt;の位置を以下のように指定します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://alkn203.github.io/blog/images/phina-locate-shape.png&#34; alt=&#34;phina_locate_shape_image&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;コード&#34;&gt;コード&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// グローバルに展開
phina.globalize();
/*
 * メインシーン
 */
phina.define(&amp;quot;MainScene&amp;quot;, {
  // 継承
  superClass: &#39;DisplayScene&#39;,
  // 初期化
  init: function() {
    // 親クラス初期化
    this.superInit();
    // 背景色
    this.backgroundColor = &#39;black&#39;;
    // Shapeを作成してシーンに追加
    var shape = Shape().addChildTo(this);
    // 移動
    shape.x = 320;
    shape.y = 480;
  },
});
/*
 * メイン処理
 */
phina.main(function() {
  // アプリケーションを生成
  var app = GameApp({
    // MainScene から開始
    startLabel: &#39;main&#39;,
  });
  // fps表示
  //app.enableStats();
  // 実行
  app.run();
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/4e8bc6e6&#34;&gt;[runstantで実行]&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;コード説明&#34;&gt;コード説明&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Shape&lt;/strong&gt;の位置変更は、&lt;strong&gt;x, y&lt;/strong&gt;プロパティに直接数値を指定することで可能です。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;他の位置指定方法&#34;&gt;他の位置指定方法&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;setPosition&lt;/strong&gt;関数を使えば、&lt;strong&gt;x, y&lt;/strong&gt;の値を一括で指定することができ、生成から一気にチェインメソッドで繋げて書くこともできるので便利です。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var shape = Shape().addChildTo(this).shape.setPosition(320, 480);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/4c21e518&#34;&gt;[runstantで実行]&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Shape&lt;/strong&gt;のコンストラクタにパラメータとして与えてることでも指定できます。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var shape = Shape({
  x: 320,
  y: 480
}).addChildTo(this)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/81ae38a5&#34;&gt;[runstantで実行]&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;moveBy&lt;/strong&gt;関数を使えば、&lt;strong&gt;x, y&lt;/strong&gt;の移動量で位置を変更することができます。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;shape.setPosition(320, 480).moveBy(100, 200);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/af6327d3&#34;&gt;[runstantで実行]&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;変則的ですが、&lt;strong&gt;Vector2&lt;/strong&gt;クラスを使ってベクトル値の加算で位置指定する方法もあります。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var v = Vector2(100, 200);
shape.position.add(v);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/6a11250f&#34;&gt;[runstantで実行]&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>001-Shapeを生成してSceneに追加する</title>
      <link>https://alkn203.github.io/blog/2016/10/01/phina-add-shape</link>
      <pubDate>Sat, 01 Oct 2016 00:01:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2016/10/01/phina-add-shape</guid>
      <description>

&lt;h2 id=&#34;内容&#34;&gt;内容&lt;/h2&gt;

&lt;p&gt;今回は基本的な内容ではありますが、オブジェクトの基本形である&lt;strong&gt;Shape&lt;/strong&gt;を以下のように画面に表示してみます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://alkn203.github.io/blog/images/phina-add-shape.png&#34; alt=&#34;phina_add_shape_image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/c5ac89af&#34;&gt;[runstantで実行]&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;

&lt;h2 id=&#34;コード&#34;&gt;コード&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// グローバルに展開
phina.globalize();
/*
 * メインシーン
 */
phina.define(&amp;quot;MainScene&amp;quot;, {
  // 継承
  superClass: &#39;DisplayScene&#39;,
  // 初期化
  init: function() {
    // 親クラス初期化
    this.superInit();
    // 背景色
    this.backgroundColor = &#39;black&#39;;
    // Shapeを作成してシーンに追加
    var shape = Shape();
    shape.addChildTo(this);
  },
});
/*
 * メイン処理
 */
phina.main(function() {
  // アプリケーションを生成
  var app = GameApp({
    // MainScene から開始
    startLabel: &#39;main&#39;,
  });
  // fps表示
  //app.enableStats();
  // 実行
  app.run();
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;コード説明&#34;&gt;コード説明&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Shape&lt;/strong&gt;クラスのコンストラクタで生成します。コンストラクタの前に&lt;strong&gt;new&lt;/strong&gt;をつける必要はありません。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;addChildTo(this)&lt;/strong&gt;で現在の&lt;strong&gt;Scene&lt;/strong&gt;に追加します。&lt;strong&gt;this&lt;/strong&gt;は&lt;strong&gt;MainScene&lt;/strong&gt;を指しています。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;this.addChild(shape)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としても同じですし&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var shape = Shape().addChildTo(this)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;として1行にまとめることもできます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;位置が指定されていない時は、画面左上(0,0)に表示されます。&lt;/li&gt;
&lt;li&gt;変数に代入しなくても表示されますが、後にプロパティを操作することが多いので、とりあえずは変数に代入しておいた方が良いでしょう。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>phina.jsの基本テンプレートについて</title>
      <link>https://alkn203.github.io/blog/2016/09/29/phina-template</link>
      <pubDate>Thu, 29 Sep 2016 01:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2016/09/29/phina-template</guid>
      <description>

&lt;h2 id=&#34;phina-jsの基本テンプレート&#34;&gt;phina.jsの基本テンプレート&lt;/h2&gt;

&lt;p&gt;自分自身の復習のためにも、私が普段１からコーディングをする時に使用しているテンプレートを紹介します。
実行結果は以下のように黒い画面が表示されるだけです。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://alkn203.github.io/blog/images/phina-template.png&#34; alt=&#34;phina_template_image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/8f0388a4&#34;&gt;[runstantで実行]&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;

&lt;h2 id=&#34;コード説明&#34;&gt;コード説明&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// グローバルに展開
phina.globalize();
/*
 * メインシーン
 */
phina.define(&amp;quot;MainScene&amp;quot;, {
  // 継承
  superClass: &#39;DisplayScene&#39;,
  // 初期化
  init: function() {
    // 親クラス初期化
    this.superInit();
    // 背景色
    this.backgroundColor = &#39;black&#39;;
    // 以下にコードを書いていく
  },
});
/*
 * メイン処理
 */
phina.main(function() {
  // アプリケーションを生成
  var app = GameApp({
    // MainScene から開始
    startLabel: &#39;main&#39;,
  });
  // fps表示
  //app.enableStats();
  // 実行
  app.run();
});
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;基本的には、&lt;strong&gt;MainScene&lt;/strong&gt;の&lt;strong&gt;init&lt;/strong&gt;関数内に自分のコードを書いていきます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;this.backgroundColor&lt;/strong&gt;で背景色を指定しないと、デフォルトでは白になります。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;main&lt;/strong&gt;関数内の&lt;strong&gt;GameApp&lt;/strong&gt;関数では、&lt;strong&gt;startLabel&lt;/strong&gt;を&lt;strong&gt;main&lt;/strong&gt;としていますが、これは実行結果をすぐに確認するためにタイトル画面をスキップしたいからです。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;main&lt;/strong&gt;関数内の&lt;strong&gt;enableStats&lt;/strong&gt;関数は、画面左上に&lt;strong&gt;fps&lt;/strong&gt;を常時表示する便利な機能ですが、処理が重くなるので一旦コメントアウトしています。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>ゲーム作成チュートリアル（マインスイーパー）（最終回）【マーク機能の追加】</title>
      <link>https://alkn203.github.io/blog/2016/08/03/minesweeper-tut-06</link>
      <pubDate>Wed, 03 Aug 2016 23:59:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2016/08/03/minesweeper-tut-06</guid>
      <description>

&lt;h2 id=&#34;今回の目標&#34;&gt;今回の目標&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://alkn203.github.io/blog/2016/07/11/minesweeper-tut-05/&#34;&gt;前回&lt;/a&gt;ではゲームオーバーとクリア処理を追加しました。
今回は最終回で、マーク機能を追加します。
マーク機能とは、自分で爆弾と判断したパネルをマークして開けないようにする機能です。
完成版は以下のとおりです。&lt;/p&gt;

&lt;div class=&#39;runstant&#39;&gt;&lt;iframe src=&#39;http://runstant.com/alkn203/projects/a76987b1/full&#39; width=&#39;100%&#39; height=&#39;640px&#39; style=&#39;border:0px;box-shadow:0px 0px 2px 0px #aaa&#39;&gt;&lt;/iframe&gt;&lt;/div&gt;

&lt;h2 id=&#34;コード説明&#34;&gt;コード説明&lt;/h2&gt;

&lt;h4 id=&#34;マーク機能の追加&#34;&gt;マーク機能の追加&lt;/h4&gt;

&lt;h4 id=&#34;mainsceneの変更点&#34;&gt;MainSceneの変更点&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // メインシーン
  phina.define(&#39;MainScene&#39;, {
    superClass: &#39;DisplayScene&#39;,
    // コンストラクタ
    init: function() {
      // 親クラス初期化
      （略）
      // ピース配置
      PANEL_NUM_XY.times(function(spanX) {
        PANEL_NUM_XY.times(function(spanY) {
          // パネル作成
          （略）
          // パネルタッチ時
          panel.onpointstart = function() {
            // マークモードなら
            if (self.mode === &#39;mark&#39;) {
              if (!panel.isOpen &amp;amp;&amp;amp; !panel.isMark) {
                // マーク追加
                if (self.markCount &amp;lt; BOMB_NUM) {
                  Mark().addChildTo(panel);
                  panel.isMark = true;
                  self.markCount++;
                }
              }
              else {
                if (self.markCount &amp;gt; 0) {
                  // マーク削除
                  panel.children[0].remove();
                  panel.isMark = false;
                  self.markCount--;
                }
              }
            }
            else {
              // パネルを開く
              self.openPanel(panel);
              // クリア判定
              self.checkClear();
            }
          };
        });
      });
      // モード
      this.mode = &#39;normal&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;this.mode&lt;/strong&gt;という変数でモードを管理します。&lt;/li&gt;
&lt;li&gt;マークモードであれば、パネルがタッチされた時にそのパネルがまだ開かれていなくて、かつ、マークされていなければマークを追加します。&lt;/li&gt;
&lt;li&gt;逆にマークがあれば、マークを削除します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;this.markCount&lt;/strong&gt;という変数で、マーク数が爆弾の数を超えないようにしています。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;      // マークモードボタン
      Button({
        width: 120,
        height: 64,
        text: &#39;Mark&#39;,
        fill: &#39;silver&#39;,
      }).addChildTo(this)
        .setPosition(this.gridX.span(14), this.gridY.span(14.5))
        .onpush = function() {
          // モード変更
          if (self.mode === &#39;normal&#39;) {
            this.fill = &#39;hsl(160, 80%, 50%)&#39;;
            self.mode = &#39;mark&#39;;
          }
          else {
            this.fill = &#39;silver&#39;;
            self.mode = &#39;normal&#39;;
          }
        };
      // 参照用
      （略）
      // マークの数
      this.markCount = 0;
    },
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;マークモードの切り替えには&lt;strong&gt;Button&lt;/strong&gt;を使用します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;onpush&lt;/strong&gt; 関数にボタンを押したときの処理を記述します。&lt;/li&gt;
&lt;li&gt;今回は現在のモードが分かるように切り替えでボタンの色が変わるようにしています。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// パネルを開く処理
openPanel: function(panel) {
  // マークされていた何もしない
  if (panel.isMark) return;
  （略）
},
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;マークされたパネルが連鎖で開かれないようにしています。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;おわりに&#34;&gt;おわりに&lt;/h2&gt;

&lt;p&gt;6回に渡ってチュートリアルを書いてきましたが、本エントリーが&lt;strong&gt;phina.js&lt;/strong&gt;を使ったゲーム作りの参考になれば幸いです。&lt;/p&gt;

&lt;h3 id=&#34;runstantプロジェクトへのリンク&#34;&gt;runstantプロジェクトへのリンク&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/a76987b1&#34;&gt;http://runstant.com/alkn203/projects/a76987b1&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ゲーム作成チュートリアル（マインスイーパー）（その５）【ゲームオーバーとクリア処理】</title>
      <link>https://alkn203.github.io/blog/2016/07/11/minesweeper-tut-05</link>
      <pubDate>Mon, 11 Jul 2016 23:59:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2016/07/11/minesweeper-tut-05</guid>
      <description>

&lt;h3 id=&#34;今回の目標&#34;&gt;今回の目標&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://alkn203.github.io/blog/2016/07/04/minesweeper-tut-03/&#34;&gt;前回&lt;/a&gt;はパネルが連鎖で開かれるようにしました。
今回は、ゲームオーバーとクリア処理を追加します。&lt;/p&gt;

&lt;div class=&#39;runstant&#39;&gt;&lt;iframe src=&#39;http://runstant.com/alkn203/projects/825d660c/full&#39; width=&#39;100%&#39; height=&#39;640px&#39; style=&#39;border:0px;box-shadow:0px 0px 2px 0px #aaa&#39;&gt;&lt;/iframe&gt;&lt;/div&gt;

&lt;h3 id=&#34;コード説明&#34;&gt;コード説明&lt;/h3&gt;

&lt;h4 id=&#34;ゲームオーバー処理&#34;&gt;ゲームオーバー処理&lt;/h4&gt;

&lt;h4 id=&#34;openpanel関数&#34;&gt;openPanel関数&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // パネルを開く処理
  openPanel: function(panel) {
    // 爆弾ならゲームオーバー
    if (panel.isBomb) {
      Explosion().addChildTo(panel);
      this.showAllBombs();
      return;
    }
    // 既に開かれていた何もしない
    （略）
  },
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;開いたパネルが爆弾だった場合、爆発を表示して、全ての爆弾を表示します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Explosion&lt;/strong&gt;クラスと&lt;strong&gt;showAllBombs&lt;/strong&gt;関数については後述します。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;explosionクラス&#34;&gt;Explosionクラス&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // 爆発クラス
  phina.define(&#39;Explosion&#39;, {
    // StarShapeを継承
    superClass: &#39;StarShape&#39;,
      // コンストラクタ
      init: function() {
        // 親クラス初期化
        this.superInit({
          radius: (PANEL_SIZE + 5) / 2,
          sides: 10,
          sideIndent: 0.75,
          rotation: 15,
          fill: &amp;quot;red&amp;quot;,
          stroke: &amp;quot;yellow&amp;quot;,
        });
      },
  });
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;StarShape&lt;/strong&gt;のパラメータを変えて爆発のように見せています。&lt;/li&gt;
&lt;li&gt;パラメータを変えることで、このような一風違った表現も可能です。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;showallbombs関数&#34;&gt;showAllBombs関数&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // 爆弾を全て表示する
  showAllBombs: function() {
    var self = this;
    
    this.panelGroup.children.each(function(panel) {
      panel.setInteractive(false);
      
      if (panel.isBomb) {
        Bomb().addChildTo(panel);
        panel.tweener.clear().scaleTo(1.2, 100)
                     .scaleTo(1.0, 100)
                     .call(function() {
                       // ラベル表示
                       Label({
                        text: &#39;TOUCH TO RESTART&#39;,
                        fill: &#39;white&#39;,
                       }).addChildTo(self).setPosition(320, 700);
                       // 画面をタッチ可能に
                       self.setInteractive(true);
                     });
      }
    });
  },
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Panel&lt;/strong&gt;をループで調べて、&lt;strong&gt;isBomb&lt;/strong&gt;が&lt;strong&gt;true&lt;/strong&gt;なら爆弾を表示します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tweener&lt;/strong&gt;で拡大・縮小のアニメーションをつけています。&lt;/li&gt;
&lt;li&gt;アニメーションした後は、ラベルを表示して画面のタッチを有効にしています。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;リスタート処理&#34;&gt;リスタート処理&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // 画面タッチ可能な場合
 onpointstart: function() {
   // 再スタート
   this.exit({
     nextLabel: &#39;main&#39;,  
   });  
 },
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;先に出た&lt;strong&gt;showAllBombs&lt;/strong&gt;で画面がタッチ有効になっている場合、画面をタッチするとこの関数が呼び出されます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;exit&lt;/strong&gt;関数で&lt;strong&gt;nextLabel&lt;/strong&gt;に&lt;strong&gt;main&lt;/strong&gt;を指定することで、メインシーンが呼び直されます。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;クリア処理&#34;&gt;クリア処理&lt;/h4&gt;

&lt;p&gt;マインスイーパーのクリアとは、爆弾以外のパネルが全部開かれた時です。
結果的には、「全体のパネル数から開かれたパネル数を引いた値が爆弾数と一致」すればよいということになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// メインシーン
phina.define(&#39;MainScene&#39;, {
  superClass: &#39;DisplayScene&#39;,
  // コンストラクタ
  init: function() {
    // 親クラス初期化
    （略）
    // 参照用
    this.panelGroup = panelGroup;
    // クリア判定用
    this.oCount = 0;
  },
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;開かれたパネル数をカウントするための変数&lt;strong&gt;oCount&lt;/strong&gt;を用意します。&lt;/li&gt;
&lt;li&gt;パネルを開いたら&lt;strong&gt;oCount&lt;/strong&gt;を増やしていきます。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;クリア判定&#34;&gt;クリア判定&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// パネルタッチ時
panel.onpointstart = function() {
  self.openPanel(panel);
  // クリア判定
  if (self.oCount === PANEL_NUM_XY * PANEL_NUM_XY - BOMB_NUM) {
    // ラベル表示
    Label({
      text: &#39;GOOD JOB!&#39;,
      fill: &#39;white&#39;,
    }).addChildTo(self).setPosition(320, 700);
    // パネルを選択不可に
    this.panelGroup.children.each(function(panel) {
      panel.setInteractive(false);
    });
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;パネルを開いた時に開かれた数を調べてクリアチェックをしています。&lt;/li&gt;
&lt;li&gt;クリアならラベルを表示して、全てのパネルを選択不可にしています。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;今回はここまで&#34;&gt;今回はここまで&lt;/h3&gt;

&lt;p&gt;ここまでで、ゲームオーバー処理とクリア処理を実装しました。
この状態で最低限のゲームとしては成立していると思いますが、次回は付加機能を追加したいと
思います。&lt;/p&gt;

&lt;h3 id=&#34;runstantプロジェクトへのリンク&#34;&gt;runstantプロジェクトへのリンク&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/825d660c&#34;&gt;http://runstant.com/alkn203/projects/825d660c&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ゲーム作成チュートリアル（マインスイーパー）（その４）【パネルを連鎖で開く】</title>
      <link>https://alkn203.github.io/blog/2016/07/06/minesweeper-tut-04</link>
      <pubDate>Wed, 06 Jul 2016 23:59:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2016/07/06/minesweeper-tut-04</guid>
      <description>

&lt;h3 id=&#34;今回の目標&#34;&gt;今回の目標&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://alkn203.github.io/blog/2016/07/04/minesweeper-tut-03/&#34;&gt;前回&lt;/a&gt;はパネルを開くと周りにある爆弾の数が表示されるようにしました。
今回は、周りに爆弾がない場合にパネルを連鎖で開くようにします。&lt;/p&gt;

&lt;div class=&#39;runstant&#39;&gt;&lt;iframe src=&#39;http://runstant.com/alkn203/projects/943f0dea/full&#39; width=&#39;100%&#39; height=&#39;640px&#39; style=&#39;border:0px;box-shadow:0px 0px 2px 0px #aaa&#39;&gt;&lt;/iframe&gt;&lt;/div&gt;

&lt;h3 id=&#34;コード説明&#34;&gt;コード説明&lt;/h3&gt;

&lt;h4 id=&#34;openpanel関数&#34;&gt;openPanel関数&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // パネルを開く処理
  openPanel: function(panel) {
    (略)
    // パネルに数を表示
    panel.num = bombs === 0 ? &#39;&#39; : bombs;
    Label({
      text: panel.num,
      fill: &#39;white&#39;,
    }).addChildTo(panel);
    panel.fill = &#39;gray&#39;;
    // 周りに爆弾がなければ再帰的に調べる
    if (bombs === 0) {
      indexs.each(function(i) {
        indexs.each(function(j) {
          var pos = Vector2(panel.x + i * GRID_SIZE, panel.y + j * GRID_SIZE);
          var target = self.getPanel(pos);
          target &amp;amp;&amp;amp; self.openPanel(target);
        });
      });
    }
  },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;周りに爆弾がない場合、現在のパネルを起点にして&lt;strong&gt;getPanel&lt;/strong&gt;を再帰呼び出しします。
今回の変更点はこれだけです。&lt;/p&gt;

&lt;h3 id=&#34;今回はここまで&#34;&gt;今回はここまで&lt;/h3&gt;

&lt;p&gt;ここまでで、パネルを連鎖で開くことができるようになりました。
段々と形になってきたと思いますが、爆弾も開けたりと全然ゲームになっていません。
次回は、ゲームオーバーとクリア処理を追加します。&lt;/p&gt;

&lt;h3 id=&#34;runstantプロジェクトへのリンク&#34;&gt;runstantプロジェクトへのリンク&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/943f0dea&#34;&gt;http://runstant.com/alkn203/projects/943f0dea&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ゲーム作成チュートリアル（マインスイーパー）（その３）【パネルを開く】</title>
      <link>https://alkn203.github.io/blog/2016/07/04/minesweeper-tut-03</link>
      <pubDate>Mon, 04 Jul 2016 23:59:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2016/07/04/minesweeper-tut-03</guid>
      <description>

&lt;h3 id=&#34;今回の目標&#34;&gt;今回の目標&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://alkn203.github.io/blog/2016/07/03/minesweeper-tut-02/&#34;&gt;前回&lt;/a&gt;はランダムに爆弾を配置しました。
今回はパネルを開いて周りにある爆弾の数が表示されるようにします。&lt;/p&gt;

&lt;div class=&#39;runstant&#39;&gt;&lt;iframe src=&#39;http://runstant.com/alkn203/projects/4edca5d9/full&#39; width=&#39;100%&#39; height=&#39;640px&#39; style=&#39;border:0px;box-shadow:0px 0px 2px 0px #aaa&#39;&gt;&lt;/iframe&gt;&lt;/div&gt;

&lt;h3 id=&#34;コード説明&#34;&gt;コード説明&lt;/h3&gt;

&lt;h4 id=&#34;mainscene&#34;&gt;MainScene&lt;/h4&gt;

&lt;h4 id=&#34;init関数&#34;&gt;init関数&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  init: function() {
    (略)
    var self = this;
    // ピース配置
    PANEL_NUM_XY.times(function(spanX) {
      PANEL_NUM_XY.times(function(spanY) {
        (略)
        // 開かれているかどうか
        panel.isOpen = false;
        // タッチ有効化
        panel.setInteractive(true);
        // パネルタッチ時
        panel.onpointstart = function() {
          self.openPanel(panel);
        };
        (略)
      });
    });
    // 参照用
    this.panelGroup = panelGroup;
  },
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;後に&lt;strong&gt;MainScene&lt;/strong&gt;を&lt;strong&gt;this&lt;/strong&gt;として参照するために、&lt;strong&gt;self&lt;/strong&gt;に代入しています。&lt;/li&gt;
&lt;li&gt;パネルが既に開かれているかどうかのフラグ変数&lt;strong&gt;isOpen&lt;/strong&gt;を作成しています。&lt;/li&gt;
&lt;li&gt;パネルをタッチできるように&lt;strong&gt;setInteractive(true)&lt;/strong&gt;としています。&lt;/li&gt;
&lt;li&gt;パネルのタッチイベント&lt;strong&gt;onpointstart&lt;/strong&gt;が発生した際に&lt;strong&gt;openPanel&lt;/strong&gt;関数を呼び出すようにしています。&lt;/li&gt;
&lt;li&gt;最後に&lt;strong&gt;panelGroup&lt;/strong&gt;を別の関数からも参照できるように&lt;strong&gt;this.panelGroup&lt;/strong&gt;に代入しています。
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;openpanel関数-新規追加&#34;&gt;openPanel関数(新規追加)&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // パネルを開く処理
  openPanel: function(panel) {
    // 既に開かれていた何もしない
    if (panel.isOpen) return;
    // 開いたとフラグを立てる
    panel.isOpen = true;
    // タッチ不可にする
    panel.setInteractive(false);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;パネルを開いた直後の処理です。既に開かれていたら以降の処理をパスします。&lt;/li&gt;
&lt;li&gt;フラグを変更して、&lt;strong&gt;setInteractive(false)&lt;/strong&gt;でタッチ不可にします。
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    var bombs = 0;
    var indexs = [-1, 0, 1];
    var self = this;
    // 周りのパネルの爆弾数をカウント
    indexs.each(function(i) {
      indexs.each(function(j) {
        var pos = Vector2(panel.x + i * GRID_SIZE, panel.y + j * GRID_SIZE);
        var target = self.getPanel(pos);
        if (target &amp;amp;&amp;amp; target.isBomb) bombs++;
      });
    });
    // パネルに数を表示
    panel.num = bombs === 0 ? &#39;&#39; : bombs;
    Label({
      text: panel.num,
      fill: &#39;white&#39;,
    }).addChildTo(panel);
    panel.fill = &#39;gray&#39;;
  },
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;インデックス値を利用して周りのパネルに爆弾が何個あるかを調べます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;getPanel&lt;/strong&gt;関数は、与えられた位置（Vector2）にパネルがあるかを返します。&lt;/li&gt;
&lt;li&gt;パネルが爆弾ならカウントして、ラベルで結果を表示しています。
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;getpanel関数-新規追加&#34;&gt;getPanel関数（新規追加）&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // 指定された位置のパネルを得る  
  getPanel: function(pos) {
    var result = null;
    
    this.panelGroup.children.some(function(panel) {
      if (panel.position.equals(pos)) {
        result = panel;
        return true;
      } 
    });
    return result;
  },
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;panelGroup&lt;/strong&gt;を調べて指定された位置にパネルがあれば、それを返します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;some&lt;/strong&gt;を使って条件が合ったらループを抜けるようにしています。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;今回はここまで&#34;&gt;今回はここまで&lt;/h3&gt;

&lt;p&gt;ここまでで、パネルを開いて爆弾数を表示することが出来ました。
次回は、再帰処理を使ってパネルが連鎖で開くようにします。&lt;/p&gt;

&lt;h3 id=&#34;runstantプロジェクトへのリンク&#34;&gt;runstantプロジェクトへのリンク&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/a24d063d&#34;&gt;http://runstant.com/alkn203/projects/a24d063d&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ゲーム作成チュートリアル（マインスイーパー）（その２）【爆弾の配置】</title>
      <link>https://alkn203.github.io/blog/2016/07/03/minesweeper-tut-02</link>
      <pubDate>Sun, 03 Jul 2016 23:59:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2016/07/03/minesweeper-tut-02</guid>
      <description>

&lt;h3 id=&#34;今回の目標&#34;&gt;今回の目標&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://alkn203.github.io/blog/2016/06/30/minesweeper-tut-01/&#34;&gt;前回&lt;/a&gt;はパネルをグリッド状に配置しました。
今回はマインスイーパーの主役とも言える爆弾を配置します。爆弾はランダムな場所に配置されるようにします。&lt;/p&gt;

&lt;div class=&#39;runstant&#39;&gt;&lt;iframe src=&#39;http://runstant.com/alkn203/projects/a24d063d/full&#39; width=&#39;100%&#39; height=&#39;640px&#39; style=&#39;border:0px;box-shadow:0px 0px 2px 0px #aaa&#39;&gt;&lt;/iframe&gt;&lt;/div&gt;

&lt;h3 id=&#34;今回のコード&#34;&gt;今回のコード&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;phina.globalize();
// 定数
var SCREEN_WIDTH = 640; // 画面横サイズ
var PANEL_NUM_XY = 9; // 縦横のパネル数
var GRID_SIZE = (SCREEN_WIDTH - 10) / PANEL_NUM_XY; // グリッドのサイズ
var SCREEN_HEIGHT = GRID_SIZE * 11; // 画面縦サイズ
var PANEL_SIZE = GRID_SIZE * 0.9; // パネルの大きさ
var PANEL_OFFSET = (GRID_SIZE + 10) / 2; // オフセット値
var BOMB_NUM = 10; // 爆弾数
// メインシーン
phina.define(&#39;MainScene&#39;, {
  superClass: &#39;DisplayScene&#39;,
  // コンストラクタ
  init: function() {
    // 親クラス初期化
    this.superInit({
      width: SCREEN_WIDTH,
      height: SCREEN_HEIGHT,
    });
    // 背景色
    this.backgroundColor = &#39;gray&#39;;
    // グリッド
    var grid = Grid(GRID_SIZE * PANEL_NUM_XY, PANEL_NUM_XY);
    // グループ
    var panelGroup = DisplayElement().addChildTo(this);
    // 爆弾位置をランダムに決めた配列を作成
    var bombs = [];
    (PANEL_NUM_XY * PANEL_NUM_XY).times(function() {
      bombs.push(false);
    });
    bombs.fill(true, 0, 10).shuffle();
    // ピース配置
    PANEL_NUM_XY.times(function(spanX) {
      PANEL_NUM_XY.times(function(spanY) {
        // パネル作成
        var panel = Panel().addChildTo(panelGroup);
        // Gridを利用して配置
        panel.x = grid.span(spanX) + PANEL_OFFSET;
        panel.y = grid.span(spanY) + PANEL_OFFSET;
        // パネルに爆弾情報を紐づける
        panel.isBomb = bombs[spanX * PANEL_NUM_XY + spanY];
        // 爆弾なら表示
        if (panel.isBomb) Bomb().addChildTo(panel);
      });
    });
  },
});
// パネルクラス
phina.define(&#39;Panel&#39;, {
  // RectangleShapeを継承
  superClass: &#39;RectangleShape&#39;,
    // コンストラクタ
    init: function() {
      // 親クラス初期化
      this.superInit({
        width: PANEL_SIZE,
        height: PANEL_SIZE,
        fill: &#39;silver&#39;, // 塗りつぶし色
        stroke: &#39;white&#39;, // 枠の色
        cornerRadius: 2, // 角の丸み
      });
    },
});
// 爆弾クラス
phina.define(&#39;Bomb&#39;, {
  // Shapeを継承
  superClass: &#39;Shape&#39;,
    // コンストラクタ
    init: function() {
      // 親クラス初期化
      this.superInit({
        width: GRID_SIZE,
        height: GRID_SIZE,
        backgroundColor: &#39;transparent&#39;,
      });
      // 導線
      RectangleShape({
        width: PANEL_SIZE / 8,
        height: PANEL_SIZE / 8,
        fill: &amp;quot;navy&amp;quot;,
        stroke: &#39;white&#39;,
        y: -20,
      }).addChildTo(this);
      // 本体
      CircleShape({
        radius: PANEL_SIZE / 4,
        fill: &amp;quot;navy&amp;quot;,
        stroke: &#39;white&#39;,
      }).addChildTo(this);
    },
});
// メイン
phina.main(function() {
  var app = GameApp({
    startLabel: &#39;main&#39;, // メイン画面からスタート
    width: SCREEN_WIDTH,
    height: SCREEN_HEIGHT,
  });
  app.run();
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;コード説明&#34;&gt;コード説明&lt;/h3&gt;

&lt;h4 id=&#34;定数の定義&#34;&gt;定数の定義&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 定数
（略）
var BOMB_NUM = 10; // 爆弾数
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;設置する爆弾数を定義します。&lt;/p&gt;

&lt;h4 id=&#34;爆弾位置情報の作成&#34;&gt;爆弾位置情報の作成&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;init: function() {
  （略）
  // 爆弾位置をランダムに決めた配列を作成
  var bombs = [];
  (PANEL_NUM_XY * PANEL_NUM_XY).times(function() {
    bombs.push(false);
  });
  bombs.fill(true, 0, 10).shuffle();
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;爆弾位置格納用の配列を作ります。&lt;/li&gt;
&lt;li&gt;一旦&lt;strong&gt;false&lt;/strong&gt;で埋めて、先頭の10個まで&lt;strong&gt;true&lt;/strong&gt;に置き換えてから&lt;strong&gt;shuffle&lt;/strong&gt;関数で要素をランダムに並び替えています。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;爆弾位置情報をパネルに紐づける&#34;&gt;爆弾位置情報をパネルに紐づける&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // ピース配置
  PANEL_NUM_XY.times(function(spanX) {
    PANEL_NUM_XY.times(function(spanY) {
      （略）
      // パネルに爆弾情報を紐づける
      panel.isBomb = bombs[spanX * PANEL_NUM_XY + spanY];
      // 爆弾なら表示
      if (panel.isBomb) Bomb().addChildTo(panel);
    });
  });
},
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;パネルの&lt;strong&gt;isBomb&lt;/strong&gt;プロパティに爆弾かどうかの情報&lt;strong&gt;true&lt;/strong&gt; or &lt;strong&gt;false&lt;/strong&gt;を設定しています。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;isBomb&lt;/strong&gt;プロパティが&lt;strong&gt;true&lt;/strong&gt;なら、爆弾を配置します。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;爆弾クラス&#34;&gt;爆弾クラス&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 爆弾クラス
phina.define(&#39;Bomb&#39;, {
  // Shapeを継承
  superClass: &#39;Shape&#39;,
    // コンストラクタ
    init: function() {
      // 親クラス初期化
      this.superInit({
        width: GRID_SIZE,
        height: GRID_SIZE,
        backgroundColor: &#39;transparent&#39;,
      });
      // 導線
      RectangleShape({
        width: PANEL_SIZE / 8,
        height: PANEL_SIZE / 8,
        fill: &amp;quot;navy&amp;quot;,
        stroke: &#39;white&#39;,
        y: -20,
      }).addChildTo(this);
      // 本体
      CircleShape({
        radius: PANEL_SIZE / 4,
        fill: &amp;quot;navy&amp;quot;,
        stroke: &#39;white&#39;,
      }).addChildTo(this);
    },
});
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;新たに&lt;strong&gt;Bomb&lt;/strong&gt;クラスを作成しています。&lt;/li&gt;
&lt;li&gt;爆弾はスプライト画像を使っても良いのですが、今回は敢えて&lt;strong&gt;Shape&lt;/strong&gt;を組み合わせて表現してみました。&lt;/li&gt;
&lt;li&gt;素の&lt;strong&gt;Shape&lt;/strong&gt;は&lt;strong&gt;backgroundColor&lt;/strong&gt;が設定されているので、これを透明にします。&lt;/li&gt;
&lt;li&gt;導線は本体の少し上になるようにy座標を指定しています。この場合、親から見た&lt;strong&gt;相対座標&lt;/strong&gt;になるということに注意してください。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;今回はここまで&#34;&gt;今回はここまで&lt;/h3&gt;

&lt;p&gt;ここまでで、爆弾をランダムに配置することができました。読み込まれる度に配置が異なることが確認できるかと思います。
次回は、パネルを開く処理を追加します。&lt;/p&gt;

&lt;h3 id=&#34;runstantプロジェクトへのリンク&#34;&gt;runstantプロジェクトへのリンク&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/a24d063d&#34;&gt;http://runstant.com/alkn203/projects/a24d063d&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ゲーム作成チュートリアル（マインスイーパー）（その１）【パネルの配置】</title>
      <link>https://alkn203.github.io/blog/2016/06/30/minesweeper-tut-01</link>
      <pubDate>Thu, 30 Jun 2016 23:59:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2016/06/30/minesweeper-tut-01</guid>
      <description>

&lt;h3 id=&#34;はじめに&#34;&gt;はじめに&lt;/h3&gt;

&lt;p&gt;以前にQiitaに&lt;a href=&#34;http://qiita.com/alkn203/items/a533b1264b912dec9590&#34;&gt;tmlib.js ＝マインスイーパー＝ チュートリアル編（目次）&lt;/a&gt;を投稿しましたが、今回は、これを&lt;a href=&#34;http://phinajs.com/&#34;&gt;phina.js&lt;/a&gt;で作り直すのが目標です。なお、本ブログのこれまでのチュートリアルを見て、「&lt;strong&gt;phina.js&lt;/strong&gt;でのゲーム作り」を少しは知っているということを前提にしています。
このチュートリアルでは、&lt;a href=&#34;http://phinajs.com/&#34;&gt;phina.js&lt;/a&gt;の公式開発環境として更に便利になった&lt;a href=&#34;http://runstant.com/&#34;&gt;runstant&lt;/a&gt;を使っていきたいと思います。&lt;/p&gt;

&lt;h3 id=&#34;今回の目標&#34;&gt;今回の目標&lt;/h3&gt;

&lt;p&gt;以下のようにパネルを並べます。
&lt;div class=&#39;runstant&#39;&gt;&lt;iframe src=&#39;http://runstant.com/alkn203/projects/ada3aa47/full&#39; width=&#39;100%&#39; height=&#39;640px&#39; style=&#39;border:0px;box-shadow:0px 0px 2px 0px #aaa&#39;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/p&gt;

&lt;h3 id=&#34;今回のコード&#34;&gt;今回のコード&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;phina.globalize();
// 定数
var SCREEN_WIDTH = 640; // 画面横サイズ
var PANEL_NUM_XY = 9; // 縦横のパネル数
var GRID_SIZE = (SCREEN_WIDTH - 10) / PANEL_NUM_XY; // グリッドのサイズ
var SCREEN_HEIGHT = GRID_SIZE * 11; // 画面縦サイズ
var PANEL_SIZE = GRID_SIZE * 0.9; // パネルの大きさ
var PANEL_OFFSET = (GRID_SIZE + 10) / 2; // オフセット値
// メインシーン
phina.define(&#39;MainScene&#39;, {
  superClass: &#39;DisplayScene&#39;,
  // コンストラクタ
  init: function() {
    // 親クラス初期化
    this.superInit({
      width: SCREEN_WIDTH,
      height: SCREEN_HEIGHT,
    });
    // 背景色
    this.backgroundColor = &#39;gray&#39;;
    // グリッド
    var grid = Grid(GRID_SIZE * PANEL_NUM_XY, PANEL_NUM_XY);
    // グループ
    var panelGroup = DisplayElement().addChildTo(this);
    // ピース配置
    PANEL_NUM_XY.times(function(spanX) {
      PANEL_NUM_XY.times(function(spanY) {
        // パネル作成
        var panel = Panel().addChildTo(panelGroup);
        // Gridを利用して配置
        panel.x = grid.span(spanX) + PANEL_OFFSET;
        panel.y = grid.span(spanY) + PANEL_OFFSET;
      });
    });
  },
});
// パネルクラス
phina.define(&#39;Panel&#39;, {
  // RectangleShapeを継承
  superClass: &#39;RectangleShape&#39;,
    // コンストラクタ
    init: function() {
      // 親クラス初期化
      this.superInit({
        width: PANEL_SIZE,
        height: PANEL_SIZE,
        fill: &#39;silver&#39;, // 塗りつぶし色
        stroke: &#39;white&#39;, // 枠の色
        cornerRadius: 2, // 角の丸み
      });
    },
});
// メイン
phina.main(function() {
  var app = GameApp({
    startLabel: &#39;main&#39;, // メイン画面からスタート
    width: SCREEN_WIDTH,
    height: SCREEN_HEIGHT,
  });
  app.run();
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;コード説明&#34;&gt;コード説明&lt;/h3&gt;

&lt;h4 id=&#34;定数の定義&#34;&gt;定数の定義&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 定数
var SCREEN_WIDTH = 640; // 画面横サイズ
var PANEL_NUM_XY = 9; // 縦横のパネル数
var GRID_SIZE = (SCREEN_WIDTH - 10) / PANEL_NUM_XY; // グリッドのサイズ
var SCREEN_HEIGHT = GRID_SIZE * 11; // 画面縦サイズ
var PANEL_SIZE = GRID_SIZE * 0.9; // パネルの大きさ
var PANEL_OFFSET = (GRID_SIZE + 10) / 2; // オフセット値
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;ゲームに必要な各種定数を定義しています。&lt;/li&gt;
&lt;li&gt;グリッドのサイズは、出来るだけ大きいサイズでパネル数で分割出来るように計算で求めています。&lt;/li&gt;
&lt;li&gt;パネルの大きさをグリッドサイズより少し小さくしてるのは、配置するときに隙間を開けるためです。&lt;/li&gt;
&lt;li&gt;パネルを正しい位置に配置できるようにオフセット値を計算しています。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;panelクラス&#34;&gt;Panelクラス&lt;/h4&gt;

&lt;p&gt;メイン処理の前にパネルクラスについて説明します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// パネルクラス
phina.define(&#39;Panel&#39;, {
  // RectangleShapeを継承
  superClass: &#39;RectangleShape&#39;,
    // コンストラクタ
    init: function() {
      // 親クラス初期化
      this.superInit({
        width: PANEL_SIZE,
        height: PANEL_SIZE,
        fill: &#39;silver&#39;, // 塗りつぶし色
        stroke: &#39;white&#39;, // 枠の色
        cornerRadius: 2, // 角の丸み
      });
    },
});
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;phina.define&lt;/strong&gt;でクラスを定義します。&lt;/li&gt;
&lt;li&gt;パネルは四角形なので&lt;strong&gt;RectangleShape&lt;/strong&gt;（矩形）クラスを継承します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;this.superInit&lt;/strong&gt;で親クラスにパラメーターを与えて初期化します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;cornerRadius&lt;/strong&gt;は角の丸みを指定します。（tmlib.jsではRoundRectangleShape）&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;メインシーン&#34;&gt;メインシーン&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// コンストラクタ
init: function() {
  // 親クラス初期化
  this.superInit({
    width: SCREEN_WIDTH,
    height: SCREEN_HEIGHT,
  });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;画面サイズを反映させるためには、&lt;strong&gt;DisplayScene&lt;/strong&gt;の親クラスにも&lt;strong&gt;width&lt;/strong&gt;と&lt;strong&gt;height&lt;/strong&gt;を指定する必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // 背景色
  this.backgroundColor = &#39;gray&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Scene&lt;/strong&gt;の背景色を指定しています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // グリッド
  var grid = Grid(GRID_SIZE * PANEL_NUM_XY, PANEL_NUM_XY);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Grid&lt;/strong&gt;クラスを使って、配置用の情報を生成しています。ここで1グリッドの大きさが決まります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // グループ
  var panelGroup = DisplayElement().addChildTo(this);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;DisplayElement&lt;/strong&gt;を使ってパネルを格納するグループを作成しています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // ピース配置
  PANEL_NUM_XY.times(function(spanX) {
    PANEL_NUM_XY.times(function(spanY) {
      // パネル作成
      var panel = Panel().addChildTo(panelGroup);
      // Gridを利用して配置
      panel.x = grid.span(spanX) + PANEL_OFFSET;
      panel.y = grid.span(spanY) + PANEL_OFFSET;
    });
  });
},
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;パネルをグリッド状に配置する処理です。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;times&lt;/strong&gt;関数は、&lt;strong&gt;phina.js&lt;/strong&gt;独自の仕様で、前に付いた値の回数だけ処理を繰り返します。ここでは、&lt;strong&gt;PANEL_NUM_XY&lt;/strong&gt;回、つまり9回の繰り返しです。入れ子にしてグリッド状に配置します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Panel&lt;/strong&gt;を作成して&lt;strong&gt;panelGroup&lt;/strong&gt;に追加しています。&lt;/li&gt;
&lt;li&gt;最後にパネルの位置を指定します。&lt;strong&gt;span&lt;/strong&gt;にインデックス値を指定することで、グリッド状に綺麗に配置することが出来ます。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;今回はここまで&#34;&gt;今回はここまで&lt;/h3&gt;

&lt;p&gt;ここまでで、パネルを配置することができました。
次回は、&lt;a href=&#34;http://alkn203.github.io/blog/2016/07/03/minesweeper-tut-02/&#34;&gt;爆弾の配置&lt;/a&gt;です。&lt;/p&gt;

&lt;h3 id=&#34;runstantプロジェクトへのリンク&#34;&gt;runstantプロジェクトへのリンク&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/ada3aa47&#34;&gt;http://runstant.com/alkn203/projects/ada3aa47&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>フレームアニメーション関係Tips</title>
      <link>https://alkn203.github.io/blog/2016/06/11/frameanimation-tips</link>
      <pubDate>Sat, 11 Jun 2016 23:59:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2016/06/11/frameanimation-tips</guid>
      <description>

&lt;h3 id=&#34;今回のtips&#34;&gt;今回のTips&lt;/h3&gt;

&lt;p&gt;以前にも紹介したように、phina.jsには&lt;strong&gt;FrameAnimation&lt;/strong&gt;という便利な機能があります。
今回はより便利に使うための2つのTipsを紹介します。&lt;/p&gt;

&lt;h3 id=&#34;スプライトのサイズがスプライトシートに定義されたサイズにフィットしないようにする&#34;&gt;スプライトのサイズがスプライトシートに定義されたサイズにフィットしないようにする&lt;/h3&gt;

&lt;p&gt;フレームアニメーションを使うためには、&lt;strong&gt;SpriteSheet&lt;/strong&gt;を定義する必要がありますが
デフォルトだと実際のコード中でスプライトのサイズを変えてもスプライトシート(json)に書かれた&lt;strong&gt;width&lt;/strong&gt;と&lt;strong&gt;height&lt;/strong&gt;に
戻ってしまい、スプライトを拡大して表示したい時に意図した結果になりません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// スプライトシート
spritesheet: {
  &#39;explosion_ss&#39;:
  {
    &amp;quot;frame&amp;quot;: {
      &amp;quot;width&amp;quot;: 20, // ←この値にフィットされる
      &amp;quot;height&amp;quot;: 20,// ←この値にフィットされる
      &amp;quot;cols&amp;quot;: 16,
      &amp;quot;rows&amp;quot;: 1,
    },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを回避するためには、&lt;strong&gt;FrameAnimation&lt;/strong&gt;クラスのプロパティ&lt;strong&gt;fit&lt;/strong&gt;を&lt;strong&gt;false&lt;/strong&gt;にします。
これで実際に変更したサイズで正しく表示されるようになります。
サンプルでは20X20で切り出した画像を5倍で表示しています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 親クラスの初期化
this.superInit(&#39;explosion&#39;, 20, 20); // ←実際の画像の切り取りサイズ
// SpriteSheetをスプライトにアタッチ
var anim = FrameAnimation(&#39;explosion_ss&#39;).attachTo(this);
// スプライトシートのサイズにフィットさせない
anim.fit = false; // ←ここ
//アニメーションを再生する
anim.gotoAndPlay(&#39;start&#39;);
// サイズ変更
this.setSize(20*5, 20*5); // ←サイズ変更
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;フレームアニメーションの終了を検知する&#34;&gt;フレームアニメーションの終了を検知する&lt;/h3&gt;

&lt;p&gt;ゲーム作成において、フレームアニメーションが終了した後に何か処理をしたい時があるかと思いまます。
この場合、&lt;strong&gt;FrameAnimation&lt;/strong&gt;クラスの&lt;strong&gt;finished&lt;/strong&gt;プロパティの値が&lt;strong&gt;true&lt;/strong&gt;かどうかを調べると便利です。
サンプルでは爆発アニメーションが終了したら、自身を消去するようにしています。（consoleに結果表示）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 毎フレーム処理
update: function() {
  // アニメーションが終わったら自身を消去
  if (this.anim.finished) { // ←ここで判定
    this.remove();
    console.log(&#39;removed&#39;);
  }
},
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;サンプル-runstant上&#34;&gt;サンプル(runstant上)&lt;/h4&gt;

&lt;div class=&#39;runstant&#39;&gt;&lt;iframe src=&#39;http://runstant.com/alkn203/projects/e18e94bb&#39; width=&#39;100%&#39; height=&#39;640px&#39; style=&#39;border:0px;box-shadow:0px 0px 2px 0px #aaa&#39;&gt;&lt;/iframe&gt;&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>ポーズ動作のサンプル</title>
      <link>https://alkn203.github.io/blog/2016/04/23/pause</link>
      <pubDate>Sat, 23 Apr 2016 23:59:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2016/04/23/pause</guid>
      <description>

&lt;h3 id=&#34;サンプル&#34;&gt;サンプル&lt;/h3&gt;

&lt;p&gt;ゲームでよくあるポーズ機能です。
もっとスマートな方法があるかと思いますが、今回は&lt;strong&gt;update&lt;/strong&gt;関数の差し替えを活用しています。&lt;/p&gt;

&lt;div class=&#39;runstant&#39;&gt;
&lt;iframe src=&#39;http://runstant.com/alkn203/projects/5b15c783&#39; width=&#39;100%&#39; height=&#39;640px&#39; style=&#39;border:0px;box-shadow:0px 0px 2px 0px #aaa&#39;&gt;
&lt;/iframe&gt;
&lt;/div&gt;

&lt;h3 id=&#34;コード&#34;&gt;コード&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;phina.globalize();
// メインシーン
phina.define(&#39;MainScene&#39;, {
  superClass: &#39;DisplayScene&#39;,
  // コンストラクタ
  init: function() {
    // 親クラス初期化
    this.superInit();
    // 背景色
    this.backgroundColor = &#39;black&#39;;

    var label = Label({
      text: &#39;画面タッチでポーズ切り替え&#39;,
      fontSize: 36,
      fill: &#39;yellow&#39;,
    }).addChildTo(this).setPosition(this.gridX.center(), this.gridY.center(-4));
    label.alpha = 0.7;

    var rect = RectangleShape().addChildTo(this);
    rect.setPosition(this.gridX.center(), this.gridY.center());
    this.rect = rect;
    this.update = this.start;
  },

  start: function() {
    this.rect.rotation += 8;
  },
  
  onpointstart: function() {
    this.update = this.update !== null ? null : this.start;
  } 
});

// メイン
phina.main(function() {
  app = GameApp({
    startLabel: &#39;main&#39;,
  });
  app.run();
});
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>スポットライトを作ってみた</title>
      <link>https://alkn203.github.io/blog/2016/03/09/phina-spotlight</link>
      <pubDate>Wed, 09 Mar 2016 23:59:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2016/03/09/phina-spotlight</guid>
      <description>

&lt;h3 id=&#34;サンプル&#34;&gt;サンプル&lt;/h3&gt;

&lt;p&gt;スポットライト的なエフェクトのサンプルです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ドラッグして移動することができます。&lt;/li&gt;
&lt;li&gt;マスク用の&lt;strong&gt;Shape&lt;/strong&gt;を土台にして、&lt;strong&gt;canvas&lt;/strong&gt;の&lt;strong&gt;clear&lt;/strong&gt;（矩形クリア）と&lt;strong&gt;arc&lt;/strong&gt;を使ってスポットを作っています。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&#39;runstant&#39;&gt;&lt;iframe src=&#39;http://goo.gl/idCD53&#39; width=&#39;100%&#39; height=&#39;640px&#39; style=&#39;border:0px;box-shadow:0px 0px 2px 0px #aaa&#39;&gt;&lt;/iframe&gt;&lt;/div&gt;

&lt;p&gt;[&lt;a href=&#34;http://goo.gl/ZrpjNP&#34;&gt;runstantで開く&lt;/a&gt;]&lt;/p&gt;

&lt;h3 id=&#34;コード&#34;&gt;コード&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;phina.globalize();
// アセット
var ASSETS = {
  // 画像
  image: {
    &#39;logo&#39;: &#39;https://raw.githubusercontent.com/phi-jp/phina.js/develop/logo.png&#39;,
  },
};
// 定数
LOGO_SIZE = 512;
PART_SIZE = 128;
// メインシーン
phina.define(&#39;MainScene&#39;, {
  superClass: &#39;DisplayScene&#39;,
  // コンストラクタ
  init: function() {
    // 親クラス初期化
    this.superInit({
      // 画面サイズ指定
      width: LOGO_SIZE,
      height: LOGO_SIZE,
    });
    // 背景色
    this.backgroundColor = &#39;skyblue&#39;;
    // 中心座標
    var cx = this.gridX.center();
    var cy = this.gridY.center();
    // ロゴ追加
    var logo = Sprite(&#39;logo&#39;).addChildTo(this).setPosition(cx, cy);
    // スポットライト
    var spot = SpotShape({
      width: LOGO_SIZE * 2,
      height: LOGO_SIZE * 2,
      spotRadius: 64,
      alpha: 0.75,
    }).addChildTo(this).setPosition(cx, cy);
    // ドラッグ可能にする
    Draggable().attachTo(spot);
  },
});
//
phina.define(&#39;SpotShape&#39;, {
  superClass: &#39;Shape&#39;,
  // コンストラクタ 
  init: function(options) {
    // 親クラス初期化
    this.superInit({
      width: options.width,
      height: options.height,
      backgroundColor: options.fill || &#39;black&#39;,
    });
    // 透明度
    if (options.alpha) {
      this.alpha = options.alpha;
    }
    // スポット半径
    this.spotRadius = options.spotRadius ? options.spotRadius : 32;
  },
  // 描画
   render: function(canvas) {
      // クリアカラー
      canvas.clearColor(this.backgroundColor);
      // 中心に座標を移動
      canvas.transformCenter();

      var r = this.spotRadius;
      var r2 = r * 2;
      // 一旦矩形で切り抜き
      canvas.clear(-r, -r, r2, r2);
      canvas.fillStyle = this.backgroundColor;
      // スポット円外側塗りつぶし
      // 下部分
      canvas.beginPath()
            .arc(0, 0, r, 0, Math.degToRad(180), false)
            .lineTo(-r, r).lineTo(r, r).lineTo(r, -r)
            .fill();
      // 上部分
      canvas.beginPath()
            .arc(0, 0, r, 0, Math.degToRad(180), true)
            .lineTo(-r, -r).lineTo(r, -r).lineTo(r, -r)
            .fill();      // 描画後処理
      return this;
    },
});
// メイン
phina.main(function() {
  var app = GameApp({
    startLabel: &#39;main&#39;,
    // アセット読み込み
    assets: ASSETS,
    // 画面サイズ指定
    width: LOGO_SIZE,
    height: LOGO_SIZE,
  });
  app.run();
});
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>グローバル座標とローカル座標を使ったサンプル</title>
      <link>https://alkn203.github.io/blog/2016/03/05/parent-and-children</link>
      <pubDate>Sat, 05 Mar 2016 23:59:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2016/03/05/parent-and-children</guid>
      <description>

&lt;h3 id=&#34;はじめに&#34;&gt;はじめに&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;phina.js&lt;/strong&gt;では、オブジェクトにオブジェクトを追加すると親子関係が成立します。子オブジェクトは親オブジェクトに追従するようになり、まとめて移動する必要がある時などに便利です。
この際に注意するべきことは、&lt;strong&gt;子オブジェクトの座標は親オブジェクトの中心からの相対座標&lt;/strong&gt;になるという点です。
従って、子オブジェクトとの当たり判定などを行う時は、親のグローバル座標と子のローカル座標について把握しておく必要があります。&lt;/p&gt;

&lt;h3 id=&#34;サンプル&#34;&gt;サンプル&lt;/h3&gt;

&lt;p&gt;子オブジェクトとの当たり判定のサンプルです。
当たり判定処理では、子オブジェクトの座標値はそのまま使えませんので&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;親のx座標 + 子のx座標（相対値）
親のy座標 + 子のy座標（相対値）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で補正した値を元に位置情報だけの&lt;strong&gt;Rect&lt;/strong&gt;（矩形）を作り、&lt;strong&gt;Collision&lt;/strong&gt;クラスを使ってその&lt;strong&gt;Rect&lt;/strong&gt;と当たり判定を行っています。&lt;/p&gt;

&lt;div class=&#39;runstant&#39;&gt;&lt;iframe src=&#39;http://goo.gl/IIEsns&#39; width=&#39;100%&#39; height=&#39;640px&#39; style=&#39;border:0px;box-shadow:0px 0px 2px 0px #aaa&#39;&gt;&lt;/iframe&gt;&lt;/div&gt;

&lt;p&gt;[&lt;a href=&#34;http://goo.gl/IIEsns&#34;&gt;runstantで開く&lt;/a&gt;]&lt;/p&gt;

&lt;h3 id=&#34;コード&#34;&gt;コード&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;phina.globalize();
// 定数
var SCREEN_RECT = Rect(0, 0, 640, 960); // 画面サイズのRect
// メインシーン
phina.define(&#39;MainScene&#39;, {
  superClass: &#39;DisplayScene&#39;,
  // コンストラクタ
  init: function() {
    // 親クラス初期化
    this.superInit();
    // 背景
    this.backgroundColor = &#39;black&#39;;

    Label({
      text: &#39;Touch To Shot&#39;,
      fontSize: 48,
      fill: &#39;lime&#39;,
    }).addChildTo(this).setPosition(this.gridX.center(), this.gridY.span(2));
    // ショットグループ
    var shotGroup = DisplayElement().addChildTo(this);
    // 敵子供グループ
    var pitGroup = DisplayElement().addChildTo(this);
    // 自機
    var player = TriangleShape().addChildTo(this);
    player.setPosition(this.gridX.center(), this.gridY.span(15));
    // 敵
    var enemy = RectangleShape().addChildTo(this);
    enemy.setPosition(this.gridX.center(), this.gridY.center(-2));

    enemy.tweener.clear()
                 .by({x: -100}, 1000)
                 .by({x: 200}, 2000)
                 .by({x: -100}, 1000)
                 .setLoop(true);
    // 敵子供追加
    [0, 45, 90, 135, 180, 225, 270, 315].each(function(deg) {
      Pit(deg, 4).addChildTo(enemy);
    });
    // 参照用
    this.player = player;
    this.enemy = enemy;
    this.shotGroup = shotGroup;
    this.pitGroup = pitGroup;
  },
  // 画面タッチ時処理
  onpointstart: function() {
    // ショットが無ければ
    if (this.shotGroup.children.length === 0) {
      // 上方向にショット発射
      CircleShape({
        radius: 16,
      }).addChildTo(this.shotGroup)
        .setPosition(this.player.x, this.player.top)
        .physical.force(0, -16);
    }
  },
  // 毎フレーム更新
  update: function() {
    var enemy = this.enemy;
    // 画面からはみ出たショットは削除
    this.shotGroup.children.each(function(shot) {
      if (shot.bottom &amp;lt; SCREEN_RECT.top) shot.remove();      
    });
    // 敵に当たったらショットは削除
    this.shotGroup.children.each(function(shot) {
      if (shot.hitTestElement(enemy)) shot.remove();
    });
    // ショットと敵の子供のあたり判定
    this.shotGroup.children.each(function(shot) {
      enemy.children.each(function(pit) {
        // 相対座標を絶対座標に変換した当たり判定用の矩形を作る
        var rect = Rect(enemy.x + pit.x, enemy.y + pit.y, pit.width, pit.height);
        // Collisionクラスを利用して当たり判定
        if (Collision.testRectRect(shot, rect)) {
          shot.remove();
          pit.remove();
        }
      });
    });
  },
});
// 敵子供クラス
phina.define(&#39;Pit&#39;, {
  superClass: &#39;PolygonShape&#39;,
  // コンストラクタ
  init: function(deg, speed) {
    // 親クラス初期化
    this.superInit({
      radius: 16,
      sides: 6,
    });

    this.r = 32 * 3;
    this.speed = speed;
    this.deg = deg;
  },
  // 毎フレーム更新
  update: function() {
    this.rotation += -this.speed * 2;
    this.deg += this.speed;    
    var deg = this.deg;
    var r = this.r;
    // 円周上の位置（相対座標）
    this.x = r * Math.cos(Math.degToRad(deg));
    this.y = r * Math.sin(Math.degToRad(deg));
  },
});
// メイン
phina.main(function() {
  var app = GameApp({
    startLabel: &#39;main&#39;,
    title: &#39;Hit test children&#39;,
  });
  app.run();
});
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>