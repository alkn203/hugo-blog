<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Keep On Coding</title>
    <link>https://alkn203.github.io/blog/</link>
    <description>Recent content on Keep On Coding</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Sun, 20 Sep 2020 20:55:06 +0900</lastBuildDate>
    
	<atom:link href="https://alkn203.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>【phina.js】ゲーム作成チュートリアル（ブロック崩し）=第3回 ボールの作成=</title>
      <link>https://alkn203.github.io/blog/2020/09/20/breakout-03/</link>
      <pubDate>Sun, 20 Sep 2020 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2020/09/20/breakout-03/</guid>
      <description>はじめに 前回は、プレイヤーが操作するパドルを作成しました。今回は、ブロック崩しの肝とも言えるボールを作成したいと思います。
runstantで確認
コードは以下のとおりです。
// グローバルに展開 phina.globalize(); /* * 定数 */ var BLOCK_WIDTH = 40 * 2; var BLOCK_HEIGHT = 60 / 2; var PADDLE_WIDTH = BLOCK_WIDTH * 1.5; var PADDLE_HEIGHT = BLOCK_HEIGHT; var BALL_RADIUS = BLOCK_WIDTH / 8; /* * メインシーン */ phina.define(&amp;#34;MainScene&amp;#34;, { // 継承  superClass: &amp;#39;DisplayScene&amp;#39;, // コンストラクタ  init: function() { // 親クラス初期化  this.superInit(); // 背景色  this.backgroundColor = &amp;#39;black&amp;#39;; // ブロックグループ  this.blockGroup = DisplayElement().</description>
    </item>
    
    <item>
      <title>【phina.js】ゲーム作成チュートリアル（ブロック崩し）=第2回 パドルの作成=</title>
      <link>https://alkn203.github.io/blog/2020/09/19/breakout-02/</link>
      <pubDate>Sat, 19 Sep 2020 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2020/09/19/breakout-02/</guid>
      <description>はじめに 前回は、画面上部にブロックを配置しました。今回は、プレイヤーが操作するパドルを作成します。
runstantで確認
定数とPaddleクラスを定義する パドル用の定数を追加して、Paddleクラスをphina.defineで定義します。コードは以下のとおりです。
// グローバルに展開 phina.globalize(); /* * 定数 */ var BLOCK_WIDTH = 40 * 2; var BLOCK_HEIGHT = 60 / 2; var PADDLE_WIDTH = BLOCK_WIDTH * 1.5; var PADDLE_HEIGHT = BLOCK_HEIGHT; /* * メインシーン */ phina.define(&amp;#34;MainScene&amp;#34;, { // 継承  superClass: &amp;#39;DisplayScene&amp;#39;, // コンストラクタ  init: function() { // 親クラス初期化  this.superInit(); // 背景色  this.backgroundColor = &amp;#39;black&amp;#39;; // ブロックグループ  this.blockGroup = DisplayElement().addChildTo(this); var self = this; // Gridを利用してブロック設置  Array.</description>
    </item>
    
    <item>
      <title>【phina.js】ゲーム作成チュートリアル（ブロック崩し）=第1回 ブロックの配置=</title>
      <link>https://alkn203.github.io/blog/2020/09/18/breakout-01/</link>
      <pubDate>Fri, 18 Sep 2020 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2020/09/18/breakout-01/</guid>
      <description>目的 このチュートリアルでは、ゲームプログラミングの手軽な題材として有名なブロック崩しをphina.jsで作っていきます。第1回目は、以下のようにブロックを配置します。
runstantで確認
定数とBlockクラスを定義する ゲーム内で使用する定数は通常のvarで、Blockクラスはphina.defineを使って定義します。コードは以下のとおりです。
phina.globalize(); /* * 定数 */ var BLOCK_WIDTH = 40 * 2; var BLOCK_HEIGHT = 60 / 2; /* * メインシーン */ phina.define(&amp;#39;MainScene&amp;#39;, { superClass: &amp;#39;DisplayScene&amp;#39;, // コンストラクタ  init: function() { // 親クラス初期化  this.superInit(); // 背景色  this.backgroundColor = &amp;#39;black&amp;#39;; }, }); /* * ブロッククラス */ phina.define(&amp;#39;Block&amp;#39;, { // 親クラス指定  superClass: &amp;#39;RectangleShape&amp;#39;, // コンストラクタ  init: function() { // 親クラス初期化  this.superInit({ width: BLOCK_WIDTH, height: BLOCK_HEIGHT, }); }, }); /* * メイン処理 */ phina.</description>
    </item>
    
    <item>
      <title>【phina.js】倉庫番風ゲームのプロトタイプを作ってみた</title>
      <link>https://alkn203.github.io/blog/2020/03/08/sokoban/</link>
      <pubDate>Sun, 08 Mar 2020 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2020/03/08/sokoban/</guid>
      <description>はじめに phina.jsで倉庫番風ゲームのプロトタイプを作ってみました。
runstantで表示
作成にあたってのポイント  自作Mapクラスの機能を活用してます。 ステージデータはオブジェクト型の配列にしていますので、拡張すれば複数ステージ制にすることも可能かと思います。 プレイヤーと荷物の移動は、Tweenerを使うことで座標の移動に伴う座標のズレが発生しないようにしています。  GitHubリポジトリ https://github.com/alkn203/phina-games/tree/master/sokoban</description>
    </item>
    
    <item>
      <title>【phina.js】塗りつぶしアルゴリズムとtweenerを組み合わせた表現</title>
      <link>https://alkn203.github.io/blog/2020/02/25/phina-fill/</link>
      <pubDate>Tue, 25 Feb 2020 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2020/02/25/phina-fill/</guid>
      <description>はじめに ふと思い立って、単純な塗りつぶしアルゴリズムとtweenerを組み合わせて、塗りつぶしが進む様子を可視化してみました。
上手く使うとゲームで室内が水で埋まっていく表現とかに使えそうです。
runstantで実行
コーディングにおけるポイント  塗りつぶしアルゴリズムは一番単純なもので、塗りつぶし開始地点から上下左右のタイルで塗りつぶし可能なものを調べて、それを再帰的に調べて処理していくというものです。 探査の途中で時間差で水を表示するとタイムラグが生じるため、一旦水を配置したら非表示にしています。 tweenerのwaitを使って、時間差で水を再表示していくようにしています。  ソースコード // グローバルに展開 phina.globalize(); // アセット var ASSETS = { // 画像  image: { &amp;#39;tile&amp;#39;: &amp;#39;https://cdn.jsdelivr.net/gh/alkn203/tomapiko_run@master/assets/tile.png&amp;#39;, &amp;#39;tile_sea&amp;#39;: &amp;#39;https://cdn.jsdelivr.net/gh/alkn203/assets_etc@master/pipo-map001_at-umi.png&amp;#39;, }, }; // 定数 var UNIT = 64; /* * メインシーン */ phina.define(&amp;#34;MainScene&amp;#34;, { // 継承  superClass: &amp;#39;DisplayScene&amp;#39;, // コンストラクタ  init: function() { // 親クラス初期化  this.superInit(); var data = [ [2,2,2,2,2,2,2,2,2,2], [2,1,1,1,1,1,1,1,1,2], [2,2,2,2,2,2,2,1,1,2], [2,1,1,1,1,1,2,1,1,2], [2,1,1,1,1,1,2,1,1,2], [2,1,1,2,1,1,2,1,1,2], [2,1,1,2,1,1,1,1,1,2], [2,1,1,2,1,1,1,1,1,2], [2,1,1,2,1,1,1,1,1,2], [2,1,1,2,1,1,1,2,2,2], [2,1,1,1,1,1,1,1,1,2], [2,1,1,1,1,2,1,1,1,2], [2,1,2,2,2,2,2,1,1,2], [2,1,1,1,1,1,1,1,1,2], [2,2,2,2,2,2,2,2,2,2] ]; var col = [ [1,1,1,1,1,1,1,1,1,1], [1,0,0,0,0,0,0,0,0,1], [1,1,1,1,1,1,1,0,0,1], [1,0,0,0,0,0,1,0,0,1], [1,0,0,0,0,0,1,0,0,1], [1,0,0,1,0,0,1,0,0,1], [1,0,0,1,0,0,0,0,0,1], [1,0,0,1,0,0,0,0,0,1], [1,0,0,1,0,0,0,0,0,1], [1,0,0,1,0,0,0,1,1,1], [1,0,0,0,0,0,0,0,0,1], [1,0,0,0,0,1,0,0,0,1], [1,0,1,1,1,1,1,0,0,1], [1,0,0,0,0,0,0,0,0,1], [1,1,1,1,1,1,1,1,1,1] ]; this.</description>
    </item>
    
    <item>
      <title>【phina.js】Mapクラスを作ってみた</title>
      <link>https://alkn203.github.io/blog/2020/01/03/phina-map-class/</link>
      <pubDate>Fri, 03 Jan 2020 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2020/01/03/phina-map-class/</guid>
      <description>はじめに RPGなどで固定マップで単純な当たり判定を行いたい時は、Mapデータと当たり判定データを読み込んで行う方法が便利です。 今回は、enchant.jsにあったMapクラスを参考にphina.js版を作ってみました。
コンストラクタ var map = phina.util.Map({ tileWidth: 64, tileHeight: 64, imageName: &amp;#39;tile&amp;#39;, mapData: data, collisionData: collision, }).addChildTo(this); プロパティ    プロパティ 説明     tileWidth タイルの幅   tileHeight タイルの高さ   imageName タイルセット画像の名前   mapData マップデータの2次元配列   collisionData タイル衝突判定用の2次元配列    メンバ関数    関数 説明     hitTest マップとの衝突判定を行う(座標から)   hitTestByIndex マップとの衝突判定を行う(インデックスから)   checkTile タイルが何か調べる(座標から)   checkTileByIndex タイルが何か調べる(インデックスから)   setTile タイルを更新する   getChild 子要素を得る（座標から）   getChildByIndex 子要素を得る（インデックスから）    おわりに 本格的なマップ作成には、タイルマップエディタが必要になってくると思いますが、簡単なゲームであれば、この程度の機能でも使えるのではないでしょうか。</description>
    </item>
    
    <item>
      <title>【phina.js】Arrayクラスのeach関数を拡張する</title>
      <link>https://alkn203.github.io/blog/2019/12/31/phina-each-extension/</link>
      <pubDate>Tue, 31 Dec 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2019/12/31/phina-each-extension/</guid>
      <description>はじめに phina.jsには、通常のfor文の代替で使える便利なメソッドがあります。 Numberの拡張クラスのメソッドtimesが代表的な例です。
(10).times(function(i) { console.log(&amp;#39;hello&amp;#39;); });  コールバック関数内に書かれた処理を10回繰り返します。 結果は hello が10回表示されます。  コールバック関数内でthisを使う コールバック関数内でthisを使った場合、このthisはコールバック関数自身を指すので、第2引数に明示的にthisが指定できるようになっています。
this.count = 0; (10).times(function(i) { this.count += i; }, this); Arrayクラスのメソッドeach phina.jsのArrayクラスには、eachというメソッドがあり、配列の各要素に対して共通の処理を行うことができます。実体はforEachです。
var spriteGroup = DisplayElement.addChildTo(this); // 各スプライトの移動 spriteGroup.children.each(function(sprite) { sprite.x += 1; }); eachを拡張してthisが指定できるようにする  便利なeachメソッドですが、現在の仕様では上で触れたtimesメソッドのように第２引数にthisを代入することができません。 eachメソッドを以下のように拡張して、thisが指定できるようにしてみました。  Array.prototype.$method(&amp;#34;each&amp;#34;, function(fn, self) { self = self || this; for (var i=0; i&amp;lt;this.length; ++i) { fn.call(self, this[i], i, this); } return this; }); サンプルコード(runstant)
まとめ 今回の拡張は、新しいjavascriptにあるアロー関数を使えば解決できることではありますが、参考までにこのような方法もあると知ってもらえば幸いです。</description>
    </item>
    
    <item>
      <title>【phina.js】マリオのようなブロック破壊処理</title>
      <link>https://alkn203.github.io/blog/2019/09/18/phina-break-object/</link>
      <pubDate>Wed, 18 Sep 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2019/09/18/phina-break-object/</guid>
      <description>はじめに 子供の頃始めてスーパーマリオブラザーズをプレイした時、ブロックが壊せることが斬新で、必要のないところまで壊しまくったりしたものです。今回は、phina.jsでその再現を試みてみました。
サンプルコード(runstant)
ブロックの動きを観察する マリオのブロックの壊れ方を自分なりに観察してみましたが、大まかには以下のように捉えることができると思います。
 4つのかけらに分かれる かけらのグラフィックは斜めになっている 上のかけらと下のかけらは違う角度で飛んでいる  スプライトを4つのかけらに分ける この表現に対しては、元のスプライトを部分的に描画した4つの新たなスプライトを作ることにしました。
_marioLike: function(sprite) { // 縦横の分割数  var divX = 2; var divY = 2; var image = sprite.image.domElement; // 分割サイズ  var sizeX = sprite.width / divX; var sizeY = sprite.height / divY; // グリッド  var grid = phina.util.Grid(sprite.width, divX); var srcRect = sprite.srcRect; // 分割スプライト作成  (divX * divY).times(function(i) { // インデックス位置設定  var xIndex = i % divX; var yIndex = (i / divX).</description>
    </item>
    
    <item>
      <title>【phina.js】反射ベクトルを使った反射処理</title>
      <link>https://alkn203.github.io/blog/2019/09/01/phina-reflect/</link>
      <pubDate>Sun, 01 Sep 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2019/09/01/phina-reflect/</guid>
      <description>はじめに 反射処理の代表的なものといえば、ブロック崩しですが、ブロック崩しの場合、縦方向あるいは横方向の速度の向きを反転させるだけなので、比較的簡単です。
しかし、角度がついた壁に対して正確に反射させるにはそう単純にはいきません。この場合は、反射ベクトルというテクニックを使う必要があります。
実行サンプル(runstant)
Vecter2クラスのreflectメソッド  phina.jsのVector2クラスには、反射ベクトルを求めるreflectというメソッドが用意されています。 reflectメソッドは、入射ベクトルと壁の向きの法線ベクトルから反射ベクトルを求めて返します。  // 線分の法線ベクトル（正規化） var n = Vector2.normal(p1, p2).normalize(); // 反射ベクトル適用 var r = Vector2.reflect(this.circle.physical.velocity, n); サンプルコード phina.globalize(); // メインシーン phina.define(&amp;#39;MainScene&amp;#39;, { superClass: &amp;#39;DisplayScene&amp;#39;, // コンストラクタ  init: function() { // 親クラス初期化  this.superInit(); // 背景色  this.backgroundColor = &amp;#39;#444&amp;#39;; // canvas要素描画用  var elem = PlainElement({ width: this.gridX.width, height: this.gridY.width, }).addChildTo(this).setPosition(this.gridX.center(), this.gridY.center()); // canvasパラメータ指定  elem.canvas.context.strokeStyle = &amp;#39;white&amp;#39;; elem.canvas.context.lineWidth = 4; // 線分配列  this.</description>
    </item>
    
    <item>
      <title>【phina.js】マリオのような敵を踏みつぶすエフェクト</title>
      <link>https://alkn203.github.io/blog/2019/08/24/phina-stump-enemy/</link>
      <pubDate>Sat, 24 Aug 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2019/08/24/phina-stump-enemy/</guid>
      <description>はじめに マリオシリーズが代表するように、敵を上から踏みつけた時に敵が潰れるエフェクトはアクションゲームではもはや定番になっています。 今回は、敵が潰れるエフェクトをphina.jsで表現してみます。
サンプルコード(runstant)
オブジェクトのoriginを理解する  今回の目的を実現するためには、オブジェクトのoriginの変更を行う必要があります。 phina.jsのオブジェクトにはoriginというプロパティがあり、位置指定、回転、拡大縮小の時の基準となっています。 Vector2クラス形式となっており、デフォルトは(0.5, 0.5)でオブジェクトの中心になっています。  敵が潰れるエフェクト  敵が潰れるアニメーションは、tweenerを用います。 ScaleYの値を変化させて縦に縮小させます。  // 縦方向に縮小 bugbow.tweener.clear().to({scaleY: 0.1}, 200);  期待する結果としては下方向に潰れて欲しいところですが、今のままだと中心に向かって縮小され、思い通りの結果になりません。 これはoriginがオブジェクトの中心になっているのが原因です。  originの変更と位置の調整  下に縮小するようにするためには、originを(0.5, 1.0)に変更します。 変更したoriginがオブジェクトの位置の基準となるため、変更したoriginの分だけ上にずらして位置調整します。  // origin変更 bugbow.setOrigin(0.5, 1.0); // 位置調整 bugbow.y += bugbow.height / 2; // 縦方向に縮小 bugbow.tweener.clear().to({scaleY: 0.1}, 200); おわりに 実際には、敵が潰れたコマ画像を用意してフレームを切り替えた方が効率的かもしれません。今回の内容は、あくまでも１つのアプローチと考えてもらえればと思います。</description>
    </item>
    
    <item>
      <title>【phina.js】マップデータの読み込みにおける工夫</title>
      <link>https://alkn203.github.io/blog/2019/08/23/phina-mapdata/</link>
      <pubDate>Fri, 23 Aug 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2019/08/23/phina-mapdata/</guid>
      <description>はじめに ゲーム作りにおいてステージを作成する時、オブジェクトが少ない場合は１つ１つ位置を指定して追加していくこともできるでしょう。 でも、最終的には2次元配列でマップデータを作成して、プログラム内から読み込む方法などに落ち着くかと思います。
サンプルコード(runstant)
2次元配列のマップデータ 通常は、以下のようなデータを作成します。
// ステージデータ var STAGE = [&amp;#39;4&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;], [&amp;#39;4&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;], [&amp;#39;4&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;], [&amp;#39;4&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;], [&amp;#39;4&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;,&amp;#39;0&amp;#39;]];  配列ですので、それぞれの要素をシングルクオーテーションで囲む必要があり、データの修正などが結構面倒です。  マップデータを簡素化する  少し簡略化した以下の形式で読め込めるようにします。 1次元の配列になっており、コピーアンドペーストも楽です。  // ステージデータ var STAGE = [&amp;#39;4000000000&amp;#39;, &amp;#39;4000000000&amp;#39;, &amp;#39;4000000000&amp;#39;, &amp;#39;4000000000&amp;#39;, &amp;#39;4000000000&amp;#39;]; マップデータ読み込み処理  マップデータを読み込んでオブジェクトを配置する処理は、以下のとおりです。  // マップ作成 setStage: function(stage) { var half = GRID_SIZE / 2; var self = this; // マップデータをループ  stage.each(function(arr, j) { // 文字列を配列に変換  arr.toArray().each(function(id, i) { var x = self.gx.span(i) + half; var y = self.</description>
    </item>
    
    <item>
      <title>【phina.js】当たり判定について考える</title>
      <link>https://alkn203.github.io/blog/2019/08/17/phina-collision/</link>
      <pubDate>Sat, 17 Aug 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2019/08/17/phina-collision/</guid>
      <description>はじめに ゲーム作りにおいて、当たり判定ほど奥深く悩まされるものはないと言ってよいでしょう。
今回は、phina.jsにおける当たり判定のアプローチについての自分なりの考察です。
hitTestElementを使う  phina.app.Object2dを継承したクラスであれば、hitTestElementを使えば手軽に当たり判定ができます。 矩形同士での判定になりますので、一番手軽です。一方で、グラフィックが矩形より小さいと大雑把な判定になってしまうという欠点があります。   参考記事
[phina.js-Tips-41] 当たり判定を行う（矩形判定）
 Collisionを自前で用意する  【phina.js】2Dシューティングチュートリアル =第6回 当たり判定とアニメーションイベントとグループ=で自前で作ったようなCollisionクラスを使う方法です。 任意の位置やサイズに設定することができるので柔軟性があります。一方で、絶対座標と相対座標の関係に気を付けないと、正しい当たり判定ができないという欠点があります。   参考記事
[phina.js]Colliderアクセサリを作ってみた話
 当たり判定用のShapeを親にしてスプライトなどを子として追加する  RectangleShapeやCircleShapeを当たり判定の対象として、スプライトをその子要素として追加する方法です。 絶対座標で当たり判定ができるというメリットがあります。 Shapeをhideメソッドで隠すと子要素まで隠れてしまいますので、Shapeのコンストラクタでfillとstrokeを透明にすると見えないようにすることができます。  サンプルコード 当たり判定を行う（当たり判定用矩形にスプライト追加）(runstant)
// グローバルに展開 phina.globalize(); // アセット var ASSETS = { // 画像  image: { &amp;#39;tomapiko&amp;#39;: &amp;#39;https://cdn.jsdelivr.net/gh/phinajs/phina.js@develop/assets/images/tomapiko.png&amp;#39;, }, }; /* * メインシーン */ phina.define(&amp;#34;MainScene&amp;#34;, { // 継承  superClass: &amp;#39;DisplayScene&amp;#39;, // コンストラクタ  init: function() { // 親クラス初期化  this.</description>
    </item>
    
    <item>
      <title>【phina.js】2Dシューティングチュートリアル =第12回 エネミーのHP設定など=</title>
      <link>https://alkn203.github.io/blog/2019/07/03/phina-shooting-12/</link>
      <pubDate>Wed, 03 Jul 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2019/07/03/phina-shooting-12/</guid>
      <description>はじめに 前回は、ゲームのタイトルを作って、ゲーム開始と終了を実装しました。今回は、ゲームを面白くする要素として「敵のヒットポイント」と「弾の攻撃力」そして「敵ががダメージを受けた時のエフェクト」と「プレイヤーの無敵エフェクト」を実装します。
実行サンプル(runstant)
敵のHPとプレイヤーの攻撃力の実装 Enemyクラスに敵のHPを実装します。
/* * 敵クラス */ phina.define(&amp;#34;Enemy&amp;#34;, { // 継承  superClass: &amp;#39;SpaceShip&amp;#39;, // 初期化  init: function(param) { // 親クラス初期化  this.superInit({ speed: 3 }); // フレームアニメーション指定  this.anim.gotoAndPlay(&amp;#39;enemy&amp;#39;); // 当たり判定用矩形  this.collider = Collider({ width: 40, height: 40, }).addChildTo(this); // ヒットポイント  this.hp = (param &amp;amp;&amp;amp; param.hp !== undefined) ? param.hp : 1; 敵のHPはコンストラクタからパラメータで指定できるようにします。
次に、PlayerBulletクラスに弾の攻撃力を実装します。
phina.define(&amp;#34;PlayerBullet&amp;#34;, { // 継  superClass: &amp;#39;Sprite&amp;#39;, // 初期化  init: function() { // 親クラス初期化  this.</description>
    </item>
    
    <item>
      <title>【phina.js】Tweenerとupdateを使ってShapeの色を変化させる</title>
      <link>https://alkn203.github.io/blog/2019/07/02/phina-tweener-color/</link>
      <pubDate>Tue, 02 Jul 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2019/07/02/phina-tweener-color/</guid>
      <description>はじめに phina.jsのTweenerはキャラクターの動きをコントロールする場合などに使えるとても勉強な機能です。今回は、Tweenerとupdateを併用したTipsを紹介します。
Shapeの色変化アニメーション Shapeの色を一定時間で変化させるアニメーションを作ります。方法は以下のとおりです。
 Shapeにrgbの3つのプロパティを追加する。 Shapeのtweenerでプロパティの値を変化させる。 Shapeのupdateでプロパティの値を使って色を変化させる。  プロパティを追加する javascriptは、後から好きな時にプロパティを追加できる柔軟さを持ってますので、これを利用します。
// shape var shape = StarShape().addChildTo(this); shape.setPosition(this.gridX.center(), this.gridY.center()); shape.radius = 128; // プロパティ追加 shape.r = 0; shape.g = 0; shape.b = 0; プロパティ値を変化させる 追加したプロパティ値をtweenerで変化させます。
// プロパティ値変化 shape.tweener.to({r: 10, g: 100, b: 200}, 2000) .to({r: 200, g: 200, b: 10}, 2000) .setLoop(true).play(); 色を変化させる  updateでShapeの塗りつぶし色であるfillにプロパティ値を代入します。 rgbは文字列指定する必要があるため、formatメソッドの引数から渡しています。  // 毎フレーム処理 shape.update = function() { // 色指定  shape.fill = &amp;#39;rgb({0}, {1}, {2})&amp;#39;.</description>
    </item>
    
    <item>
      <title>【phina.js】タイマーゲージを作ってみた</title>
      <link>https://alkn203.github.io/blog/2019/07/01/phina-timergauge/</link>
      <pubDate>Mon, 01 Jul 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2019/07/01/phina-timergauge/</guid>
      <description>はじめに phina.jsには、体力ゲージの実装に使えるGaugeという便利なクラスが用意されています。今回、これをベースにゲームの制限時間表示によく見られるタイマーゲージを作ってみました。
実行サンプル  runボタンを押すとゲージが経過時間で減っていきます。 pauseボタンで一時停止。recoverボタンで全回復します。  TimerGaugeクラスの仕様 以下のように、シーンに追加します。
// タイマーゲージ  var gauge = phina.ui.TimerGauge({ limitTime: 30, }).addChildTo(this); gauge.setPosition(this.gridX.center(), this.gridY.center()); プロパティ・メソッド・イベント    プロパティ 説明     limitTime 制限時間(秒） デフォルト値60       メソッド 説明     run タイマー作動   pause 一時停止   recover ゲージを満タンにする       イベント 説明     onfull ゲージが満タンになった時   onempty ゲージが空になった時     その他のプロパティは、継承元のphina.</description>
    </item>
    
    <item>
      <title>【phina.js 】Webブラウザだけでhtml5ゲームを作成して公開する</title>
      <link>https://alkn203.github.io/blog/2019/06/29/quick-html5-game/</link>
      <pubDate>Sat, 29 Jun 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2019/06/29/quick-html5-game/</guid>
      <description>はじめに ゲームを作っている人なら、自分の作ったゲームを誰かに遊んでもらいたい気持ちは皆持っていると思います。今では、スマホアプリを作ってプラットフォームで公開する方法がメジャーですが、初心者にとってはそう簡単にはいかないものです。 中には、アプリ化まではいかないけど何かゲームを作って公開してみたいと思っている人もいるでしょう。そのようなときは、javascriptでhtml5ゲームを作って、Webで公開することをおすすめします。（もちろんhtml5ゲームをアプリ化する方法もあります）
Webブラウザだけでゲームを作成して公開する 今回は、特別な環境構築をせずに、Webブラウザだけを使ってhtml5ゲームを公開する方法を紹介します。大まかな流れは以下のとおりです。
 runstantでコーティングする runstantプロジェクトをhtmlファイルとしてダウンロードする GitHubにゲーム公開用のリポジトリを作る htmlファイルをGitHubのリポジトリにアップロードする GitHubのリポジトリの設定でGitHub Pagesを有効にする  それでは、順番に説明していきます。
runstantでコーティングする runstantは、phina.jsの生みの親であるphiさんが開発したWebブラウザ上で動くオンラインエディタで、ユーザー登録すれば誰でも利用することができます。 phina.jsの公式エディタでもあり、実際に様々なプログラムが作られて公開されています。
phina.jsのひな形からゲームを作成 これまでも触れていますが、普段私が使っているphina.jsのひな形から作ることで、簡単に始められます。
今回作ったゲーム サンプルとして、制限時間内にどれだけ円をタッチできるかを競う単純なゲームを作りました。
Touch The Circle(runstant)
runstantプロジェクトをhtmlファイルとしてダウンロードする ゲームを作ったら、Webに公開するファイルの準備をする必要がありますが、runstantの便利な機能として、プロジェクトのダウンロードがあります。 ダウンロードされたファイルはhtml形式でjavascriptのコード部分もパッケージ化されているので、このファイル１つあればゲームとして動作します。
プロジェクトのダウンロード方法  runstantの画面下部にあるボタンをクリックすると、プロジェクトのダウンロードができます。ダウンロード先は任意の場所にして、ファイル名をindex.htmlに変更して下さい。  GitHubにゲーム公開用のリポジトリを作る GitHubは、プログラマなら誰もが知るようになりつつある、主にソースコードのバージョン管理を目的としたサービスです。 今回は、このGitHubをゲームの公開用サーバとして利用します。
ユーザー登録を行ったら、ゲーム公開用のリポジトリを作成します。
 ユーザーホーム画面で「New」ボタンをクリックします。   作成画面でリポジトリ名を入力します。 公開範囲が「Public」になっているのを確認します。 「リポジトリをREAD ME で初期化」にチェックを入れます。 「Create repository」ボタンをクリックします。  htmlファイルをGitHubのリポジトリにアップロードする リポジトリの用意が出来たら、runstantからダウンロードしたhtmlファイルをリポジトリにアップロードします。GitHubは、ローカル環境からgitのコマンドを駆使して使うイメージがありますが、GitHub上のGUI操作でもファイルのアップロード程度はできます。
 「Upload files」ボタンをクリックします。   上の領域にダウンロードしたhtmlファイルをドラッグするか、ファイル選択ダイアログでファイルを選択します。 「Commit Changes」ボタンをクリックします。   ファイルがアップロードされたのを確認します。  GitHubのリポジトリの設定でGitHub Pagesを有効にする  上部メニューから「Setting」をクリックします。   「github pages」を有効にします。以前は、git でgh-pages名でブランチを切って、pushする必要がありましたが、現在は不要になっています。   上部に表示される アドレスが公開先のアドレスになります。 反映されるまでには、少し時間がかかる場合もあるようです。  公開先 Touch The Circle</description>
    </item>
    
    <item>
      <title>【phina.js】2Dシューティングチュートリアル =第11回 タイトルをつける=</title>
      <link>https://alkn203.github.io/blog/2019/06/28/phina-shooting-11/</link>
      <pubDate>Fri, 28 Jun 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2019/06/28/phina-shooting-11/</guid>
      <description>はじめに 前回は、プレイヤーが画面外に出ないように移動に制限をかけました。今回は、タイトル画面を追加します。
独自のタイトル画面の作成 Unityのチュートリアルでは、タイトル文字を非表示にすることでタイトル画面とゲーム画面の区別を行っています。これも一つの手法ですが、今回は、phina.jsで元々用意されているタイトル画面を上書きする方法にします。
TitleSceneの上書き  MainSceneを流用して、TitleSceneと同じ名前で新たにクラスを作ることで、元々のシーンが上書きされます。 コード的にはダブりもありますが、シーン毎に切り離して管理できるのがメリットです。  /* * タイトルシーン */ phina.define(&amp;#34;TitleScene&amp;#34;, { // 継承  superClass: &amp;#39;DisplayScene&amp;#39;, // 初期化  init: function() { // 親クラス初期化  this.superInit(); // グループ  this.bgGroup = DisplayElement().addChildTo(this); this.bg2Group = DisplayElement().addChildTo(this); // グリッド  var gx = this.gridX; var gy = this.gridY; // 背景  this.createBackground(); // タイトルラベル  var title = Label({ text: &amp;#39;Shooting Game&amp;#39;, fill: &amp;#39;white&amp;#39;, stroke: &amp;#39;yellow&amp;#39;, fontSize: 72, }).</description>
    </item>
    
    <item>
      <title>【phina.js】2Dシューティングチュートリアル =第10回 プレイヤーの移動制限=</title>
      <link>https://alkn203.github.io/blog/2019/06/27/phina-shooting-10/</link>
      <pubDate>Thu, 27 Jun 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2019/06/27/phina-shooting-10/</guid>
      <description>はじめに 前回は、敵の波状攻撃を実装しました。今回は、ゲームにサウンドをつけます。
サウンド素材の読み込み 画像と同じようにアセットとして読み込みます。
// サウンド  sound: { &amp;#39;bgm&amp;#39;: &amp;#39;https://cdn.jsdelivr.net/gh/alkn203/phina-shooting-tutorial@master/work/assets/game_maoudamashii_4_vehicle03.mp3&amp;#39;, &amp;#39;shot&amp;#39;: &amp;#39;https://cdn.jsdelivr.net/gh/alkn203/phina-shooting-tutorial@master/work/assets/se_maoudamashii_battle_gun05.mp3&amp;#39;, &amp;#39;explosion&amp;#39;: &amp;#39;https://cdn.jsdelivr.net/gh/alkn203/phina-shooting-tutorial@master/work/assets/se_maoudamashii_explosion06.mp3&amp;#39;, },  サウンド素材は魔王魂から拝借しました。
 BGMをつける  phina.jsでサウンドを扱うには、SoundManagerクラスを使用します。 BGMのようにループするサウンドの場合は、playMusicメソッドを使います。 デフォルトでは、ループする設定になってます。 メインシーンのコンストラクタなど好きな場所に追加して下さい。  // BGM再生  SoundManager.playMusic(&amp;#39;bgm&amp;#39;); プレイヤーにショット音をつける  ショット音は一回毎に再生する必要がありますので、playメソッドを使います。 弾生成と同時に音を再生するようにPlayerBulletクラスのコンストラクに処理を追加しています。  /* * プレイヤーの弾クラス */ phina.define(&amp;#34;PlayerBullet&amp;#34;, { // 継  superClass: &amp;#39;Sprite&amp;#39;, // 初期化  init: function() { // 親クラス初期化  this.superInit(&amp;#39;bullet&amp;#39;, 64, 64); // スピード  var speed = 10; // 当たり判定用のコライダー  this.collider = Collider({ width: 10, height: 30, }).</description>
    </item>
    
    <item>
      <title>【phina.js】2Dシューティングチュートリアル =第9回 音をつける=</title>
      <link>https://alkn203.github.io/blog/2019/06/27/phina-shooting-09/</link>
      <pubDate>Thu, 27 Jun 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2019/06/27/phina-shooting-09/</guid>
      <description>はじめに 前回は、敵の波状攻撃を実装しました。今回は、ゲームにサウンドをつけます。
サウンド素材の読み込み 画像と同じようにアセットとして読み込みます。
// サウンド  sound: { &amp;#39;bgm&amp;#39;: &amp;#39;https://cdn.jsdelivr.net/gh/alkn203/phina-shooting-tutorial@master/work/assets/game_maoudamashii_4_vehicle03.mp3&amp;#39;, &amp;#39;shot&amp;#39;: &amp;#39;https://cdn.jsdelivr.net/gh/alkn203/phina-shooting-tutorial@master/work/assets/se_maoudamashii_battle_gun05.mp3&amp;#39;, &amp;#39;explosion&amp;#39;: &amp;#39;https://cdn.jsdelivr.net/gh/alkn203/phina-shooting-tutorial@master/work/assets/se_maoudamashii_explosion06.mp3&amp;#39;, },  サウンド素材は魔王魂から拝借しました。
 BGMをつける  phina.jsでサウンドを扱うには、SoundManagerクラスを使用します。 BGMのようにループするサウンドの場合は、playMusicメソッドを使います。 デフォルトでは、ループする設定になってます。 メインシーンのコンストラクタなど好きな場所に追加して下さい。  // BGM再生  SoundManager.playMusic(&amp;#39;bgm&amp;#39;); プレイヤーにショット音をつける  ショット音は一回毎に再生する必要がありますので、playメソッドを使います。 弾生成と同時に音を再生するようにPlayerBulletクラスのコンストラクに処理を追加しています。  /* * プレイヤーの弾クラス */ phina.define(&amp;#34;PlayerBullet&amp;#34;, { // 継  superClass: &amp;#39;Sprite&amp;#39;, // 初期化  init: function() { // 親クラス初期化  this.superInit(&amp;#39;bullet&amp;#39;, 64, 64); // スピード  var speed = 10; // 当たり判定用のコライダー  this.collider = Collider({ width: 10, height: 30, }).</description>
    </item>
    
    <item>
      <title>【phina.js】2Dシューティングチュートリアル =第8回 敵の波状攻撃=</title>
      <link>https://alkn203.github.io/blog/2019/06/26/phina-shooting-08/</link>
      <pubDate>Wed, 26 Jun 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2019/06/26/phina-shooting-08/</guid>
      <description>はじめに 前回は、背景を追加しました。今回は、敵の波状攻撃を実装します。
WaveとEmitter UnityのチュートリアルにあるWave型とEmitterという仕組み自体は、phina.jsにはありませんので、似せた処理を作ります。
Wave機能の実現 UnityのWave型を参考にして、以下の仕様にします。
 敵をフォーメーションで出現させる。 敵が全て倒されるか、画面外に出たら1に戻る。  クラスにしても良いのですが、親子関係の複雑化を避けるために、今回は関数を作ります。
createWave関数 // Wave作成  createWave: function() { // 敵3機フォーメーション  [[0, -2], [-2, -4], [2, -4]].each(function(arr) { var enemy = Enemy().addChildTo(this.waveGroup); enemy.setPosition(this.gridX.center(arr[0]), this.gridY.span(arr[1])); }, this); },  これまで敵はenemyGroupに追加してきましたが、新たにwaveGroupに追加します。 敵のフォーメーション情報を配列に入れて、ループでアクセスして敵を配置しています。  checkWave関数 // Waveの状態チェック  checkWave: function() { // 敵がいなくなったら出現させる  if (this.waveGroup.children.length === 0) { this.createWave(); } },  updateでこの関数を呼び出し、敵の状態をチェックします。 全ての敵が画面外に出るか、プレイヤーに倒されたらcreateWaveを呼び出して敵を出現させます。  敵が画面外で弾を撃たないようにする 敵の波状攻撃は実装できましたが、このままだと画面外にいる時から弾を発射できてしまいますので、画面に現れてから弾の発射を開始するように調整します。
// 一定間隔で弾を発射  this.tweener.clear() .call(function() { this.</description>
    </item>
    
    <item>
      <title>【phina.js】2Dシューティングチュートリアル =第7回 背景を追加する=</title>
      <link>https://alkn203.github.io/blog/2019/06/25/phina-shooting-07/</link>
      <pubDate>Tue, 25 Jun 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2019/06/25/phina-shooting-07/</guid>
      <description>はじめに 前回は、当たり判定を追加しました。今回は、背景を作成します。
背景画像を追加する  背景画像をスプライトとして追加します。画像は2種類にしてスクロール速度を変えて奥行き感を表現します。 背景をループしてスクロールできるように、それぞれ同じ画像を2つ縦に繋げて並べます。画像はグループに追加して管理します。 背景画像は、画面の縦サイズより少し大きめにすることで、スクロールさせる時の画像の移動をより自然に見せることができます。  // グループ  this.bgGroup = DisplayElement().addChildTo(this); this.bg2Group = DisplayElement().addChildTo(this); // 背景作成  createBackground: function() { var bgGroup = this.bgGroup; var bg2Group = this.bg2Group; (2).times(function(i) { // 一番下の背景  var bg = Sprite(&amp;#39;bg&amp;#39;).addChildTo(bgGroup); bg.setPosition(this.gridX.center(), this.gridY.center()); // 上の背景  var bg2 = Sprite(&amp;#39;bg2&amp;#39;).addChildTo(bg2Group); bg2.setPosition(this.gridX.center(), this.gridY.center()); // スクロールスピード  bg.physical.velocity.y = 2; bg2.physical.velocity.y = 4; }, this); // それぞれ2つの背景を縦に繋げる  bgGroup.children.last.bottom = bgGroup.children.first.top; bg2Group.children.last.bottom = bg2Group.</description>
    </item>
    
    <item>
      <title>【phina.js】2Dシューティングチュートリアル =第6回 当たり判定とアニメーションイベントとグループ=</title>
      <link>https://alkn203.github.io/blog/2019/06/24/phina-shooting-06/</link>
      <pubDate>Mon, 24 Jun 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2019/06/24/phina-shooting-06/</guid>
      <description>はじめに 前回は、敵を追加して敵が弾を発射するようにしました。今回は、当たり判定を作成します。
Colliderクラスを作成する Unityでは、コライダーという当たり判定を行うためのコンポーネントが用意されていますが、phina.jsにはありません。そこで、それに似た機能を持たせたColliderというクラスを作りました。
/* * コライダークラス */ phina.define(&amp;#34;Collider&amp;#34;, { // 継承  superClass: &amp;#39;RectangleShape&amp;#39;, // 初期化  init: function(param) { // 親クラス初期化  this.superInit({ width: param.width, height: param.height, fill: null, stroke: &amp;#39;red&amp;#39;, }); }, // コライダーの絶対座標の矩形  getAbsoluteRect: function() { var x = this.left + this.parent.x; var y = this.top + this.parent.y; return Rect(x, y, this.width, this.height); }, });  今回は簡易な矩形での当たり判定を行うので、RentangleShapeクラスを継承しています。 コライダーは子要素として追加するため、コライダー自体の座標は相対座標値になることから、親の座標を元に絶対座標値の矩形を計算して返す関数を用意します。  仕様変更 これまでプレイヤーと敵の弾は、空のクラスに一旦追加する形にしていましたが、当たり判定における親子関係を出来るだけシンプルにするために、shot関数の中で直接生成する形に変更しました。
当たり判定を付ける プレイヤー プレイヤークラスでコライダーを以下のように追加します。
/* * プレイヤークラス */ phina.</description>
    </item>
    
    <item>
      <title>【phina.js】2Dシューティングチュートリアル =第5回 敵を作成する=</title>
      <link>https://alkn203.github.io/blog/2019/06/23/phina-shooting-05/</link>
      <pubDate>Sun, 23 Jun 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2019/06/23/phina-shooting-05/</guid>
      <description>はじめに 前回は、プレイヤーから弾が発射できるようにしました。今回は、敵を作成します。
共通部分のクラス化 前回作ったプレイヤークラスと今回作成する敵クラスでは、共通化できる部分があります。その部分をSpaceShipクラスとして別クラスで作成し、使い回しが出来るようにします。
SpaceShipクラス /* * スペースシップクラス */ phina.define(&amp;#34;SpaceShip&amp;#34;, { // 継承  superClass: &amp;#39;Sprite&amp;#39;, // 初期化  init: function(param) { // 親クラス初期化  this.superInit(&amp;#39;spaceship&amp;#39;, 64, 64); // フレームアニメーションをアタッチ  this.anim = FrameAnimation(&amp;#39;spaceship&amp;#39;).attachTo(this); // 移動スピード  this.speed = param.speed; }, // 機体の移動  move: function(direction) { this.moveBy(direction.x * this.speed, direction.y * this.speed); }, });  プレイヤークラスと敵クラスがこのクラスを継承できるようにします。 スプライトとフレームアニメーションは、同じファイルを使っていますので共通化できます。 移動スピードは、外から指定出来るようにしています。 移動処理も関数に方向を代入することで処理ができるようにしています。  プレイヤークラスから継承する 設計変更で、プレイヤークラスのコンストラクは以下のようになります。
/* * プレイヤークラス */ phina.define(&amp;#34;Player&amp;#34;, { // 継承  superClass: &amp;#39;SpaceShip&amp;#39;, // 初期化  init: function() { // 親クラス初期化  this.</description>
    </item>
    
    <item>
      <title>【phina.js】2Dシューティングチュートリアル =第4回 プレイヤーから弾を撃つ=</title>
      <link>https://alkn203.github.io/blog/2019/06/22/phina-shooting-04/</link>
      <pubDate>Sat, 22 Jun 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2019/06/22/phina-shooting-04/</guid>
      <description>はじめに 前回は、プレイヤーをキーボードで移動させるところまで出来ました。 今回は、プレイヤーが自動で弾を連射するようにします。
親子関係  Unityでは、オブジェクトの「親子関係」という言葉を使いますが、phina.jsでも同じような関係を持たせることができます。 親子関係になると、親が移動・回転を行えば、追従して子も同じように移動・回転します。  子要素として追加する方法 例えば、obj1をobj2の子要素として追加したい場合、以下のように書きます。
obj1.addChildTo(obj2); プレイヤーの弾を作成する プレイヤーの弾を表示するだけなら、以下のようにスプライトとしてシーンに追加すればOKです。
// プレイヤーの弾 Sprite(&amp;#39;bullet&amp;#39;, 64, 64).addChildTo(this).setPosition(this.gridX.center(), this.gridY.center()); ここまでの実行サンプル プレイヤーの弾表示(runstant)
プレイヤーの弾を動かす ゲームを実行したら勝手に上に飛んで行く弾を作成します。
親となるPlayerBulletの作成 Unityのチュートリアルでは空のゲームオブジェクトを作成していますが、phina.jsではDisplayElementというクラスにその役割をさせることができます。
PlayerBulletクラス プレイヤーの弾として、DisplayElementを継承した以下のクラスを作成しました。
/* * プレイヤーの弾クラス */ phina.define(&amp;#34;PlayerBullet&amp;#34;, { // 継  superClass: &amp;#39;DisplayElement&amp;#39;, // 初期化  init: function() { // 親クラス初期化  this.superInit(); // スピード  var speed = 10; var self = this; // 左右の弾  [-10, 10].each(function(dx) { Sprite(&amp;#39;bullet&amp;#39;, 64, 64).addChildTo(self).setPosition(self.x + dx, self.</description>
    </item>
    
    <item>
      <title>【phina.js】2Dシューティングチュートリアル =第3回 プレイヤーの移動=</title>
      <link>https://alkn203.github.io/blog/2019/06/21/phina-shooting-03/</link>
      <pubDate>Fri, 21 Jun 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2019/06/21/phina-shooting-03/</guid>
      <description>はじめに 前回は、ゲームで使うアセットの読み込みまで行いました。今回は、プレイヤーをキーボードで操作できるようにします。
プレイヤーの移動 Unityでは、コードを実行する場合、ゲームオブジェクトにスクリプトをアタッチする方法をとりますが、phina.jsでは、オブジェクト専用のクラスを作成する方法が一般的です。
プレイヤークラス 今回は、プレイヤークラスを以下のとおり実装しました。
/* * プレイヤークラス */ phina.define(&amp;#34;Player&amp;#34;, { // 継承  superClass: &amp;#39;Sprite&amp;#39;, // 初期化  init: function() { // 親クラス初期化  this.superInit(&amp;#39;spaceship&amp;#39;, 64, 64); // フレームアニメーションをアタッチ  FrameAnimation(&amp;#39;spaceship&amp;#39;).attachTo(this).gotoAndPlay(&amp;#39;player&amp;#39;); // 移動スピード  this.speed = 5; }, // 毎フレーム更新処理  update: function(app) { // 移動する向きを求める  var direction = app.keyboard.getKeyDirection(); // 移動する向きとスピードを代入する  this.moveBy(direction.x * this.speed, direction.y * this.speed); }, }); クラス宣言 phina.define(&amp;#34;Player&amp;#34;, { // 継承  superClass: &amp;#39;Sprite&amp;#39;,  クラス宣言は、defineで行います。次の文字列はクラス名です。 superClassで継承元の親クラスを指定します。自機はスプライト画像を使うので、親クラスにSpriteクラスを指定しています。  init関数 一般的にコンストラクと呼ばれるもので、UnityにおけるStartと同じ役割です。</description>
    </item>
    
    <item>
      <title>【phina.js】2Dシューティングチュートリアル =第2回 スプライトとフレームアニメーション=</title>
      <link>https://alkn203.github.io/blog/2019/06/20/phina-shooting-02/</link>
      <pubDate>Thu, 20 Jun 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2019/06/20/phina-shooting-02/</guid>
      <description>はじめに 前回は、phina.jsにおけるコーディングの準備までを書きました。今回から具体的にチュートリアルを進めていきます。
テクスチャからスプライトを作成する Unityでは内臓のスプライトエディタで作成しますが、phina.jsではアセットとして別に用意した画像ファイルを読み込みます。
用意した画像 プレイヤーと敵 プレイヤーと敵の弾 爆発  これらの画像は、一般的にスプライトシートと呼ばれており同じサイズの画像を複数枚タイル状に並べたものです。 一枚当たりのサイズを指定して切り出すことで、好きなコマ画像を表示したり、フレームアニメーションと言われるコマ送りの動画を表現することができます。  自機と敵のアニメーション 以下ようなアニメーションを作成します。
フレームアニメーション定義ファイルの作成  フレームアニメーションは、少ないコマ数であればコード中でフレームインデックスを指定して表現することもできますが、アニメーションの種類が増えると複雑になりがちです phina.jsではフレームアニメーション定義ファイルを作成してアセットとして読み込むことで、簡単にアニメーションを行うことができます。  自機と敵の定義ファイル { &amp;#34;frame&amp;#34;: { &amp;#34;width&amp;#34;: 64, &amp;#34;height&amp;#34;: 64, &amp;#34;cols&amp;#34;: 4, &amp;#34;rows&amp;#34;: 4 }, &amp;#34;animations&amp;#34; : { &amp;#34;player&amp;#34;: { &amp;#34;frames&amp;#34;: [0,1,2,3,2,1], &amp;#34;next&amp;#34;: &amp;#34;player&amp;#34;, &amp;#34;frequency&amp;#34;: 1 }, &amp;#34;enemy&amp;#34;: { &amp;#34;frames&amp;#34;: [4,5,6,7,6,5], &amp;#34;next&amp;#34;: &amp;#34;enemy&amp;#34;, &amp;#34;frequency&amp;#34;: 1 } } } 定義ファイルはjson形式で作成します。
 frameのwidthとheightは、１コマ毎に画像を切り出すサイズで、今回は64x64としています。 colsは横、rowは縦の画像のコマ数で、4x4の合計16コマであることが分かります。 animationsで個別のアニメーションを定義します。 playerはアニメーション名で、任意の名前を設定することができます。 framesで何番目のコマを使うかを配列形式で指定します。自機の画像は4コマ目までなので、今回は0→1→2→3→2→1と順番に切り替えてアニメーションさせます。敵の画像は5から8コマ目なので、同様に指定しています。配列なのでインデックスは0から始まります。 nextで次のアニメーションを指定します。同じアニメーション名を指定すると、ループします。 frequencyはアニメーションの間隔で、小さければ速くなり、大きければ遅くなります。  爆発アニメーションの定義ファイル 以下のようなアニメーションを作成します。
{ &amp;#34;frame&amp;#34;: { &amp;#34;width&amp;#34;: 64, &amp;#34;height&amp;#34;: 64, &amp;#34;cols&amp;#34;: 10, &amp;#34;rows&amp;#34;: 1 }, &amp;#34;animations&amp;#34; : { &amp;#34;explosion&amp;#34;: { &amp;#34;frames&amp;#34;: [0,1,2,3,4,5,6,7,8,9], &amp;#34;frequency&amp;#34;: 1 } } } 自機と敵の場合と違う点は、animationsのnextを指定していないところです。理由は、爆発アニメーションは1回限りで良いからです。</description>
    </item>
    
    <item>
      <title>【phina.js】2Dシューティングチュートリアル =第1回 プログラミングの準備=</title>
      <link>https://alkn203.github.io/blog/2019/06/19/phina-shooting-01/</link>
      <pubDate>Wed, 19 Jun 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2019/06/19/phina-shooting-01/</guid>
      <description>プログラミングの準備 今回のチュートリアルでは、phina.jsの公式オンラインエディタの位置付けであるRunstantを使用します。
ひな形 私が普段使っている以下のひな形から作成します。
// グローバルに展開 phina.globalize(); /* * メインシーン */ phina.define(&amp;#34;MainScene&amp;#34;, { // 継承  superClass: &amp;#39;DisplayScene&amp;#39;, // 初期化  init: function() { // 親クラス初期化  this.superInit(); // 背景色  this.backgroundColor = &amp;#39;black&amp;#39;; // 以下にコードを書いていく  }, // 毎フレーム更新処理  update: function() { // 以下にコードを書いていく  }, }); /* * メイン処理 */ phina.main(function() { // アプリケーションを生成  var app = GameApp({ // MainScene から開始  startLabel: &amp;#39;main&amp;#39;, }); // fps表示  //app.</description>
    </item>
    
    <item>
      <title>【phina.js】バブルソートを視覚化してみた</title>
      <link>https://alkn203.github.io/blog/2019/06/16/phina-bubblesort/</link>
      <pubDate>Sun, 16 Jun 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2019/06/16/phina-bubblesort/</guid>
      <description>バブルソートとは プログラミングを習うと必ずと言って良いほど、最初に出てくるソートアルゴリズムです。 今回のコードは、phina.jsでそれを視覚化してみたものです。 要素が入れ替わる様子が何となく分かるかと思います。
実行サンプル コード バブルソート視覚化(runstant)
参考にしたサイト バブルソート</description>
    </item>
    
    <item>
      <title>このブログについて</title>
      <link>https://alkn203.github.io/blog/about/</link>
      <pubDate>Sun, 16 Jun 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/about/</guid>
      <description>このブログについて 当ブログは、趣味でプログラミングをしている管理人がjavascriptのゲームライブラリphina.jsに関するTipsなどを通して、ゲームプログラミングの楽しさを伝えることを目的としています。
掲載されているコードについて 当ブログの記事に掲載されているコードはの取り扱いについては、個別に記述がない限り、特に使用制限はありません。記事中にリンクしているrunstantプロジェクトについても同様です。 当ブログに掲載されているコードをご自身のブログなどで引用された場合は、当ブログへリンクをして頂ければ嬉しいです。
免責事項 当ブログに掲載された内容および当ブログからのリンク先への移動によって発生した損害等の一切の責任は、当ブログでは負いかねますので、ご了承ください。
改訂履歴 2019年6月18日　作成</description>
    </item>
    
    <item>
      <title>【phina.js】色々なスクロールを試す</title>
      <link>https://alkn203.github.io/blog/2019/06/15/phina-various-scroll/</link>
      <pubDate>Sat, 15 Jun 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2019/06/15/phina-various-scroll/</guid>
      <description>はじめに 横スクロールアクションゲームでは、画面のスクロール処理が欠かせませんが、スクロール１つでも結構奥が深いです。今回はphina.jsで主だったスクロール処理を実装してみました。
プレイヤー固定スクロール まずは以下のサンプルを確認してみて下さい。 プレイヤーの位置は画面の中心固定で画面がスクロールします。画面タッチでプレイヤーがジャンプして、障害物に当たると反転移動します。 中心には分かりやすいようにラインを表示しています。
runstantで確認
このパターンのスクロールは、特に難しい実装はないかと思います。 プレイヤーは動かさずに固定して、プレイヤー以外のオブジェクトをプレイヤーの移動方向と逆向きに動かすことで、プレイヤーが移動しているように見えます。
// 画面スクロール moveX: function() { var self = this; this.objectGroup.children.each(function(obj) { obj.x += -self.player.vx; }); }, 変則スクロール 始めは固定スクロールと同じようにスクロールしますが、ステージの端に行くとスクロールが止まります。 そして、画面中央を超えると再びスクロールします。
runstantで確認
このパターンのスクロールのポイントは、プレイヤー以外のオブジェクトの移動とプレイヤーのみの移動の切り替えです。 プレイヤーの横方向の状態をチェックする関数を用意して、その中で切り替えを行います。
// 横方向の状態チェック  checkHorizontalState: function() { var player = this.player; var state = this.player.horizontalState; // 左端のオブジェクト  var first = this.objectGroup.children.first; // 右端のオブジェクト  var last = this.objectGroup.children.last; // プレイヤーの状態で分ける  switch (state) { // 左移動中  case &amp;#39;MOVING_LEFT&amp;#39;: // ヒットしたら反転  if (this.</description>
    </item>
    
    <item>
      <title>【phina.js】パスに沿ったオブジェクト移動</title>
      <link>https://alkn203.github.io/blog/2019/06/14/phina-movealongpath/</link>
      <pubDate>Fri, 14 Jun 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2019/06/14/phina-movealongpath/</guid>
      <description>パスに沿ったオブジェクトの移動 ゲームを作成していると、動く床などのように一定のルートに従ってオブジェクトを移動させたい時があると思います。 phina.jsを使って、自分なりにその処理を実装してみました。
動作サンプル まずは以下のサンプルをご覧下さい。線に沿ってオブジェクトが移動します。
runstantで確認
 オブジェクトの移動には、非同期処理が行えるtweenerを利用します。 tweenerの内部処理で使われている**_add**関数で処理をスタックさせています。 tweenerは、基本的にスタックされた順に非同期処理されるので、次の移動先である各頂点の位置を順番に与えることで、結果としてパスに沿った移動が可能になります。  課題  今回のサンプルでは、移動速度が一定になるように各頂点の距離が同一になるように配置しています。 一定の時間で移動させるのがtweenerの処理ですので、距離が変わると移動速度も変わることになります。 各頂点の距離に応じてdurationを変えると速度を一定にすることが可能になると思われますが、その辺は次回の課題にしたいと思います。  </description>
    </item>
    
    <item>
      <title>【phina.js】上方向だけすり抜ける床を作る</title>
      <link>https://alkn203.github.io/blog/2019/06/13/phina-up-direction/</link>
      <pubDate>Thu, 13 Jun 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2019/06/13/phina-up-direction/</guid>
      <description>上方向だけすり抜ける床  ジャンプゲームなどでは、上方向にすり抜け下方向にはすり抜けない床がよくあります。 今回は基本的なジャンプ処理とともに、phina.jsを使って自分なりに実装してみました。  動作サンプル まずは以下のサンプルを確認して下さい。 画面タッチでキャラがジャンプしますが、上方向にはブロックをすり抜けて、その後に下のブロックに着地します。
runstantで確認
プレイヤーとブロックの作成 プレイヤーとブロックは、それぞれSpriteクラスを継承して作成しました。
// プレイヤークラス phina.define(&amp;#39;Player&amp;#39;, { superClass: &amp;#39;Sprite&amp;#39;, // コンストラクタ  init: function() { // 親クラス初期化  this.superInit(&amp;#39;tomapiko&amp;#39;, SPRITE_SIZE, SPRITE_SIZE); // フレームアニメーションをアタッチ  this.anim = FrameAnimation(&amp;#39;tomapiko_ss&amp;#39;).attachTo(this); // スプライトシートのサイズにフィットさせない  this.anim.fit = false; // 縦移動速度  this.vy = 0; // サイズ変更  this.setSize(CHARA_SIZE, CHARA_SIZE); },  デフォルトのスプライトサイズから半分のサイズにしています。 FrameAnimationクラスのプロパティfitをfalseにしないと、スプライトシートに書いている切り出しサイズが適用されるので注意して下さい。  // ブロッククラス phina.define(&amp;#39;Block&amp;#39;, { superClass: &amp;#39;Sprite&amp;#39;, // コンストラクタ  init: function() { // 親クラス初期化  this.</description>
    </item>
    
    <item>
      <title>【phina.js】シンプルなタイピングゲームを作ってみた</title>
      <link>https://alkn203.github.io/blog/2019/06/12/keywordshot/</link>
      <pubDate>Wed, 12 Jun 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2019/06/12/keywordshot/</guid>
      <description>はじめに phina.jsでシンプルなタイピングゲームを作ってみました。 私はあまりタイピングは得意な方ではないので、自分で作っておきながら途中でゲームオーバーになりますが、皆さんはいかがでしょうか。
別画面でプレイする
 画面左から飛んでくるhtmlやjavascriptに関するキーワードをタイプするだけのゲームです。 大文字小文字は区別しません。  改定 2019/5/18 ライフ制導入
カスタマイズ キーワード一覧は、以下のように改行区切りのテキストファイルからアセットとして読み込んでいますので、中身を変えれば 別言語のキーワードなどもイケると思います。
// アセット var ASSETS = { // キーワード一覧  text: { &amp;#39;keywords&amp;#39;: &amp;#39;https://cdn.jsdelivr.net/gh/alkn203/phina-games@master/keyword-shot/assets/keywords&amp;#39;, }, }; リファレンス キーワード一覧は、以下のサイトから引用させて頂きました。ありがとうございます。 JavaScriptのキーワードとか予約語をかき集めてみた - Born Neet</description>
    </item>
    
    <item>
      <title>phina.js事始め</title>
      <link>https://alkn203.github.io/blog/2019/06/11/about-phina/</link>
      <pubDate>Tue, 11 Jun 2019 20:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2019/06/11/about-phina/</guid>
      <description>（ロゴはphinajs.comから借用）
phina.jsについて 私が日々楽しんで使っているjavascriptのゲームライブラリで、tmlib.jsの後継のライブラリになります。現在開発はphina.jsの方にシフトしています。 とりあえずどのようなものか知るためには、以下の紹介記事辺りが参考になるかと思います。
 本日 JavaScript ゲームライブラリ『phina.js』をリリースしました! by @phi さん phina.js - JavaScriptで楽しく簡単にゲームが作れるライブラリ by @simiraaaa さん phina.jsの簡単さから基礎知識まで by @axion014 さん はじめてのphina.js – JavaScriptゲームライブラリを使ってみた！ by 株式会社LIG さん  気に入っているところ 以下は主観的ですが、他のユーザーも感じているのではないかと思います。
 同じ処理でもコード量が少なく済みます。全てのゲームライブラリと比較したわけではありませんが、phina.jsで書き慣れると、個人的には同様の処理を行う他のライブラリのコードが冗長に感じるようになりました。 ソースが読みやすいです。ソースの書き方を真似ることで、結果的に自分のコードも読みやすくなりました。 実行確認までのステップが短いです。Web上でコーディングできるrunstantを使うことで、環境構築の手間をかけずに自分のプログラムが確認できます。 他に、配列やベクトルなどのコーディングする上でベースとなるクラスの機能拡張が充実しているなどが挙げられます。  とにかく使ってみたい方へ  Githubのリポジトリに導入方法が記載されていますが、開発者向けの内容に近いので、私も含めて不慣れな方には少し敷居が高いかと思います。 一番簡単なのは、runstantへのユーザー登録が必要ですが、runstantに用意されたテンプレートをForkする方法です。  質問など phina.jsの魅力の一つに、親切なサポート体制があります。 Twitterで#phina_jsタグをつけて質問したり、slack(gitterから移行）に参加して質問すれば、作者の phiさんを始め、他のメンバーが優しく真剣に答えてくれます。些細なことでも良いので、構えずに質問してみて下さい。
Tipsなど どんなものか少しでも知ってもらうために、phina.js Tips集をよろしければご覧ください。
おわりに ゲームライブラリは実際に使ってみないとその良し悪しはわかりませんが、恵まれたことにphina.jsは、比較的簡単にトライすることができます。 javascriptでのゲーム開発に興味がある方は、是非一度触ってみて色々と試して頂ければと思います。</description>
    </item>
    
  </channel>
</rss>