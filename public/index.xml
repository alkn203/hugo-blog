<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Keep Coding</title>
    <link>https://alkn203.github.io/blog/</link>
    <description>Recent content on Keep Coding</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Sat, 31 Dec 2016 23:59:06 +0900</lastBuildDate>
    <atom:link href="https://alkn203.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>円と円の衝突運動プログラム</title>
      <link>https://alkn203.github.io/blog/2016/12/31/phina-circle-collision</link>
      <pubDate>Sat, 31 Dec 2016 23:59:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2016/12/31/phina-circle-collision</guid>
      <description>

&lt;h2 id=&#34;今回のサンプル&#34;&gt;今回のサンプル&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;phina.js&lt;/strong&gt;の作者&lt;a href=&#34;https://twitter.com/phi_jp&#34;&gt;phi&lt;/a&gt;さんの過去のブログ記事&lt;a href=&#34;http://tmlife.net/programming/javascript-tmlib-js-circle-collision.html&#34;&gt;[New] JavaScript ライブラリ tmlib.js で円同士の衝突プログラムを作ってみた&lt;/a&gt;を参考にして、円同士の衝突運動プログラムを作ってみました。
こういった動きは物理エンジンに頼っても良いと思いますが、一度自分で書いてみることで理解が深まります。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://alkn203.github.io/blog/images/phina-circle-collision.png&#34; alt=&#34;phina-circle-collision&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;h2 id=&#34;ソースコード&#34;&gt;ソースコード&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// グローバルに展開
phina.globalize();
// 定数
var REBOUND  = 0.8;    // 反発係数
var FRICTION = 0.99;   // 摩擦係数
var GRAVITY  = 0.8;    // 重力
var BALL_MAX_NUM = 15; // ボールの数
/*
 * メインシーン
 */
phina.define(&amp;quot;MainScene&amp;quot;, {
  // 継承
  superClass: &#39;DisplayScene&#39;,
  // 初期化
  init: function() {
    // 親クラス初期化
    this.superInit();
    // 背景色
    this.backgroundColor = &#39;black&#39;;
    // 画面の矩形
    var scrRect = Rect(0, 0, 640, 960);
    // ボールグループ
    var ballGroup = DisplayElement().addChildTo(this);
    var self = this;
    // ランダムな場所にボールを作成
    (BALL_MAX_NUM).times(function() {
      var rx = Random.randint(scrRect.left, scrRect.right);
      var ry = Random.randint(scrRect.top, scrRect.bottom);
      var ball = Ball().addChildTo(ballGroup).setPosition(rx, ry);
    });
    // 参照用
    this.ballGroup = ballGroup;
    this.scrRect = scrRect;
  },
  // 毎フレーム更新
  update: function() {
    // ボール同士
    this.checkHitBalls();
    // ボールと壁
    this.checkHitWalls();
  },
  // ボール同士の当たり判定処理
  checkHitBalls: function() {
    var balls = this.ballGroup.children;

    balls.each(function(ball, i) {
      balls.each(function(target, j) {
        // 自分以外の相手
        if (i !== j) {
          // 衝突してたら
          if (Collision.testCircleCircle(ball, target)) {
            // 自分から相手へのベクトル
            var abVec = Vector2.sub(target.position, ball.position);
            var len = abVec.length();
            if (len === 0) return;
            // 正規化
            abVec.normalize();
            // 自分と相手の距離
            var distance = (ball.radius + target.radius) - len;
            // めり込んだ量の半分
            var sinkVec = Vector2.mul(abVec, (distance / 2));
            // それぞれで押し出す
            ball.position.sub(sinkVec);
            target.position.add(sinkVec);
            // 反発ベクトルを求める
            var V = Vector2;
            var m0 = ball.m;
            var m1 = target.m;
            var e = REBOUND;
            var vs = ball.physical.velocity;
            var vo = target.physical.velocity;

            var ma = ((m1 / (m0 + m1)) * (1 + e)) * V.dot(V.sub(vo, vs), abVec);
            var mb = ((m0 / (m0 + m1)) * (1 + e)) * V.dot(V.sub(vs, vo), abVec);
       
            vs.add(V.mul(abVec, ma));
            vo.add(V.mul(abVec, mb));
          }
        }
      });    
    });
  },
  // タッチ終了時
  onpointend: function() {
    // ボールを散らす
    this.ballGroup.children.each(function(ball) {
      ball.physical.velocity.random(0, 360, 32);
    });
  },
  // ボールと壁との辺り判定
  checkHitWalls: function() {
    var balls = this.ballGroup.children;
    var rect = this.scrRect;
    
    balls.each(function(ball) {
      if (ball.top &amp;lt; rect.top) {
        ball.top = rect.top;
        ball.physical.velocity.y *= -1;
      }
      if (ball.bottom &amp;gt; rect.bottom) {
        ball.bottom = rect.bottom;
        ball.physical.velocity.y *= -1;
      }
      if (ball.left &amp;lt; rect.left) {
        ball.left = rect.left;
        ball.physical.velocity.x *= -1;
      }
      if (ball.right &amp;gt; rect.right) {
        ball.right = rect.right;
        ball.physical.velocity.x *= -1;
      }
    });
  },
});
/*
 * ボールクラス
 */
phina.define(&#39;Ball&#39;, {
  // CircleShapeを継承
  superClass: &#39;CircleShape&#39;,
  // コンストラクタ
  init: function() {
    // 親クラス初期化
    this.superInit({
      fill: null,
    });
    // 重力
    this.physical.gravity.set(0, GRAVITY);
    // 摩擦
    this.physical.friction = FRICTION;
    // 半径
    this.radius = Random.randint(25, 50);
    // 面積 = 質量にする
    this.m = Math.PI * this.radius * this.radius;
    // 初期移動量
    this.physical.velocity.random(0, 360, 32);
  },
});
/*
 * メイン処理
 */
phina.main(function() {
  // アプリケーションを生成
  var app = GameApp({
    // MainScene から開始
    startLabel: &#39;main&#39;,
  });
  // 実行
  app.run();
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/75048ec9&#34; target=&#34;_blank&#34;&gt;[runstantで確認]&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>クラス継承をしてみよう</title>
      <link>https://alkn203.github.io/blog/2016/12/23/phina-advent-23th</link>
      <pubDate>Fri, 23 Dec 2016 00:01:08 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2016/12/23/phina-advent-23th</guid>
      <description>

&lt;h2 id=&#34;はじめに&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;この記事は、&lt;a href=&#34;http://qiita.com/advent-calendar/2016/phinajs&#34;&gt;phina.js Advent Calendar 2016&lt;/a&gt; の23日目の記事です。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;22日目：&lt;a href=&#34;http://qiita.com/advent-calendar/2016/phinajs&#34;&gt;Three.jsとPhina.js使った何か by kjunichiさん&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;24日目：&lt;a href=&#34;http://qiita.com/emadurandal/items/63e262df75b279dda253&#34;&gt;phina.jsとGLBoostの連携について by emadurandalさん&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;クラス継承&#34;&gt;クラス継承&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;phina.js&lt;/strong&gt;を使い慣れてくると、&lt;strong&gt;既存のクラスに機能を追加&lt;/strong&gt;したいと思うことがあります。もちろんイチから作るのもありですが、ちょっとした機能追加であれば既存のクラスを継承したクラスを作った方が効率的です。今回は&lt;strong&gt;Button&lt;/strong&gt;クラスを例にその方法を説明します。&lt;/p&gt;

&lt;h2 id=&#34;animatebuttonクラスを作る&#34;&gt;AnimateButtonクラスを作る&lt;/h2&gt;

&lt;p&gt;現在の&lt;strong&gt;Button&lt;/strong&gt;クラスの仕様はシンプルで、最低限の機能しかありません。今回はこの&lt;strong&gt;Button&lt;/strong&gt;クラスを継承して&lt;strong&gt;AnimateButton&lt;/strong&gt;というクラスを新しく作りたいと思います。追加する仕様は単純で、&lt;strong&gt;「ボタンを押している間は縮小して押しているように見せる」&lt;/strong&gt;です。（下のボタンは画像なので押せません）&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://alkn203.github.io/blog/images/phina-advent-23th.png&#34; alt=&#34;phina-advent-23th&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;h3 id=&#34;手順１-buttonクラスのソースをコピーする&#34;&gt;手順１ Buttonクラスのソースをコピーする&lt;/h3&gt;

&lt;p&gt;本来であれば、&lt;strong&gt;ローカル環境にソースをダウンロード→エディタで編集→ビルド→テスト&lt;/strong&gt;というのが手順かもしれませんが、今回は簡単な継承例ということでソースを丸ごとコピーして、&lt;strong&gt;runstant&lt;/strong&gt;上で作業します。コピー場所はコードの冒頭にします。(phina.globalize()よりも前)&lt;/p&gt;

&lt;p&gt;以下が&lt;strong&gt;Button&lt;/strong&gt;クラスのソースです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/**
 * @class phina.ui.Button
 * Button
 */
phina.define(&#39;phina.ui.Button&#39;, {
  superClass: &#39;phina.display.Shape&#39;,
  /**
   * @constructor
   */
  init: function(options) {
    options = (options || {}).$safe(phina.ui.Button.defaults);
    this.superInit(options);

    this.cornerRadius = options.cornerRadius;
    this.text         = options.text;
    this.fontColor    = options.fontColor;
    this.fontSize     = options.fontSize;
    this.fontWeight     = options.fontWeight;
    this.fontFamily   = options.fontFamily;

    this.setInteractive(true);
    this.on(&#39;pointend&#39;, function() {
      this.flare(&#39;push&#39;);
    });
  },
  prerender: function(canvas) {
    canvas.roundRect(-this.width/2, -this.height/2, this.width, this.height, this.cornerRadius);
  },

  postrender: function(canvas) {
    var context = canvas.context;
    // text
    var font = &amp;quot;{fontWeight} {fontSize}px {fontFamily}&amp;quot;.format(this);
    context.font = font;
    context.textAlign = &#39;center&#39;;
    context.textBaseline = &#39;middle&#39;;
    context.fillStyle = this.fontColor;
    context.fillText(this.text, 0, 0);
  },

  _static: {
    defaults: {
      width: 200,
      height: 80,
      backgroundColor: &#39;transparent&#39;,
      fill: &#39;hsl(200, 80%, 60%)&#39;,
      stroke: null,

      cornerRadius: 8,
      text: &#39;Hello&#39;,
      fontColor: &#39;white&#39;,
      fontSize: 32,
      fontWeight: &#39;&#39;,
      fontFamily: &amp;quot;&#39;HiraKakuProN-W3&#39;&amp;quot;, // Hiragino or Helvetica,
    },
  },

  _defined: function() {
    phina.display.Shape.watchRenderProperty.call(this, &#39;cornerRadius&#39;);
    phina.display.Shape.watchRenderProperty.call(this, &#39;text&#39;);
    phina.display.Shape.watchRenderProperty.call(this, &#39;fontColor&#39;);
    phina.display.Shape.watchRenderProperty.call(this, &#39;fontSize&#39;);
    phina.display.Shape.watchRenderProperty.call(this, &#39;fontFamily&#39;);
  },

});

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;手順２-クラス名を変更し-不要な部分を削除する&#34;&gt;手順２ クラス名を変更し、不要な部分を削除する&lt;/h3&gt;

&lt;p&gt;クラス名を変更し、更に&lt;strong&gt;phina.ui.Button&lt;/strong&gt;を継承するように変更します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/**
   * @class phina.ui.AnimateButton
   * AnimateButton
   */
  phina.define(&#39;phina.ui.AnimateButton&#39;, {
    superClass: &#39;phina.ui.Button&#39;,
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;見た目や基本動作は&lt;strong&gt;Button&lt;/strong&gt;クラスのものを使うので基底クラスに関する部分は削除し、以下のようにスッキリさせます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/**
   * @class phina.ui.AnimateButton
   * AnimateButton
   */
  phina.define(&#39;phina.ui.AnimateButton&#39;, {
    superClass: &#39;phina.ui.Button&#39;,
    /**
     * @constructor
     */
    init: function(options) {
      options = (options || {}).$safe(phina.ui.Button.defaults);
      this.superInit(options);
    },
    
    _static: {
      defaults: {
      },
    },
  });
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;手順３-押している間の見た目を変更する&#34;&gt;手順３　押している間の見た目を変更する&lt;/h3&gt;

&lt;p&gt;押している間は少し縮小させたいので、&lt;strong&gt;pointstay&lt;/strong&gt;イベント内に処理を書きます。
&lt;strong&gt;scaleMin&lt;/strong&gt;は後のプロパティ設定で説明します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// プッシュ時の処理を追加
this.on(&#39;pointstay&#39;, function() {
  // 少し縮小
  this.setScale(scaleMin, scaleMin);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;押し終わった後は元のサイズに戻さないといけないので、&lt;strong&gt;pointend&lt;/strong&gt;イベント内に処理を書きます。
&lt;strong&gt;1.0&lt;/strong&gt;が元のサイズです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;this.on(&#39;pointend&#39;, function() {
  // 元に戻す
  this.setScale(1.0, 1.0);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;オプション-クラス特有プロパティを設定できるようにする&#34;&gt;オプション　クラス特有プロパティを設定できるようにする&lt;/h3&gt;

&lt;p&gt;折角ですので、&lt;strong&gt;AnimateButton&lt;/strong&gt;クラス特有のプロパティをコンストラクタで指定できるようにします。
今回は、縮小サイズを指定できるようにしたいと思います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;init: function(options) {
  options = (options || {}).$safe(phina.ui.AnimateButton.defaults);
  this.superInit(options);
  // 独自プロパティ
  var scaleMin = options.scaleMin;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;$safe&lt;/strong&gt;はプロパティ（連想配列）をマージする関数で、&lt;strong&gt;options&lt;/strong&gt;で与えられた値とデフォルトで定義されている値を結合します。
プロパティ名がバッティングした場合、&lt;strong&gt;options&lt;/strong&gt;で与えられた値をデフォルトの値で上書きすることはありません。&lt;/p&gt;

&lt;p&gt;独自プロパティの値は、&lt;strong&gt;options&lt;/strong&gt;からもらいます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;_static: {
  defaults: {
    scaleMin: 0.95,
  },
},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;独自プロパティのデフォルト値は、上のように書きます。これで、コンストラクタで値を渡して指定できるようになります。&lt;/p&gt;

&lt;h2 id=&#34;完成コード&#34;&gt;完成コード&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/**
 * @class phina.ui.AnimateButton
 * AnimateButton
 */
phina.define(&#39;phina.ui.AnimateButton&#39;, {
  superClass: &#39;phina.ui.Button&#39;,
  /**
   * @constructor
   */
  init: function(options) {
    options = (options || {}).$safe(phina.ui.AnimateButton.defaults);
    this.superInit(options);
    // 独自プロパティ
    var scaleMin = options.scaleMin;
    // プッシュ時の処理を追加
    this.on(&#39;pointstay&#39;, function() {
      // 少し縮小
      this.setScale(scaleMin, scaleMin);
    });
    this.on(&#39;pointend&#39;, function() {
      // 元に戻す
      this.setScale(1.0, 1.0);
    });
  },
  
  _static: {
    defaults: {
      scaleMin: 0.95,
    },
  },
});
// グローバルに展開
phina.globalize();
/*
* メインシーン
*/
phina.define(&amp;quot;MainScene&amp;quot;, {
// 継承
superClass: &#39;DisplayScene&#39;,
// 初期化
init: function() {
  // 親クラス初期化
  this.superInit();
  
  var txt = &#39;Push me&#39;;
  // デフォルトのボタン
  Button({text: txt}).addChildTo(this)
          .setPosition(this.gridX.center(), this.gridY.center(-2))
          .onpush = function() {
            console.log(&#39;Default&#39;);  
          };
  // 拡張ボタン
  AnimateButton({text: txt}).addChildTo(this)
                 .setPosition(this.gridX.center(), this.gridY.center(2))
                 .onpush = function() {
                   console.log(&#39;Animate&#39;);
                 };
},
});
/*
* メイン処理
*/
phina.main(function() {
// アプリケーションを生成
var app = GameApp({
  // MainScene から開始
  startLabel: &#39;main&#39;,
});
// 実行
app.run();
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/9c1f8097&#34; target=&#34;_blank&#34;&gt;[runstantで確認]&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;おわりに&#34;&gt;おわりに&lt;/h2&gt;

&lt;p&gt;説明をだいぶ端折ってしまいましたが、&lt;strong&gt;phina.js&lt;/strong&gt;でのクラス継承についての説明は以上です。このように拡張したクラスは自分専用に使っても良いですし、他のユーザーにも使ってもらいたいということであれば、&lt;a href=&#34;https://github.com/phi-jp/phina.js&#34;&gt;Github&lt;/a&gt;でプルリクエストをしても良いでしょう。&lt;strong&gt;phina.js&lt;/strong&gt;への理解も深まりますので、お勧めです。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Collisionクラスを使った当たり判定</title>
      <link>https://alkn203.github.io/blog/2016/12/16/phina-advent-16th</link>
      <pubDate>Fri, 16 Dec 2016 00:01:08 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2016/12/16/phina-advent-16th</guid>
      <description>

&lt;h2 id=&#34;はじめに&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;この記事は、&lt;a href=&#34;http://qiita.com/advent-calendar/2016/phinajs&#34;&gt;phina.js Advent Calendar 2016&lt;/a&gt; の16日目の記事です。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;15日目：&lt;a href=&#34;http://qiita.com/minimo/items/8aca8ee80196ad045b87&#34;&gt;phina.jsとFirebaseで簡単にオンラインゲームを作ってみる by minimoさん&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;17日目：&lt;a href=&#34;http://qiita.com/minimo/items/b55b792c2fa19964acb4&#34;&gt;phina.jsでTiledMapEditorを利用するy minimoさん&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;collisionクラスについて&#34;&gt;Collisionクラスについて&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;phina.geom.Collision&lt;/strong&gt;は、当たり判定を行うためのクラスです。
&lt;strong&gt;phina.js&lt;/strong&gt;の当たり判定で良く使うのは、&lt;strong&gt;phina.app.Object2d&lt;/strong&gt;クラスの&lt;strong&gt;hitTest&lt;/strong&gt;メソッドかと思いますが、このメソッドを使うためには以下のようにインスタンス経由となります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;obj.hitTest(target);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;対して、&lt;strong&gt;Collision&lt;/strong&gt;クラスのメソッドは全て&lt;strong&gt;static&lt;/strong&gt;なメソッドとなっています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Collision.メソッド名(引数1, 引数2);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;collisionクラスのメソッド&#34;&gt;Collisionクラスのメソッド&lt;/h2&gt;

&lt;h3 id=&#34;testcirclecircle&#34;&gt;testCircleCircle&lt;/h3&gt;

&lt;p&gt;円同士が重なっているかを判定します。&lt;/p&gt;

&lt;h3 id=&#34;testrectrect&#34;&gt;testRectRect&lt;/h3&gt;

&lt;p&gt;矩形同士が重なっているかを判定します。&lt;/p&gt;

&lt;h3 id=&#34;testcirclerect&#34;&gt;testCircleRect&lt;/h3&gt;

&lt;p&gt;円と矩形が重なってるかを判定します。&lt;/p&gt;

&lt;h3 id=&#34;testcircleline&#34;&gt;testCircleLine&lt;/h3&gt;

&lt;p&gt;円と線分が重なってるかを判定します。&lt;/p&gt;

&lt;h2 id=&#34;サンプルコード&#34;&gt;サンプルコード&lt;/h2&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://alkn203.github.io/blog/images/phina-advent-16th.png&#34; alt=&#34;phina-advent-16th&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// グローバルに展開
phina.globalize();
/*
 * メインシーン
 */
phina.define(&amp;quot;MainScene&amp;quot;, {
  // 継承
  superClass: &#39;DisplayScene&#39;,
  // 初期化
  init: function() {
    // 親クラス初期化
    this.superInit();
    // 背景色
    this.backgroundColor = &#39;black&#39;;
    // ラベル1
    this.label1 = Label({
      text: &#39;図形をドラッグして重ねよう&#39;,
      fill: &#39;white&#39;,
      fontSize: 48,
    }).addChildTo(this).setPosition(this.gridX.center(), this.gridY.center(-6));
    // ラベル2
    this.label2 = Label({
      fill: &#39;white&#39;,
      fontSize: 48,
    }).addChildTo(this).setPosition(this.gridX.center(), this.gridY.center(6));
    // 円1
    var circle1 = CircleShape({
      fill: null,
    }).addChildTo(this).setPosition(this.gridX.center(), this.gridY.center(-2));
    // ドラッグ可能にする
    Draggable().attachTo(circle1);
    // 円2
    var circle2 = CircleShape({
      fill: null,
    }).addChildTo(this).setPosition(this.gridX.center(), this.gridY.center(2));
    // ドラッグ可能にする
    Draggable().attachTo(circle2); 
    // 矩形1
    var rect1 = RectangleShape({
      fill: null,
    }).addChildTo(this).setPosition(this.gridX.center(-3), this.gridY.center());
    Draggable().attachTo(rect1);
    // 矩形2
    var rect2 = RectangleShape({
      fill: null,
    }).addChildTo(this).setPosition(this.gridX.center(3), this.gridY.center());
    Draggable().attachTo(rect2);
    // canvas要素描画用
    var elem  = PlainElement({
      width: this.gridX.width,
      height: this.gridY.width, 
    }).addChildTo(this).setPosition(this.gridX.center(), this.gridY.center());
    // canvasパラメータ指定
    elem.canvas.context.strokeStyle = &#39;white&#39;;
    elem.canvas.context.lineWidth = 4;
    // 線分の両端の座標
    this.points = [Vector2(this.gridX.center(-3), this.gridY.center(-3)),
                   Vector2(this.gridX.center(3), this.gridY.center(3))];
    
    var p1 = this.points[0];
    var p2 = this.points[1];
    // 線を引く
    elem.canvas.drawLine(p1.x, p1.y, p2.x, p2.y);
    // 参照用
    this.circle1 = circle1;
    this.circle2 = circle2;
    this.rect1 = rect1;
    this.rect2 = rect2;
  },

  update: function() {
    var c1 = this.circle1;
    var c2 = this.circle2;
    var r1 = this.rect1;
    var r2 = this.rect2;
    // 円同士の当たり判定
    if (Collision.testCircleCircle(c1, c2)) {
      this.label2.text = &#39;Circle And Circle&#39;;
      return;
    }
    // 矩形同士の当たり判定
    if (Collision.testRectRect(r1, r2)) {
      this.label2.text = &#39;Rect And Rect&#39;;
      return;  
    }
    // 円と矩形の当たり判定
    if (Collision.testCircleRect(c1, r1) || Collision.testCircleRect(c1, r2) ||
        Collision.testCircleRect(c2, r1) || Collision.testCircleRect(c2, r2)) {
          this.label2.text = &#39;Circle And Rect&#39;;
          return;  
    }

    var p1 = this.points[0];
    var p2 = this.points[1];
    var bc1 = Circle(c1.x, c1.y, c1.radius);
    var bc2 = Circle(c2.x, c2.y, c2.radius);
    // 円と線分の当たり判定
    if (Collision.testCircleLine(bc1, p1, p2) ||
        Collision.testCircleLine(bc2, p1, p2)) {
          this.label2.text = &#39;Circle And Line&#39;;
          return;  
    }
    
    this.label2.text = &#39;&#39;;
  },
});
/*
 * メイン処理
 */
phina.main(function() {
  // アプリケーションを生成
  var app = GameApp({
    // MainScene から開始
    startLabel: &#39;main&#39;,
  });
  // 実行
  app.run();
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/9872a6f6&#34; target=&#34;_blank&#34;&gt;[runstantで確認]&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;おわりに&#34;&gt;おわりに&lt;/h2&gt;

&lt;p&gt;現在の&lt;strong&gt;Collision&lt;/strong&gt;クラスで大体の当たり判定の処理はできるかと思いますが、&lt;strong&gt;線分と線分&lt;/strong&gt;、&lt;strong&gt;矩形と線分&lt;/strong&gt;、&lt;strong&gt;多角形と多角形&lt;/strong&gt;といった当たり判定を追加しても良いかもしれません。ライブラリ開発に少しでもコントリビュートしていけるのが&lt;strong&gt;phina.js&lt;/strong&gt;の醍醐味でもあります。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Flowを使った非同期処理の基本</title>
      <link>https://alkn203.github.io/blog/2016/12/12/phina-advent-12th</link>
      <pubDate>Mon, 12 Dec 2016 00:01:08 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2016/12/12/phina-advent-12th</guid>
      <description>

&lt;h2 id=&#34;はじめに&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;この記事は、&lt;a href=&#34;http://qiita.com/advent-calendar/2016/phinajs&#34;&gt;phina.js Advent Calendar 2016&lt;/a&gt; の12日目の記事です。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;11日目：&lt;a href=&#34;http://qiita.com/tamochu3141/items/8094aec3348dc9a6ae9d&#34;&gt;phina.jsでの多人数参加型ゲームの作製 by tamochu3141さん&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;13日目：&lt;a href=&#34;http://qiita.com/minimo/items/27020fdb66375f1f868b&#34;&gt;phina.jsでGamePadを使う by minimoさん&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;非同期処理&#34;&gt;非同期処理&lt;/h2&gt;

&lt;p&gt;基本的にプログラムはソースに書かれたの順序で実行されます。これは一般的に&lt;strong&gt;同期処理&lt;/strong&gt;と呼んでいます。
一方で、処理の一部を特定の処理が終わるまで待ってから実行するなど、書かれた順序に依存しない処理を&lt;strong&gt;非同期処理&lt;/strong&gt;と呼んでおり、時間のかかる処理をバックグランドで実行させておく場合になどによく使用されます。&lt;/p&gt;

&lt;h2 id=&#34;flowとは&#34;&gt;Flowとは&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;phina.js&lt;/strong&gt;には、&lt;strong&gt;Flow&lt;/strong&gt;という非同期処理を実装するためのクラスが用意されています。&lt;strong&gt;javascript&lt;/strong&gt;に詳しい人なら、&lt;strong&gt;EcmaScript6&lt;/strong&gt;の&lt;strong&gt;Promise&lt;/strong&gt;と言えばピンと来るかもしれません。(そう言う私もそれほど詳しくありませんが）
&lt;strong&gt;Flow&lt;/strong&gt;はその&lt;strong&gt;Promise&lt;/strong&gt;と基本的に同じ機能を&lt;strong&gt;phina.js&lt;/strong&gt;で実装したものです。&lt;strong&gt;tmlib.js&lt;/strong&gt;時代も&lt;strong&gt;Flow&lt;/strong&gt;というクラス自体はありましたが、中身は大幅に違っています。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://alkn203.github.io/blog/images/phina-advent-12th.png&#34; alt=&#34;15puzzle-tut-2&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;h2 id=&#34;flowの使い方&#34;&gt;Flowの使い方&lt;/h2&gt;

&lt;p&gt;では、早速使い方を見ていきましょう。
以下がサンプルコードです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;phina.globalize();
// メインシーン
phina.define(&#39;MainScene&#39;, {
  superClass: &#39;DisplayScene&#39;,
  // コンストラクタ
  init: function() {
    // 親クラス初期化
    this.superInit();
    // 背景色
    this.backgroundColor = &#39;black&#39;;
  
    var self = this;
    var duration = 2000;
    // flow設定
    var flow = Flow(function(resolve) {
      RectangleShape()
        .addChildTo(self)
        .setPosition(self.gridX.center(), 0)
        .tweener.to({y: self.gridY.center()}, duration)
        .call(function() {
          resolve();
        });
    });

    var rect = RectangleShape().addChildTo(this);
    rect.setPosition(self.gridX.center(1), self.gridY.center(1));
    // 非同期処理(resoveで呼ばれる)
    flow.then(function() {
      rect.tweener.to({y: self.gridY.width}, duration).play();
    });
    // 同期処理
    RectangleShape()
      .addChildTo(self)
      .setPosition(self.gridX.center(-1), self.gridY.center(1))
      .tweener.to({y: self.gridY.width}, duration);
  },
});
// メイン
phina.main(function() {
  var app = GameApp({
    startLabel: &#39;main&#39;,
  });
  app.run();
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/017e556a&#34; target=&#34;_blank&#34;&gt;[runstantで確認]&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;実行すると、左下の矩形は実行と同時に下に移動しますが、右下の矩形は上の矩形が止まってから移動を開始します。&lt;/p&gt;

&lt;h2 id=&#34;コード説明&#34;&gt;コード説明&lt;/h2&gt;

&lt;h3 id=&#34;flowの設定&#34;&gt;Flowの設定&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// flow設定
var flow = Flow(function(resolve) {
  RectangleShape()
    .addChildTo(self)
    .setPosition(self.gridX.center(), 0)
    .tweener.to({y: self.gridY.center()}, duration)
    .call(function() {
      resolve(&#39;flow done&#39;);
      console.log(message);
    }).play();
});
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;非同期で実行したい処理を&lt;strong&gt;Flow&lt;/strong&gt;内に記述します。&lt;/li&gt;
&lt;li&gt;処理が終わった後は、&lt;strong&gt;resolve&lt;/strong&gt;を呼び出します。&lt;/li&gt;
&lt;li&gt;上の例では、&lt;strong&gt;tweener&lt;/strong&gt;を使って一定時間かけて画面中央まで移動した後に、&lt;strong&gt;resolve&lt;/strong&gt;をコールするようにしています。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;後処理の記述&#34;&gt;後処理の記述&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// resoveで実行される
flow.then(function() {
  rect.tweener.to({y: self.gridY.width}, duration).play();
});
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;resolve&lt;/strong&gt;が呼ばれると、&lt;strong&gt;Flow&lt;/strong&gt;クラスのメソッド&lt;strong&gt;then&lt;/strong&gt;が実行されるため、この中に後から実行したい処理を記述します。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;複数のflowを取り扱う&#34;&gt;複数のFlowを取り扱う&lt;/h3&gt;

&lt;p&gt;これまでは1つの&lt;strong&gt;Flow&lt;/strong&gt;オブジェクトを取り扱ってきました。
1つであれば&lt;strong&gt;tweener&lt;/strong&gt;を使えば似たような処理が出来なくもないですが、さらに&lt;strong&gt;Flow&lt;/strong&gt;では複数の非同期処理をウォッチすることができます。
サンプルコードは以下のとおりです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;phina.globalize();
// メインシーン
phina.define(&#39;MainScene&#39;, {
  superClass: &#39;DisplayScene&#39;,
  // コンストラクタ
  init: function() {
    // 親クラス初期化
    this.superInit();
    // 背景色
    this.backgroundColor = &#39;black&#39;;
  
    var self = this;
    var flows = [];
    
    (10).times(function(i) {
      // flow作成
      var flow = Flow(function(resolve) {
        var x = Random.randint(64, self.gridX.width - 64);
        var y = Random.randint(64, self.gridY.width - 64);
        var duration = Random.randint(500, 5000); 
        // ランダムな位置に円を作成
        CircleShape()
          .addChildTo(self)
          .setPosition(x, y)
          .tweener.fadeOut(duration) // フェードアウト
          .call(function() {
            resolve(i + &#39;done&#39;);
          }).play();
        });
        // 配列に追加
        flows.push(flow);
    });
    // 全てのflow実行後
    Flow.all(flows).then(function(messages) {
      console.log(&#39;all done!&#39;, messages);
    });
  },
});
// メイン
phina.main(function() {
  var app = GameApp({
    startLabel: &#39;main&#39;,
  });
  app.run();
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/9665202b&#34; target=&#34;_blank&#34;&gt;[runstantで確認]&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;実行すると、ランダムな位置に円が表示されランダムな時間でフェードアウトします。&lt;/li&gt;
&lt;li&gt;最後の円がフェードアウトしてから、メッセージがコンソールに表示されます。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;コード説明-1&#34;&gt;コード説明&lt;/h2&gt;

&lt;h3 id=&#34;flowの配列を作って追加する&#34;&gt;Flowの配列を作って追加する&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var flows = [];

(10).times(function(i) {
  // flow作成
  var flow = Flow(function(resolve) {
    var x = Random.randint(64, self.gridX.width - 64);
    var y = Random.randint(64, self.gridY.width - 64);
    var duration = Random.randint(500, 5000); 
    // ランダムな位置に円を作成
    CircleShape()
      .addChildTo(self)
      .setPosition(x, y)
      .tweener.fadeOut(duration) // フェードアウト
      .call(function() {
        resolve(i + &#39;done&#39;);
      }).play();
    });
    // 配列に追加
    flows.push(flow);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Flow&lt;/strong&gt;を格納する配列を作って&lt;strong&gt;push&lt;/strong&gt;しています。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;flow-allで全てのflowをウォッチ&#34;&gt;Flow.allで全てのFlowをウォッチ&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 全てのflow実行後
Flow.all(flows).then(function(messages) {
  console.log(&#39;all done!&#39;, messages);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Flow.all&lt;/strong&gt;の引数にウォッチしたい&lt;strong&gt;Flow&lt;/strong&gt;の配列を代入すると、与えれられた全ての非同期処理の終了をウォッチすることができます。&lt;/li&gt;
&lt;li&gt;今回は配列でまとめて代入しましたが、個々に&lt;strong&gt;Flow&lt;/strong&gt;を作成して代入することもできます。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;おわりに&#34;&gt;おわりに&lt;/h2&gt;

&lt;p&gt;説明不足のところもあるかもしれませんが、今回紹介した&lt;strong&gt;Flow&lt;/strong&gt;を使うことによって、&lt;strong&gt;phina.js&lt;/strong&gt;における非同期処理をよりスマートにコーディングすることができると思いますので、皆も色々と試してみて下さい。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PlainElementでCanvas描画</title>
      <link>https://alkn203.github.io/blog/2016/12/05/phina-advent-5th</link>
      <pubDate>Mon, 05 Dec 2016 00:01:08 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2016/12/05/phina-advent-5th</guid>
      <description>

&lt;h2 id=&#34;はじめに&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;この記事は、&lt;a href=&#34;http://qiita.com/tamochu3141/items/8094aec3348dc9a6ae9d&#34;&gt;phina.js Advent Calendar 2016&lt;/a&gt; の5日目の記事です。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;4日目：&lt;a href=&#34;http://qiita.com/tamochu3141/items/8094aec3348dc9a6ae9d&#34;&gt;phina.jsでの多人数参加型ゲームの作製 by tamochu3141さん&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;6日目：&lt;a href=&#34;http://qiita.com/simiraaaa/items/ba1f1648a6d0451b5abc&#34;&gt;Shapeを画像として使う by simiraaaaさん&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;phina-jsの描画機能&#34;&gt;phina.jsの描画機能&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;phina.js&lt;/strong&gt;の描画機能は、&lt;strong&gt;HTML5 Canvas&lt;/strong&gt;がベースになっています。&lt;strong&gt;Canvas&lt;/strong&gt;をある程度知っている人は、&lt;strong&gt;phina.js&lt;/strong&gt;を使ってみてピンと来るところがあると思います。加えて、&lt;strong&gt;phina.js&lt;/strong&gt;にはデフォルトの&lt;strong&gt;Canvas&lt;/strong&gt;の機能を拡張した&lt;a href=&#34;https://github.com/phi-jp/phina.js/blob/develop/src/graphics/canvas.js&#34;&gt;&lt;strong&gt;phina.graphics.Canvas&lt;/strong&gt;&lt;/a&gt;というクラスが用意されており、デフォルトのメソッドに加え、簡単に線を描画できる&lt;strong&gt;drawLine&lt;/strong&gt;など便利なメソッド群が追加で実装されています。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;phina.js&lt;/strong&gt;で&lt;strong&gt;Canvas&lt;/strong&gt;のメソッドを使用したい場合は、&lt;strong&gt;phina.graphics.Canvas&lt;/strong&gt;のインスタンスを作ってそこに描画する方法がありますが、多少手間がかかるところがありますので、今回は手軽に&lt;strong&gt;Canvas&lt;/strong&gt;の機能が使える&lt;strong&gt;PlainElement&lt;/strong&gt;というクラスを紹介したいと思います。&lt;/p&gt;

&lt;h2 id=&#34;plainelementクラス&#34;&gt;PlainElementクラス&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;phina.display.PlainElement&lt;/strong&gt;は、内部に&lt;strong&gt;Canvas&lt;/strong&gt;クラスを持っているだけのシンプルなクラスで、&lt;strong&gt;Shape&lt;/strong&gt;の親クラスとして位置付けられています。
内部に&lt;strong&gt;Canvas&lt;/strong&gt;を持っているので、&lt;strong&gt;Canvas&lt;/strong&gt;で使えるメソッドは一通り使うことができます。&lt;/p&gt;

&lt;h2 id=&#34;plainelementクラスの使用例-簡単なお絵描き風プログラム&#34;&gt;PlainElementクラスの使用例（簡単なお絵描き風プログラム）&lt;/h2&gt;

&lt;p&gt;お絵描きと呼べる程ではありませんが、今回は、マウスドラッグで線が引けるだけの簡単なサンプルを作ってみました。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://alkn203.github.io/blog/images/phina-advent-5th.png&#34; alt=&#34;phina-advent-5th&#34; /&gt;&lt;/p&gt;

&lt;p&gt;コードは以下のとおりです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;phina.globalize();
// メインシーン
phina.define(&#39;MainScene&#39;, {
  superClass: &#39;DisplayScene&#39;,
  // コンストラクタ
  init: function() {
    // 親クラス初期化
    this.superInit();
    // 背景色
    this.backgroundColor = &#39;black&#39;;
    // canvas要素描画用
    var elem  = PlainElement({
      width: this.gridX.width,
      height: this.gridY.width, 
    }).addChildTo(this).setPosition(this.gridX.center(), this.gridY.center());
    // canvasパラメータ指定
    elem.canvas.context.strokeStyle = &#39;white&#39;;
    elem.canvas.context.lineWidth = 4;
    // 参照用
    this.elem = elem;
  },
  // タッチ開始
  onpointstart: function(e) {
    // タッチされた位置を記憶
    this.prev = Vector2(e.pointer.x, e.pointer.y);
  },
  // タッチ移動中
  onpointmove: function(e) {
    // 現在のタッチ位置を記憶
    var current = Vector2(e.pointer.x, e.pointer.y);
    // 前の位置から現在の位置まで線を引く
    this.elem.canvas.drawLine(this.prev.x, this.prev.y, current.x, current.y);
    // 前の位置を現在の位置に更新
    this.prev = current;
  },
  // タッチ終了
  onpointend: function() {
    // 位置情報をクリア
    this.prev = null;  
  },
});
// メイン
phina.main(function() {
  var app = GameApp({
    startLabel: &#39;main&#39;,
  });
  app.run();
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/783bf264&#34; target=&#34;_blank&#34;&gt;[runstantで確認]&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;コード説明&#34;&gt;コード説明&lt;/h2&gt;

&lt;h3 id=&#34;plainelementの追加&#34;&gt;PlainElementの追加&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    // canvas要素描画用
    var elem  = PlainElement({
      width: this.gridX.width,
      height: this.gridY.width, 
    }).addChildTo(this).setPosition(this.gridX.center(), this.gridY.center());
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;PlainElement&lt;/strong&gt;を作成して、&lt;strong&gt;Scene&lt;/strong&gt;に追加しています。&lt;/li&gt;
&lt;li&gt;コンストラクでは、横と縦のサイズを指定します。今回は、画面と同じサイズにして重ねています。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;canvasのcontext指定&#34;&gt;canvasのcontext指定&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// canvasパラメータ指定
elem.canvas.context.strokeStyle = &#39;white&#39;;
elem.canvas.context.lineWidth = 4;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;PlainElement&lt;/strong&gt;内部の&lt;strong&gt;Canvas&lt;/strong&gt;には、&lt;strong&gt;canvas&lt;/strong&gt;プロパティでアクセスできます。&lt;/li&gt;
&lt;li&gt;ここでは&lt;strong&gt;canvas&lt;/strong&gt;の&lt;strong&gt;context&lt;/strong&gt;を経由して、線の色と幅を指定しています。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;タッチ開始時処理&#34;&gt;タッチ開始時処理&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// タッチ開始
onpointstart: function(e) {
  // タッチされた位置を記憶
  this.prev = Vector2(e.pointer.x, e.pointer.y);
},
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;イベントからマウスが押された位置を取得します。&lt;/li&gt;
&lt;li&gt;線の始点の座標を&lt;strong&gt;Vector2&lt;/strong&gt;クラスを使って記憶します。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;タッチ移動時処理&#34;&gt;タッチ移動時処理&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// タッチ移動中
onpointmove: function(e) {
  // 現在のタッチ位置を記憶
  var current = Vector2(e.pointer.x, e.pointer.y);
  // 前の位置から現在の位置まで線を引く
  this.elem.canvas.drawLine(this.prev.x, this.prev.y, current.x, current.y);
  // 前の位置を更新
  this.prev = current;
},
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;現在のタッチ位置を線の終点として記憶します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;canvas&lt;/strong&gt;の&lt;strong&gt;drawLine&lt;/strong&gt;メソッドで線を引きます。&lt;/li&gt;
&lt;li&gt;最後の前の位置を現在の位置に更新します。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;タッチ終了時処理&#34;&gt;タッチ終了時処理&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// タッチ終了
onpointend: function() {
  // 位置情報をクリア
  this.prev = null;  
},
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;線を引き終わった後は、始点の位置情報をクリアします。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;補足&#34;&gt;補足&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;phinajs&lt;/strong&gt;には他に&lt;strong&gt;PathShape&lt;/strong&gt;というクラスがあります。線の描画に特化したクラスで、座標値データ群を与えるだけでその点を結んだ線を自動で描画してくれる優れものです。こちらはまた別の機会に紹介したいと思います。&lt;/p&gt;

&lt;h2 id=&#34;おわりに&#34;&gt;おわりに&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;phina.js&lt;/strong&gt;でゲームを作るときは&lt;strong&gt;Sprite&lt;/strong&gt;画像を使うことが多いかもしれませんが、上で説明した&lt;strong&gt;PlainElement&lt;/strong&gt;、つまり、&lt;strong&gt;Canvas&lt;/strong&gt;の機能を併用することで、よりゲームの表現性が増すのではないでしょうか。可能であれば、今回のアドベントカレンダーの期間内で簡単なサンプルゲームを作ってみたいと思います。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>006-Shapeの更新イベント処理</title>
      <link>https://alkn203.github.io/blog/2016/11/29/phina-update-shape</link>
      <pubDate>Tue, 29 Nov 2016 00:01:08 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2016/11/29/phina-update-shape</guid>
      <description>

&lt;h2 id=&#34;内容&#34;&gt;内容&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Shape&lt;/strong&gt;に対してフレーム更新処理を登録する方法について説明します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://alkn203.github.io/blog/images/phina-update-shape.png&#34; alt=&#34;phina-invisible-shape&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;更新イベント処理-update&#34;&gt;更新イベント処理（update）&lt;/h2&gt;

&lt;p&gt;更新処理を登録するためには、&lt;strong&gt;shape&lt;/strong&gt;の&lt;strong&gt;update&lt;/strong&gt;関数を実装します。
&lt;strong&gt;update&lt;/strong&gt;関数が実装されていると、その内容が毎フレーム実行されます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 毎フレーム更新処理
shape.update = function() {
  // 移動
  shape.moveBy(1, 1);  
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/d709760f&#34; target=&#34;_blank&#34;&gt;[runstantで確認]&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;更新イベント処理-on-enterframe&#34;&gt;更新イベント処理（on + enterframe）&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;update&lt;/strong&gt;では1つのメソッドしか登録できません。一方、&lt;strong&gt;on&lt;/strong&gt;と&lt;strong&gt;enterframe&lt;/strong&gt;を組み合わせると複数のメソッドを登録可能で、その内容が並行して実行されます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 毎フレーム更新処理
shape.on(&#39;enterframe&#39;, function() {
  // 移動
  shape.moveBy(1, 1);  
});
// 毎フレーム更新処理
shape.on(&#39;enterframe&#39;, function() {
  // 回転
  shape.rotation++;  
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/0705ecfc&#34; target=&#34;_blank&#34;&gt;[runstantで確認]&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>005-Shapeを透明化する</title>
      <link>https://alkn203.github.io/blog/2016/11/13/phina-invisible-shape</link>
      <pubDate>Sun, 13 Nov 2016 00:01:08 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2016/11/13/phina-invisible-shape</guid>
      <description>

&lt;h2 id=&#34;内容&#34;&gt;内容&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Shape&lt;/strong&gt;を透明化する方法について説明します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://alkn203.github.io/blog/images/phina-invisible-shape.png&#34; alt=&#34;phina-invisible-shape&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;shapeの透明化&#34;&gt;Shapeの透明化&lt;/h2&gt;

&lt;p&gt;透明にするには&lt;strong&gt;alpha&lt;/strong&gt;プロパティに&lt;strong&gt;0&lt;/strong&gt;を指定します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;shape.alpha = 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/7e1a191a&#34; target=&#34;_blank&#34;&gt;[runstantで確認]&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;alpha&lt;/strong&gt;プロパティには&lt;strong&gt;0から1&lt;/strong&gt;が指定できるので、好みの透明度にすることができます。&lt;/p&gt;

&lt;h2 id=&#34;shapeの非表示&#34;&gt;Shapeの非表示&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;phina.js&lt;/strong&gt;では、透明化の他に&lt;strong&gt;hide&lt;/strong&gt;メソッドでオブジェクトそのものを非表示にすることができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;shape.hide();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/3df6a8b8&#34; target=&#34;_blank&#34;&gt;[runstantで確認]&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;再表示するには、&lt;strong&gt;show&lt;/strong&gt;メソッドを使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;shape.show();
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;透明化と非表示の違い&#34;&gt;透明化と非表示の違い&lt;/h2&gt;

&lt;p&gt;透明化ではオブジェクト自体は存在するので、当たり判定やタッチ処理は有効ですが、非表示にした場合は描画自体されないので、当たり判定やタッチ処理は無効になります。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>004-Shapeの背景色指定</title>
      <link>https://alkn203.github.io/blog/2016/10/09/phina-bg-shape</link>
      <pubDate>Sun, 09 Oct 2016 00:01:08 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2016/10/09/phina-bg-shape</guid>
      <description>

&lt;h2 id=&#34;内容&#34;&gt;内容&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Shape&lt;/strong&gt;の背景色の指定方法について説明します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://alkn203.github.io/blog/images/phina-bg-shape.png&#34; alt=&#34;phina-bg-shape&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;背景色指定&#34;&gt;背景色指定&lt;/h2&gt;

&lt;p&gt;背景色は&lt;strong&gt;backgroundColor&lt;/strong&gt;プロパティで指定します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;shape.backgroundColor = &#39;red&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/57cab291&#34; target=&#34;_blank&#34;&gt;[runstantで確認]&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;他の指定方法&#34;&gt;他の指定方法&lt;/h2&gt;

&lt;h3 id=&#34;16進数&#34;&gt;16進数&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;css&lt;/strong&gt;と同様に指定できます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;shape.backgroundColor = &#39;#ffff00&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/6a5a9d1d&#34; target=&#34;_blank&#34;&gt;[runstantで確認]&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;rgb&#34;&gt;RGB&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Rgb&lt;/strong&gt;クラスを使って指定できます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;shape.backgroundColor = `rgb(0, 255, 255)`;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/cb651549&#34; target=&#34;_blank&#34;&gt;[runstantで確認]&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;hsl&#34;&gt;hsl&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;css&lt;/strong&gt;と同様に指定できます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;shape.backgroundColor = `hsl(300, 75%, 50%)`;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/accb7a5a&#34; target=&#34;_blank&#34;&gt;[runstantで確認]&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>003-Shapeの幅・高さ指定</title>
      <link>https://alkn203.github.io/blog/2016/10/06/phina-resize-shape</link>
      <pubDate>Thu, 06 Oct 2016 00:01:08 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2016/10/06/phina-resize-shape</guid>
      <description>

&lt;h2 id=&#34;内容&#34;&gt;内容&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Shape&lt;/strong&gt;の幅・高さの指定方法について説明します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://alkn203.github.io/blog/images/phina-resize-shape.png&#34; alt=&#34;phina-resize-shape&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;幅指定&#34;&gt;幅指定&lt;/h2&gt;

&lt;p&gt;幅は&lt;strong&gt;width&lt;/strong&gt;プロパティで指定します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;shape.width = 128;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/7fad0439&#34;&gt;[runstantで確認]&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;高さ指定&#34;&gt;高さ指定&lt;/h2&gt;

&lt;p&gt;高さは&lt;strong&gt;height&lt;/strong&gt;プロパティで指定します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;shape.height = 128;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/5da92e05&#34;&gt;[runstantで確認]&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;幅-高さを一括指定&#34;&gt;幅・高さを一括指定&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;setSize&lt;/strong&gt;を使えば、幅と高さを一括で指定できます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;shape.setSize(128, 256);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/8de8694c&#34;&gt;[runstantで確認]&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;コンストラクタ内で指定&#34;&gt;コンストラクタ内で指定&lt;/h2&gt;

&lt;p&gt;位置指定と同じくコンストラクタ内で幅・高さを指定することも可能です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    var shape = Shape({
      // 位置・幅・高さ指定
      x: 320,
      y: 480,
      width: 128,
      height: 256,
    }).addChildTo(this);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/1a3e59cf&#34;&gt;[runstantで確認]&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>002-Shapeの位置指定</title>
      <link>https://alkn203.github.io/blog/2016/10/03/phina-locate-shape</link>
      <pubDate>Mon, 03 Oct 2016 00:01:08 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2016/10/03/phina-locate-shape</guid>
      <description>

&lt;h2 id=&#34;内容&#34;&gt;内容&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Shape&lt;/strong&gt;の位置を以下のように指定します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://alkn203.github.io/blog/images/phina-locate-shape.png&#34; alt=&#34;phina_locate_shape_image&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;コード&#34;&gt;コード&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// グローバルに展開
phina.globalize();
/*
 * メインシーン
 */
phina.define(&amp;quot;MainScene&amp;quot;, {
  // 継承
  superClass: &#39;DisplayScene&#39;,
  // 初期化
  init: function() {
    // 親クラス初期化
    this.superInit();
    // 背景色
    this.backgroundColor = &#39;black&#39;;
    // Shapeを作成してシーンに追加
    var shape = Shape().addChildTo(this);
    // 移動
    shape.x = 320;
    shape.y = 480;
  },
});
/*
 * メイン処理
 */
phina.main(function() {
  // アプリケーションを生成
  var app = GameApp({
    // MainScene から開始
    startLabel: &#39;main&#39;,
  });
  // fps表示
  //app.enableStats();
  // 実行
  app.run();
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/4e8bc6e6&#34;&gt;[runstantで実行]&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;コード説明&#34;&gt;コード説明&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Shape&lt;/strong&gt;の位置変更は、&lt;strong&gt;x, y&lt;/strong&gt;プロパティに直接数値を指定することで可能です。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;他の位置指定方法&#34;&gt;他の位置指定方法&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;setPosition&lt;/strong&gt;関数を使えば、&lt;strong&gt;x, y&lt;/strong&gt;の値を一括で指定することができ、生成から一気にチェインメソッドで繋げて書くこともできるので便利です。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var shape = Shape().addChildTo(this).shape.setPosition(320, 480);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/4c21e518&#34;&gt;[runstantで実行]&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Shape&lt;/strong&gt;のコンストラクタにパラメータとして与えてることでも指定できます。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var shape = Shape({
  x: 320,
  y: 480
}).addChildTo(this)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/81ae38a5&#34;&gt;[runstantで実行]&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;moveBy&lt;/strong&gt;関数を使えば、&lt;strong&gt;x, y&lt;/strong&gt;の移動量で位置を変更することができます。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;shape.setPosition(320, 480).moveBy(100, 200);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/af6327d3&#34;&gt;[runstantで実行]&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;変則的ですが、&lt;strong&gt;Vector2&lt;/strong&gt;クラスを使ってベクトル値の加算で位置指定する方法もあります。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var v = Vector2(100, 200);
shape.position.add(v);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/6a11250f&#34;&gt;[runstantで実行]&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>001-Shapeを生成してSceneに追加する</title>
      <link>https://alkn203.github.io/blog/2016/10/01/phina-add-shape</link>
      <pubDate>Sat, 01 Oct 2016 00:01:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2016/10/01/phina-add-shape</guid>
      <description>

&lt;h2 id=&#34;内容&#34;&gt;内容&lt;/h2&gt;

&lt;p&gt;今回は基本的な内容ではありますが、オブジェクトの基本形である&lt;strong&gt;Shape&lt;/strong&gt;を以下のように画面に表示してみます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://alkn203.github.io/blog/images/phina-add-shape.png&#34; alt=&#34;phina_add_shape_image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/c5ac89af&#34;&gt;[runstantで実行]&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;

&lt;h2 id=&#34;コード&#34;&gt;コード&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// グローバルに展開
phina.globalize();
/*
 * メインシーン
 */
phina.define(&amp;quot;MainScene&amp;quot;, {
  // 継承
  superClass: &#39;DisplayScene&#39;,
  // 初期化
  init: function() {
    // 親クラス初期化
    this.superInit();
    // 背景色
    this.backgroundColor = &#39;black&#39;;
    // Shapeを作成してシーンに追加
    var shape = Shape();
    shape.addChildTo(this);
  },
});
/*
 * メイン処理
 */
phina.main(function() {
  // アプリケーションを生成
  var app = GameApp({
    // MainScene から開始
    startLabel: &#39;main&#39;,
  });
  // fps表示
  //app.enableStats();
  // 実行
  app.run();
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;コード説明&#34;&gt;コード説明&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Shape&lt;/strong&gt;クラスのコンストラクタで生成します。コンストラクタの前に&lt;strong&gt;new&lt;/strong&gt;をつける必要はありません。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;addChildTo(this)&lt;/strong&gt;で現在の&lt;strong&gt;Scene&lt;/strong&gt;に追加します。&lt;strong&gt;this&lt;/strong&gt;は&lt;strong&gt;MainScene&lt;/strong&gt;を指しています。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;this.addChild(shape)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;としても同じですし&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var shape = Shape().addChildTo(this)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;として1行にまとめることもできます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;位置が指定されていない時は、画面左上(0,0)に表示されます。&lt;/li&gt;
&lt;li&gt;変数に代入しなくても表示されますが、後にプロパティを操作することが多いので、とりあえずは変数に代入しておいた方が良いでしょう。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>phina.jsの基本テンプレートについて</title>
      <link>https://alkn203.github.io/blog/2016/09/29/phina-template</link>
      <pubDate>Thu, 29 Sep 2016 01:55:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2016/09/29/phina-template</guid>
      <description>

&lt;h2 id=&#34;phina-jsの基本テンプレート&#34;&gt;phina.jsの基本テンプレート&lt;/h2&gt;

&lt;p&gt;自分自身の復習のためにも、私が普段１からコーディングをする時に使用しているテンプレートを紹介します。
実行結果は以下のように黒い画面が表示されるだけです。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://alkn203.github.io/blog/images/phina-template.png&#34; alt=&#34;phina_template_image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/8f0388a4&#34;&gt;[runstantで実行]&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;

&lt;h2 id=&#34;コード説明&#34;&gt;コード説明&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// グローバルに展開
phina.globalize();
/*
 * メインシーン
 */
phina.define(&amp;quot;MainScene&amp;quot;, {
  // 継承
  superClass: &#39;DisplayScene&#39;,
  // 初期化
  init: function() {
    // 親クラス初期化
    this.superInit();
    // 背景色
    this.backgroundColor = &#39;black&#39;;
    // 以下にコードを書いていく
  },
});
/*
 * メイン処理
 */
phina.main(function() {
  // アプリケーションを生成
  var app = GameApp({
    // MainScene から開始
    startLabel: &#39;main&#39;,
  });
  // fps表示
  //app.enableStats();
  // 実行
  app.run();
});
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;基本的には、&lt;strong&gt;MainScene&lt;/strong&gt;の&lt;strong&gt;init&lt;/strong&gt;関数内に自分のコードを書いていきます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;this.backgroundColor&lt;/strong&gt;で背景色を指定しないと、デフォルトでは白になります。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;main&lt;/strong&gt;関数内の&lt;strong&gt;GameApp&lt;/strong&gt;関数では、&lt;strong&gt;startLabel&lt;/strong&gt;を&lt;strong&gt;main&lt;/strong&gt;としていますが、これは実行結果をすぐに確認するためにタイトル画面をスキップしたいからです。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;main&lt;/strong&gt;関数内の&lt;strong&gt;enableStats&lt;/strong&gt;関数は、画面左上に&lt;strong&gt;fps&lt;/strong&gt;を常時表示する便利な機能ですが、処理が重くなるので一旦コメントアウトしています。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>ゲーム作成チュートリアル（マインスイーパー）（最終回）【マーク機能の追加】</title>
      <link>https://alkn203.github.io/blog/2016/08/03/minesweeper-tut-06</link>
      <pubDate>Wed, 03 Aug 2016 23:59:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2016/08/03/minesweeper-tut-06</guid>
      <description>

&lt;h2 id=&#34;今回の目標&#34;&gt;今回の目標&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://alkn203.github.io/blog/2016/07/11/minesweeper-tut-05/&#34;&gt;前回&lt;/a&gt;ではゲームオーバーとクリア処理を追加しました。
今回は最終回で、マーク機能を追加します。
マーク機能とは、自分で爆弾と判断したパネルをマークして開けないようにする機能です。
完成版は以下のとおりです。&lt;/p&gt;

&lt;div class=&#39;runstant&#39;&gt;&lt;iframe src=&#39;http://runstant.com/alkn203/projects/a76987b1/full&#39; width=&#39;100%&#39; height=&#39;640px&#39; style=&#39;border:0px;box-shadow:0px 0px 2px 0px #aaa&#39;&gt;&lt;/iframe&gt;&lt;/div&gt;

&lt;h2 id=&#34;コード説明&#34;&gt;コード説明&lt;/h2&gt;

&lt;h4 id=&#34;マーク機能の追加&#34;&gt;マーク機能の追加&lt;/h4&gt;

&lt;h4 id=&#34;mainsceneの変更点&#34;&gt;MainSceneの変更点&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // メインシーン
  phina.define(&#39;MainScene&#39;, {
    superClass: &#39;DisplayScene&#39;,
    // コンストラクタ
    init: function() {
      // 親クラス初期化
      （略）
      // ピース配置
      PANEL_NUM_XY.times(function(spanX) {
        PANEL_NUM_XY.times(function(spanY) {
          // パネル作成
          （略）
          // パネルタッチ時
          panel.onpointstart = function() {
            // マークモードなら
            if (self.mode === &#39;mark&#39;) {
              if (!panel.isOpen &amp;amp;&amp;amp; !panel.isMark) {
                // マーク追加
                if (self.markCount &amp;lt; BOMB_NUM) {
                  Mark().addChildTo(panel);
                  panel.isMark = true;
                  self.markCount++;
                }
              }
              else {
                if (self.markCount &amp;gt; 0) {
                  // マーク削除
                  panel.children[0].remove();
                  panel.isMark = false;
                  self.markCount--;
                }
              }
            }
            else {
              // パネルを開く
              self.openPanel(panel);
              // クリア判定
              self.checkClear();
            }
          };
        });
      });
      // モード
      this.mode = &#39;normal&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;this.mode&lt;/strong&gt;という変数でモードを管理します。&lt;/li&gt;
&lt;li&gt;マークモードであれば、パネルがタッチされた時にそのパネルがまだ開かれていなくて、かつ、マークされていなければマークを追加します。&lt;/li&gt;
&lt;li&gt;逆にマークがあれば、マークを削除します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;this.markCount&lt;/strong&gt;という変数で、マーク数が爆弾の数を超えないようにしています。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;      // マークモードボタン
      Button({
        width: 120,
        height: 64,
        text: &#39;Mark&#39;,
        fill: &#39;silver&#39;,
      }).addChildTo(this)
        .setPosition(this.gridX.span(14), this.gridY.span(14.5))
        .onpush = function() {
          // モード変更
          if (self.mode === &#39;normal&#39;) {
            this.fill = &#39;hsl(160, 80%, 50%)&#39;;
            self.mode = &#39;mark&#39;;
          }
          else {
            this.fill = &#39;silver&#39;;
            self.mode = &#39;normal&#39;;
          }
        };
      // 参照用
      （略）
      // マークの数
      this.markCount = 0;
    },
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;マークモードの切り替えには&lt;strong&gt;Button&lt;/strong&gt;を使用します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;onpush&lt;/strong&gt; 関数にボタンを押したときの処理を記述します。&lt;/li&gt;
&lt;li&gt;今回は現在のモードが分かるように切り替えでボタンの色が変わるようにしています。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// パネルを開く処理
openPanel: function(panel) {
  // マークされていた何もしない
  if (panel.isMark) return;
  （略）
},
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;マークされたパネルが連鎖で開かれないようにしています。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;おわりに&#34;&gt;おわりに&lt;/h2&gt;

&lt;p&gt;6回に渡ってチュートリアルを書いてきましたが、本エントリーが&lt;strong&gt;phina.js&lt;/strong&gt;を使ったゲーム作りの参考になれば幸いです。&lt;/p&gt;

&lt;h3 id=&#34;runstantプロジェクトへのリンク&#34;&gt;runstantプロジェクトへのリンク&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/a76987b1&#34;&gt;http://runstant.com/alkn203/projects/a76987b1&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ゲーム作成チュートリアル（マインスイーパー）（その５）【ゲームオーバーとクリア処理】</title>
      <link>https://alkn203.github.io/blog/2016/07/11/minesweeper-tut-05</link>
      <pubDate>Mon, 11 Jul 2016 23:59:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2016/07/11/minesweeper-tut-05</guid>
      <description>

&lt;h3 id=&#34;今回の目標&#34;&gt;今回の目標&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://alkn203.github.io/blog/2016/07/04/minesweeper-tut-03/&#34;&gt;前回&lt;/a&gt;はパネルが連鎖で開かれるようにしました。
今回は、ゲームオーバーとクリア処理を追加します。&lt;/p&gt;

&lt;div class=&#39;runstant&#39;&gt;&lt;iframe src=&#39;http://runstant.com/alkn203/projects/825d660c/full&#39; width=&#39;100%&#39; height=&#39;640px&#39; style=&#39;border:0px;box-shadow:0px 0px 2px 0px #aaa&#39;&gt;&lt;/iframe&gt;&lt;/div&gt;

&lt;h3 id=&#34;コード説明&#34;&gt;コード説明&lt;/h3&gt;

&lt;h4 id=&#34;ゲームオーバー処理&#34;&gt;ゲームオーバー処理&lt;/h4&gt;

&lt;h4 id=&#34;openpanel関数&#34;&gt;openPanel関数&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // パネルを開く処理
  openPanel: function(panel) {
    // 爆弾ならゲームオーバー
    if (panel.isBomb) {
      Explosion().addChildTo(panel);
      this.showAllBombs();
      return;
    }
    // 既に開かれていた何もしない
    （略）
  },
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;開いたパネルが爆弾だった場合、爆発を表示して、全ての爆弾を表示します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Explosion&lt;/strong&gt;クラスと&lt;strong&gt;showAllBombs&lt;/strong&gt;関数については後述します。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;explosionクラス&#34;&gt;Explosionクラス&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // 爆発クラス
  phina.define(&#39;Explosion&#39;, {
    // StarShapeを継承
    superClass: &#39;StarShape&#39;,
      // コンストラクタ
      init: function() {
        // 親クラス初期化
        this.superInit({
          radius: (PANEL_SIZE + 5) / 2,
          sides: 10,
          sideIndent: 0.75,
          rotation: 15,
          fill: &amp;quot;red&amp;quot;,
          stroke: &amp;quot;yellow&amp;quot;,
        });
      },
  });
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;StarShape&lt;/strong&gt;のパラメータを変えて爆発のように見せています。&lt;/li&gt;
&lt;li&gt;パラメータを変えることで、このような一風違った表現も可能です。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;showallbombs関数&#34;&gt;showAllBombs関数&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // 爆弾を全て表示する
  showAllBombs: function() {
    var self = this;
    
    this.panelGroup.children.each(function(panel) {
      panel.setInteractive(false);
      
      if (panel.isBomb) {
        Bomb().addChildTo(panel);
        panel.tweener.clear().scaleTo(1.2, 100)
                     .scaleTo(1.0, 100)
                     .call(function() {
                       // ラベル表示
                       Label({
                        text: &#39;TOUCH TO RESTART&#39;,
                        fill: &#39;white&#39;,
                       }).addChildTo(self).setPosition(320, 700);
                       // 画面をタッチ可能に
                       self.setInteractive(true);
                     });
      }
    });
  },
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Panel&lt;/strong&gt;をループで調べて、&lt;strong&gt;isBomb&lt;/strong&gt;が&lt;strong&gt;true&lt;/strong&gt;なら爆弾を表示します。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tweener&lt;/strong&gt;で拡大・縮小のアニメーションをつけています。&lt;/li&gt;
&lt;li&gt;アニメーションした後は、ラベルを表示して画面のタッチを有効にしています。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;リスタート処理&#34;&gt;リスタート処理&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // 画面タッチ可能な場合
 onpointstart: function() {
   // 再スタート
   this.exit({
     nextLabel: &#39;main&#39;,  
   });  
 },
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;先に出た&lt;strong&gt;showAllBombs&lt;/strong&gt;で画面がタッチ有効になっている場合、画面をタッチするとこの関数が呼び出されます。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;exit&lt;/strong&gt;関数で&lt;strong&gt;nextLabel&lt;/strong&gt;に&lt;strong&gt;main&lt;/strong&gt;を指定することで、メインシーンが呼び直されます。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;クリア処理&#34;&gt;クリア処理&lt;/h4&gt;

&lt;p&gt;マインスイーパーのクリアとは、爆弾以外のパネルが全部開かれた時です。
結果的には、「全体のパネル数から開かれたパネル数を引いた値が爆弾数と一致」すればよいということになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// メインシーン
phina.define(&#39;MainScene&#39;, {
  superClass: &#39;DisplayScene&#39;,
  // コンストラクタ
  init: function() {
    // 親クラス初期化
    （略）
    // 参照用
    this.panelGroup = panelGroup;
    // クリア判定用
    this.oCount = 0;
  },
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;開かれたパネル数をカウントするための変数&lt;strong&gt;oCount&lt;/strong&gt;を用意します。&lt;/li&gt;
&lt;li&gt;パネルを開いたら&lt;strong&gt;oCount&lt;/strong&gt;を増やしていきます。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;クリア判定&#34;&gt;クリア判定&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// パネルタッチ時
panel.onpointstart = function() {
  self.openPanel(panel);
  // クリア判定
  if (self.oCount === PANEL_NUM_XY * PANEL_NUM_XY - BOMB_NUM) {
    // ラベル表示
    Label({
      text: &#39;GOOD JOB!&#39;,
      fill: &#39;white&#39;,
    }).addChildTo(self).setPosition(320, 700);
    // パネルを選択不可に
    this.panelGroup.children.each(function(panel) {
      panel.setInteractive(false);
    });
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;パネルを開いた時に開かれた数を調べてクリアチェックをしています。&lt;/li&gt;
&lt;li&gt;クリアならラベルを表示して、全てのパネルを選択不可にしています。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;今回はここまで&#34;&gt;今回はここまで&lt;/h3&gt;

&lt;p&gt;ここまでで、ゲームオーバー処理とクリア処理を実装しました。
この状態で最低限のゲームとしては成立していると思いますが、次回は付加機能を追加したいと
思います。&lt;/p&gt;

&lt;h3 id=&#34;runstantプロジェクトへのリンク&#34;&gt;runstantプロジェクトへのリンク&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/825d660c&#34;&gt;http://runstant.com/alkn203/projects/825d660c&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ゲーム作成チュートリアル（マインスイーパー）（その４）【パネルを連鎖で開く】</title>
      <link>https://alkn203.github.io/blog/2016/07/06/minesweeper-tut-04</link>
      <pubDate>Wed, 06 Jul 2016 23:59:06 +0900</pubDate>
      
      <guid>https://alkn203.github.io/blog/2016/07/06/minesweeper-tut-04</guid>
      <description>

&lt;h3 id=&#34;今回の目標&#34;&gt;今回の目標&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://alkn203.github.io/blog/2016/07/04/minesweeper-tut-03/&#34;&gt;前回&lt;/a&gt;はパネルを開くと周りにある爆弾の数が表示されるようにしました。
今回は、周りに爆弾がない場合にパネルを連鎖で開くようにします。&lt;/p&gt;

&lt;div class=&#39;runstant&#39;&gt;&lt;iframe src=&#39;http://runstant.com/alkn203/projects/943f0dea/full&#39; width=&#39;100%&#39; height=&#39;640px&#39; style=&#39;border:0px;box-shadow:0px 0px 2px 0px #aaa&#39;&gt;&lt;/iframe&gt;&lt;/div&gt;

&lt;h3 id=&#34;コード説明&#34;&gt;コード説明&lt;/h3&gt;

&lt;h4 id=&#34;openpanel関数&#34;&gt;openPanel関数&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;  // パネルを開く処理
  openPanel: function(panel) {
    (略)
    // パネルに数を表示
    panel.num = bombs === 0 ? &#39;&#39; : bombs;
    Label({
      text: panel.num,
      fill: &#39;white&#39;,
    }).addChildTo(panel);
    panel.fill = &#39;gray&#39;;
    // 周りに爆弾がなければ再帰的に調べる
    if (bombs === 0) {
      indexs.each(function(i) {
        indexs.each(function(j) {
          var pos = Vector2(panel.x + i * GRID_SIZE, panel.y + j * GRID_SIZE);
          var target = self.getPanel(pos);
          target &amp;amp;&amp;amp; self.openPanel(target);
        });
      });
    }
  },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;周りに爆弾がない場合、現在のパネルを起点にして&lt;strong&gt;getPanel&lt;/strong&gt;を再帰呼び出しします。
今回の変更点はこれだけです。&lt;/p&gt;

&lt;h3 id=&#34;今回はここまで&#34;&gt;今回はここまで&lt;/h3&gt;

&lt;p&gt;ここまでで、パネルを連鎖で開くことができるようになりました。
段々と形になってきたと思いますが、爆弾も開けたりと全然ゲームになっていません。
次回は、ゲームオーバーとクリア処理を追加します。&lt;/p&gt;

&lt;h3 id=&#34;runstantプロジェクトへのリンク&#34;&gt;runstantプロジェクトへのリンク&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://runstant.com/alkn203/projects/943f0dea&#34;&gt;http://runstant.com/alkn203/projects/943f0dea&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>